{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Namespace = void 0;\n\nvar socket_1 = require(\"./socket\");\n\nvar events_1 = require(\"events\");\n\nvar socket_io_parser_1 = require(\"socket.io-parser\");\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"socket.io:namespace\");\n\nvar Namespace = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Namespace, _events_1$EventEmitte);\n\n  var _super = _createSuper(Namespace);\n\n  /**\n   * Namespace constructor.\n   *\n   * @param {Server} server instance\n   * @param {string} name\n   */\n  function Namespace(server, name) {\n    var _this;\n\n    _classCallCheck(this, Namespace);\n\n    _this = _super.call(this);\n    _this.sockets = new Map();\n    /** @private */\n\n    _this._fns = [];\n    /** @private */\n\n    _this._rooms = new Set();\n    /** @private */\n\n    _this._flags = {};\n    /** @private */\n\n    _this._ids = 0;\n    _this.server = server;\n    _this.name = name;\n\n    _this._initAdapter();\n\n    return _this;\n  }\n  /**\n   * Initializes the `Adapter` for this nsp.\n   * Run upon changing adapter by `Server#adapter`\n   * in addition to the constructor.\n   *\n   * @private\n   */\n\n\n  _createClass(Namespace, [{\n    key: \"_initAdapter\",\n    value: function _initAdapter() {\n      this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Sets up namespace middleware.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"use\",\n    value: function use(fn) {\n      this._fns.push(fn);\n\n      return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param {Socket} socket - the socket that will get added\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(socket, fn) {\n      var fns = this._fns.slice(0);\n\n      if (!fns.length) return fn(null);\n\n      function run(i) {\n        fns[i](socket, function (err) {\n          // upon error, short-circuit\n          if (err) return fn(err); // if no middleware left, summon callback\n\n          if (!fns[i + 1]) return fn(null); // go on to next\n\n          run(i + 1);\n        });\n      }\n\n      run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param {String} name\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"to\",\n    value: function to(name) {\n      this._rooms.add(name);\n\n      return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param {String} name\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in(name) {\n      this._rooms.add(name);\n\n      return this;\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */\n\n  }, {\n    key: \"_add\",\n    value: function _add(client, query, fn) {\n      var _this2 = this;\n\n      debug(\"adding socket to nsp %s\", this.name);\n      var socket = new socket_1.Socket(this, client, query);\n      this.run(socket, function (err) {\n        process.nextTick(function () {\n          if (\"open\" == client.conn.readyState) {\n            if (err) return socket._error({\n              message: err.message,\n              data: err.data\n            }); // track socket\n\n            _this2.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic\n            // fires before user-set events to prevent state order\n            // violations (such as a disconnection before the connection\n            // logic is complete)\n\n\n            socket._onconnect();\n\n            if (fn) fn(); // fire user-set events\n\n            _get(_getPrototypeOf(Namespace.prototype), \"emit\", _this2).call(_this2, \"connect\", socket);\n\n            _get(_getPrototypeOf(Namespace.prototype), \"emit\", _this2).call(_this2, \"connection\", socket);\n          } else {\n            debug(\"next called after client was closed - ignoring socket\");\n          }\n        });\n      });\n      return socket;\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(socket) {\n      if (this.sockets.has(socket.id)) {\n        this.sockets.delete(socket.id);\n      } else {\n        debug(\"ignoring remove for %s\", socket.id);\n      }\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return {Boolean} Always true\n     * @public\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      if (socket_1.RESERVED_EVENTS.has(ev)) {\n        throw new Error(\"\\\"\".concat(ev, \"\\\" is a reserved event name\"));\n      } // set up packet object\n\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      args.unshift(ev);\n      var packet = {\n        type: socket_io_parser_1.PacketType.EVENT,\n        data: args\n      };\n\n      if (\"function\" == typeof args[args.length - 1]) {\n        throw new Error(\"Callbacks are not supported when broadcasting\");\n      }\n\n      var rooms = new Set(this._rooms);\n      var flags = Object.assign({}, this._flags); // reset flags\n\n      this._rooms.clear();\n\n      this._flags = {};\n      this.adapter.broadcast(packet, {\n        rooms: rooms,\n        flags: flags\n      });\n      return true;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      args.unshift(\"message\");\n      this.emit.apply(this, args);\n      return this;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"write\",\n    value: function write() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      args.unshift(\"message\");\n      this.emit.apply(this, args);\n      return this;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"allSockets\",\n    value: function allSockets() {\n      if (!this.adapter) {\n        throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n      }\n\n      var rooms = new Set(this._rooms);\n\n      this._rooms.clear();\n\n      return this.adapter.sockets(rooms);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(_compress) {\n      this._flags.compress = _compress;\n      return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"volatile\",\n    get: function get() {\n      this._flags.volatile = true;\n      return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n\n  }, {\n    key: \"local\",\n    get: function get() {\n      this._flags.local = true;\n      return this;\n    }\n  }]);\n\n  return Namespace;\n}(events_1.EventEmitter);\n\nexports.Namespace = Namespace;","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io/dist/namespace.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Namespace","socket_1","require","events_1","socket_io_parser_1","debug_1","debug","default","server","name","sockets","Map","_fns","_rooms","Set","_flags","_ids","_initAdapter","adapter","fn","push","socket","fns","slice","length","run","i","err","add","client","query","Socket","process","nextTick","conn","readyState","_error","message","data","set","id","_onconnect","has","delete","ev","RESERVED_EVENTS","Error","args","unshift","packet","type","PacketType","EVENT","rooms","flags","assign","clear","broadcast","emit","apply","compress","volatile","local","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Namespace = void 0;\nconst socket_1 = require(\"./socket\");\nconst events_1 = require(\"events\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"socket.io:namespace\");\nclass Namespace extends events_1.EventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param {Server} server instance\n     * @param {string} name\n     */\n    constructor(server, name) {\n        super();\n        this.sockets = new Map();\n        /** @private */\n        this._fns = [];\n        /** @private */\n        this._rooms = new Set();\n        /** @private */\n        this._flags = {};\n        /** @private */\n        this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */\n    _initAdapter() {\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Sets up namespace middleware.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n    use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param {Socket} socket - the socket that will get added\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */\n    run(socket, fn) {\n        const fns = this._fns.slice(0);\n        if (!fns.length)\n            return fn(null);\n        function run(i) {\n            fns[i](socket, function (err) {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn(null);\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param {String} name\n     * @return {Namespace} self\n     * @public\n     */\n    to(name) {\n        this._rooms.add(name);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param {String} name\n     * @return {Namespace} self\n     * @public\n     */\n    in(name) {\n        this._rooms.add(name);\n        return this;\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */\n    _add(client, query, fn) {\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = new socket_1.Socket(this, client, query);\n        this.run(socket, err => {\n            process.nextTick(() => {\n                if (\"open\" == client.conn.readyState) {\n                    if (err)\n                        return socket._error({\n                            message: err.message,\n                            data: err.data\n                        });\n                    // track socket\n                    this.sockets.set(socket.id, socket);\n                    // it's paramount that the internal `onconnect` logic\n                    // fires before user-set events to prevent state order\n                    // violations (such as a disconnection before the connection\n                    // logic is complete)\n                    socket._onconnect();\n                    if (fn)\n                        fn();\n                    // fire user-set events\n                    super.emit(\"connect\", socket);\n                    super.emit(\"connection\", socket);\n                }\n                else {\n                    debug(\"next called after client was closed - ignoring socket\");\n                }\n            });\n        });\n        return socket;\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            this.sockets.delete(socket.id);\n        }\n        else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return {Boolean} Always true\n     * @public\n     */\n    emit(ev, ...args) {\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${ev}\" is a reserved event name`);\n        }\n        // set up packet object\n        args.unshift(ev);\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args\n        };\n        if (\"function\" == typeof args[args.length - 1]) {\n            throw new Error(\"Callbacks are not supported when broadcasting\");\n        }\n        const rooms = new Set(this._rooms);\n        const flags = Object.assign({}, this._flags);\n        // reset flags\n        this._rooms.clear();\n        this._flags = {};\n        this.adapter.broadcast(packet, {\n            rooms: rooms,\n            flags: flags\n        });\n        return true;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n    write(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        const rooms = new Set(this._rooms);\n        this._rooms.clear();\n        return this.adapter.sockets(rooms);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Namespace} self\n     * @public\n     */\n    compress(compress) {\n        this._flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return {Namespace} self\n     * @public\n     */\n    get volatile() {\n        this._flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return {Namespace} self\n     * @public\n     */\n    get local() {\n        this._flags.local = true;\n        return this;\n    }\n}\nexports.Namespace = Namespace;\n"]},"metadata":{},"sourceType":"script"}