{"ast":null,"code":"import _classCallCheck from\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/esm/createClass\";import _assertThisInitialized from\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";import _inherits from\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/esm/createSuper\";import Phaser from'phaser';var lightningHB=/*#__PURE__*/function(_Phaser$Physics$Arcad){_inherits(lightningHB,_Phaser$Physics$Arcad);var _super=_createSuper(lightningHB);function lightningHB(scene,x,y,texture){var _this;var _ref=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{},owner=_ref.owner,animationSprite=_ref.animationSprite,Olength=_ref.Olength;_classCallCheck(this,lightningHB);_this=_super.call(this,scene,x,y,texture);//Adds sprite to screen\nscene.add.existing(_assertThisInitialized(_this));//Adds physics to sprite\nscene.physics.add.existing(_assertThisInitialized(_this));_this.setCircle(16);//The sprite is an invisible hitbox\n_this.setVisible(false);_this.texture=texture;//Track which animation sprite this lightning hitbox belongs to. This is needed for collisions.\n_this.animationSprite=animationSprite;_this.owner=owner;//Center \n_this.x=x+owner.width-8;_this.y=y+owner.height-8;_this.oscillationLength=Olength;_this.startingOlength=Olength;_this.orientationx=owner.getOrientationVector().x;_this.orientationy=owner.getOrientationVector().y;//Creates a recursive, growing oscillation distance that accelerates with the lightning \n//bolt. \n//This allows for an illision of a diagonal, rotating hitbox that arcade physics cannot create,\n//I'd rather not have to use matter just for diagonal hitboxes,\n//or resort to custom hitboxes and collision detection in the update loop\n_this.scene.tweens.add({targets:_assertThisInitialized(_this),x:_this.x+_this.oscillationLength*_this.orientationx,y:_this.y+_this.oscillationLength*_this.orientationy,duration:100,yoyo:true,onComplete:onCompleteHandler,onCompleteParams:[_this.scene]});//Recursive callback function that allows for a growing oscillation length to our circular hitbox, simulating a non AABB hitbox effectively\nfunction onCompleteHandler(tween,targets,scene){var self=targets[0];if(self){//Each iteration, this multiplies the distance,\n//an exponential growth occurs\nself.oscillationLength*=3;//This runs while the hitboxes don't move at max length\nif(self.oscillationLength<=1000*self.startingOlength/100){self.scene.tweens.add({targets:self,x:self.x+self.oscillationLength*self.orientationx,y:self.y+self.oscillationLength*self.orientationy,duration:100,yoyo:true,onComplete:onCompleteHandler});}//This runs once the hitboxes have reached the maximum range of movement\nelse{if(self){self.scene.tweens.add({targets:self,//1000 is maximum blast length, then a ratio of that length is calculated in x and y distances\nx:self.x+1000*self.orientationx*self.startingOlength/100,y:self.y+1000*self.orientationy*self.startingOlength/100,duration:100,onComplete:countRuns,repeat:10,yoyo:true});}}}};//This function destroys the object\nfunction countRuns(tween,targets,scene){var self=targets[0];self.destroy();}return _this;}//Reference to animation sprite to destroy for collisions\n_createClass(lightningHB,[{key:\"destroyAnimationSprite\",value:function destroyAnimationSprite(){this.animationSprite.destroy();}},{key:\"getOwner\",value:function getOwner(){return this.owner;}}]);return lightningHB;}(Phaser.Physics.Arcade.Sprite);export{lightningHB as default};","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/src/phaser/sprites/lightningBoltHitbox.js"],"names":["Phaser","lightningHB","scene","x","y","texture","owner","animationSprite","Olength","add","existing","physics","setCircle","setVisible","width","height","oscillationLength","startingOlength","orientationx","getOrientationVector","orientationy","tweens","targets","duration","yoyo","onComplete","onCompleteHandler","onCompleteParams","tween","self","countRuns","repeat","destroy","Physics","Arcade","Sprite"],"mappings":"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","sourcesContent":["import Phaser from 'phaser';\r\nexport default class lightningHB extends Phaser.Physics.Arcade.Sprite\r\n    {\r\n\r\n        constructor (scene,x,y,texture,{owner, animationSprite, Olength}={})\r\n        {\r\n            super(scene,x,y,texture);\r\n            //Adds sprite to screen\r\n            scene.add.existing(this);\r\n\r\n            //Adds physics to sprite\r\n            scene.physics.add.existing(this);\r\n            this.setCircle(16);\r\n            //The sprite is an invisible hitbox\r\n            this.setVisible(false);\r\n\r\n            this.texture = texture;\r\n\r\n            //Track which animation sprite this lightning hitbox belongs to. This is needed for collisions.\r\n            this.animationSprite = animationSprite;\r\n\r\n            this.owner = owner;\r\n            \r\n            //Center \r\n            this.x = x+owner.width-8;\r\n            this.y = y+owner.height-8;\r\n            this.oscillationLength = Olength;\r\n            this.startingOlength = Olength;\r\n            this.orientationx = owner.getOrientationVector().x;\r\n            this.orientationy = owner.getOrientationVector().y;\r\n            \r\n            //Creates a recursive, growing oscillation distance that accelerates with the lightning \r\n            //bolt. \r\n            //This allows for an illision of a diagonal, rotating hitbox that arcade physics cannot create,\r\n            //I'd rather not have to use matter just for diagonal hitboxes,\r\n            //or resort to custom hitboxes and collision detection in the update loop\r\n            this.scene.tweens.add({\r\n                targets: this,\r\n                x: this.x + this.oscillationLength*this.orientationx,\r\n                y: this.y + this.oscillationLength*this.orientationy,\r\n                duration: 100,\r\n                yoyo: true,\r\n                onComplete: onCompleteHandler,\r\n                onCompleteParams: [this.scene]\r\n            });\r\n           //Recursive callback function that allows for a growing oscillation length to our circular hitbox, simulating a non AABB hitbox effectively\r\n           function onCompleteHandler(tween, targets, scene){\r\n                let self = targets[0];\r\n                if(self){\r\n                        //Each iteration, this multiplies the distance,\r\n                        //an exponential growth occurs\r\n                        self.oscillationLength *= 3;\r\n                    //This runs while the hitboxes don't move at max length\r\n                    if (self.oscillationLength <= 1000*self.startingOlength/100){\r\n                            self.scene.tweens.add({\r\n                            targets: self,\r\n                            x: self.x + self.oscillationLength*self.orientationx,\r\n                            y: self.y + self.oscillationLength*self.orientationy,\r\n                            duration: 100,\r\n                            yoyo: true,\r\n                            onComplete: onCompleteHandler,\r\n                        \r\n                        });\r\n                    }\r\n                    //This runs once the hitboxes have reached the maximum range of movement\r\n                    else {\r\n                        if (self){\r\n                            self.scene.tweens.add({\r\n                            targets: self,\r\n                            //1000 is maximum blast length, then a ratio of that length is calculated in x and y distances\r\n                            x: self.x + 1000*self.orientationx*self.startingOlength/100,\r\n                            y: self.y + 1000*self.orientationy*self.startingOlength/100,\r\n                            duration: 100,\r\n                            onComplete: countRuns,\r\n                            repeat: 10,\r\n                            yoyo: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n               \r\n            };\r\n            //This function destroys the object\r\n            function countRuns(tween, targets, scene){\r\n                let self = targets[0];\r\n                self.destroy();\r\n            }\r\n            \r\n        }\r\n        //Reference to animation sprite to destroy for collisions\r\n        destroyAnimationSprite(){\r\n            this.animationSprite.destroy();\r\n        }\r\n        getOwner(){\r\n          return this.owner;\r\n        }\r\n        \r\n        \r\n      \r\n    }"]},"metadata":{},"sourceType":"module"}