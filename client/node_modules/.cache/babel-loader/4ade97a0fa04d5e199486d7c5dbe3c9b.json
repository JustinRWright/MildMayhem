{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n(function (exports, io) {\n  /**\n   * Expose constructor.\n   */\n  exports.flashsocket = Flashsocket;\n  /**\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n   * specification. It uses a .swf file to communicate with the server. If you want\n   * to serve the .swf file from a other server than where the Socket.IO script is\n   * coming from you need to use the insecure version of the .swf. More information\n   * about this can be found on the github page.\n   *\n   * @constructor\n   * @extends {io.Transport.websocket}\n   * @api public\n   */\n\n  function Flashsocket() {\n    io.Transport.websocket.apply(this, arguments);\n  }\n\n  ;\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(Flashsocket, io.Transport.websocket);\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  Flashsocket.prototype.name = 'flashsocket';\n  /**\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.open = function () {\n    var self = this,\n        args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.open.apply(self, args);\n    });\n\n    return this;\n  };\n  /**\n   * Sends a message to the Socket.IO server. This is done by adding a new\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n\n  Flashsocket.prototype.send = function () {\n    var self = this,\n        args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.send.apply(self, args);\n    });\n\n    return this;\n  };\n  /**\n   * Disconnects the established `FlashSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n\n  Flashsocket.prototype.close = function () {\n    WebSocket.__tasks.length = 0;\n    io.Transport.websocket.prototype.close.call(this);\n    return this;\n  };\n  /**\n   * The WebSocket fall back needs to append the flash container to the body\n   * element, so we need to make sure we have access to it. Or defer the call\n   * until we are sure there is a body element.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n\n  Flashsocket.prototype.ready = function (socket, fn) {\n    function init() {\n      var options = socket.options,\n          port = options['flash policy port'],\n          path = ['http' + (options.secure ? 's' : '') + ':/', options.host + ':' + options.port, options.resource, 'static/flashsocket', 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf']; // Only start downloading the swf file when the checked that this browser\n      // actually supports it\n\n      if (!Flashsocket.loaded) {\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n          // Set the correct file based on the XDomain settings\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\n        }\n\n        if (port !== 843) {\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n        }\n\n        WebSocket.__initialize();\n\n        Flashsocket.loaded = true;\n      }\n\n      fn.call(self);\n    }\n\n    var self = this;\n    if (document.body) return init();\n    io.util.load(init);\n  };\n  /**\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n   * the polyfill is correctly loaded.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n\n  Flashsocket.check = function () {\n    if (typeof WebSocket == 'undefined' || !('__initialize' in WebSocket) || !swfobject) return false;\n    return swfobject.getFlashPlayerVersion().major >= 10;\n  };\n  /**\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \n   * transport. Because we can't see which type (secure or insecure) of .swf is used\n   * we will just return true.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n\n  Flashsocket.xdomainCheck = function () {\n    return true;\n  };\n  /**\n   * Disable AUTO_INITIALIZATION\n   */\n\n\n  if (typeof window != 'undefined') {\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n  }\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n\n  io.transports.push('flashsocket');\n})('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/transports/flashsocket.js"],"names":["exports","io","flashsocket","Flashsocket","Transport","websocket","apply","arguments","util","inherit","prototype","name","open","self","args","WebSocket","__addTask","send","close","__tasks","length","call","ready","socket","fn","init","options","port","path","secure","host","resource","isXDomain","loaded","WEB_SOCKET_SWF_LOCATION","join","loadFlashPolicyFile","__initialize","document","body","load","check","swfobject","getFlashPlayerVersion","major","xdomainCheck","window","WEB_SOCKET_DISABLE_AUTO_INITIALIZATION","transports","push","module","parent"],"mappings":"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","sourcesContent":["\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.flashsocket = Flashsocket;\n\n  /**\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n   * specification. It uses a .swf file to communicate with the server. If you want\n   * to serve the .swf file from a other server than where the Socket.IO script is\n   * coming from you need to use the insecure version of the .swf. More information\n   * about this can be found on the github page.\n   *\n   * @constructor\n   * @extends {io.Transport.websocket}\n   * @api public\n   */\n\n  function Flashsocket () {\n    io.Transport.websocket.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(Flashsocket, io.Transport.websocket);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  Flashsocket.prototype.name = 'flashsocket';\n\n  /**\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.open = function () {\n    var self = this\n      , args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.open.apply(self, args);\n    });\n    return this;\n  };\n  \n  /**\n   * Sends a message to the Socket.IO server. This is done by adding a new\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.send = function () {\n    var self = this, args = arguments;\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.send.apply(self, args);\n    });\n    return this;\n  };\n\n  /**\n   * Disconnects the established `FlashSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.close = function () {\n    WebSocket.__tasks.length = 0;\n    io.Transport.websocket.prototype.close.call(this);\n    return this;\n  };\n\n  /**\n   * The WebSocket fall back needs to append the flash container to the body\n   * element, so we need to make sure we have access to it. Or defer the call\n   * until we are sure there is a body element.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Flashsocket.prototype.ready = function (socket, fn) {\n    function init () {\n      var options = socket.options\n        , port = options['flash policy port']\n        , path = [\n              'http' + (options.secure ? 's' : '') + ':/'\n            , options.host + ':' + options.port\n            , options.resource\n            , 'static/flashsocket'\n            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n          ];\n\n      // Only start downloading the swf file when the checked that this browser\n      // actually supports it\n      if (!Flashsocket.loaded) {\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n          // Set the correct file based on the XDomain settings\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\n        }\n\n        if (port !== 843) {\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n        }\n\n        WebSocket.__initialize();\n        Flashsocket.loaded = true;\n      }\n\n      fn.call(self);\n    }\n\n    var self = this;\n    if (document.body) return init();\n\n    io.util.load(init);\n  };\n\n  /**\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n   * the polyfill is correctly loaded.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.check = function () {\n    if (\n        typeof WebSocket == 'undefined'\n      || !('__initialize' in WebSocket) || !swfobject\n    ) return false;\n\n    return swfobject.getFlashPlayerVersion().major >= 10;\n  };\n\n  /**\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \n   * transport. Because we can't see which type (secure or insecure) of .swf is used\n   * we will just return true.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Disable AUTO_INITIALIZATION\n   */\n\n  if (typeof window != 'undefined') {\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n  }\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('flashsocket');\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n"]},"metadata":{},"sourceType":"script"}