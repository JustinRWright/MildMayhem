{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar qs = require(\"querystring\");\n\nvar parse = require(\"url\").parse;\n\nvar base64id = require(\"base64id\");\n\nvar transports = require(\"./transports\");\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar Socket = require(\"./socket\");\n\nvar debug = require(\"debug\")(\"engine\");\n\nvar cookieMod = require(\"cookie\");\n\nvar Server = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(Server, _EventEmitter);\n\n  var _super = _createSuper(Server);\n\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  function Server() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Server);\n\n    _this = _super.call(this);\n    _this.clients = {};\n    _this.clientsCount = 0;\n    _this.opts = Object.assign({\n      wsEngine: process.env.EIO_WS_ENGINE || \"ws\",\n      pingTimeout: 5000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: Object.keys(transports),\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false\n    }, opts);\n\n    if (opts.cookie) {\n      _this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (_this.opts.cors) {\n      _this.corsMiddleware = require(\"cors\")(_this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      _this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    _this.init();\n\n    return _this;\n  }\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n\n\n  _createClass(Server, [{\n    key: \"init\",\n    value: function init() {\n      if (!~this.opts.transports.indexOf(\"websocket\")) return;\n      if (this.ws) this.ws.close(); // add explicit require for bundlers like webpack\n\n      var wsModule = this.opts.wsEngine === \"ws\" ? require(\"ws\") : require(this.opts.wsEngine);\n      this.ws = new wsModule.Server({\n        noServer: true,\n        clientTracking: false,\n        perMessageDeflate: this.opts.perMessageDeflate,\n        maxPayload: this.opts.maxHttpBufferSize\n      });\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     * @api public\n     */\n\n  }, {\n    key: \"upgrades\",\n    value: function upgrades(transport) {\n      if (!this.opts.allowUpgrades) return [];\n      return transports[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(req, upgrade, fn) {\n      // transport check\n      var transport = req._query.transport;\n\n      if (!~this.opts.transports.indexOf(transport)) {\n        debug('unknown transport \"%s\"', transport);\n        return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n      } // 'Origin' header check\n\n\n      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n      if (isOriginInvalid) {\n        req.headers.origin = null;\n        debug(\"origin header invalid\");\n        return fn(Server.errors.BAD_REQUEST, false);\n      } // sid check\n\n\n      var sid = req._query.sid;\n\n      if (sid) {\n        if (!this.clients.hasOwnProperty(sid)) {\n          debug('unknown sid \"%s\"', sid);\n          return fn(Server.errors.UNKNOWN_SID, false);\n        }\n\n        if (!upgrade && this.clients[sid].transport.name !== transport) {\n          debug(\"bad request: unexpected transport without upgrade\");\n          return fn(Server.errors.BAD_REQUEST, false);\n        }\n      } else {\n        // handshake is GET only\n        if (\"GET\" !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n        if (!this.opts.allowRequest) return fn(null, true);\n        return this.opts.allowRequest(req, fn);\n      }\n\n      fn(null, true);\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(req) {\n      // try to leverage pre-existing `req._query` (e.g: from connect)\n      if (!req._query) {\n        req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n      }\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      debug(\"closing all open clients\");\n\n      for (var i in this.clients) {\n        if (this.clients.hasOwnProperty(i)) {\n          this.clients[i].close(true);\n        }\n      }\n\n      if (this.ws) {\n        debug(\"closing webSocketServer\");\n        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n      }\n\n      return this;\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {http.ServerResponse|http.OutgoingMessage} response\n     * @api public\n     */\n\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(req, res) {\n      var _this2 = this;\n\n      debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n      this.prepare(req);\n      req.res = res;\n\n      var callback = function callback(err, success) {\n        if (!success) {\n          sendErrorMessage(req, res, err);\n          return;\n        }\n\n        if (req._query.sid) {\n          debug(\"setting new request for existing client\");\n\n          _this2.clients[req._query.sid].transport.onRequest(req);\n        } else {\n          _this2.handshake(req._query.transport, req);\n        }\n      };\n\n      if (this.corsMiddleware) {\n        this.corsMiddleware.call(null, req, res, function () {\n          _this2.verify(req, false, callback);\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n\n  }, {\n    key: \"generateId\",\n    value: function generateId(req) {\n      return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @api private\n     */\n\n  }, {\n    key: \"handshake\",\n    value: function () {\n      var _handshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(transportName, req) {\n        var _this3 = this;\n\n        var id, transport, socket, self;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.generateId(req);\n\n              case 3:\n                id = _context.sent;\n                _context.next = 11;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                debug(\"error while generating an id\");\n                sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 11:\n                debug('handshaking client \"%s\"', id);\n                _context.prev = 12;\n                transport = new transports[transportName](req);\n\n                if (\"polling\" === transportName) {\n                  transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                  transport.httpCompression = this.opts.httpCompression;\n                } else if (\"websocket\" === transportName) {\n                  transport.perMessageDeflate = this.opts.perMessageDeflate;\n                }\n\n                if (req._query && req._query.b64) {\n                  transport.supportsBinary = false;\n                } else {\n                  transport.supportsBinary = true;\n                }\n\n                _context.next = 23;\n                break;\n\n              case 18:\n                _context.prev = 18;\n                _context.t1 = _context[\"catch\"](12);\n                debug('error handshaking to transport \"%s\"', transportName);\n                sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 23:\n                socket = new Socket(id, this, transport, req);\n                self = this;\n\n                if (this.opts.cookie) {\n                  transport.on(\"headers\", function (headers) {\n                    headers[\"Set-Cookie\"] = cookieMod.serialize(_this3.opts.cookie.name, id, _this3.opts.cookie);\n                  });\n                }\n\n                transport.onRequest(req);\n                this.clients[id] = socket;\n                this.clientsCount++;\n                socket.once(\"close\", function () {\n                  delete self.clients[id];\n                  self.clientsCount--;\n                });\n                this.emit(\"connection\", socket);\n\n              case 31:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6], [12, 18]]);\n      }));\n\n      function handshake(_x, _x2) {\n        return _handshake.apply(this, arguments);\n      }\n\n      return handshake;\n    }()\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, upgradeHead) {\n      this.prepare(req);\n      var self = this;\n      this.verify(req, true, function (err, success) {\n        if (!success) {\n          abortConnection(socket, err);\n          return;\n        }\n\n        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n        upgradeHead = null; // delegate to ws\n\n        self.ws.handleUpgrade(req, socket, head, function (conn) {\n          self.onWebSocket(req, conn);\n        });\n      });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n\n  }, {\n    key: \"onWebSocket\",\n    value: function onWebSocket(req, socket) {\n      socket.on(\"error\", onUpgradeError);\n\n      if (transports[req._query.transport] !== undefined && !transports[req._query.transport].prototype.handlesUpgrades) {\n        debug(\"transport doesnt handle upgraded requests\");\n        socket.close();\n        return;\n      } // get client id\n\n\n      var id = req._query.sid; // keep a reference to the ws.Socket\n\n      req.websocket = socket;\n\n      if (id) {\n        var client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          socket.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          socket.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          socket.close();\n        } else {\n          debug(\"upgrading existing transport\"); // transport error handling takes over\n\n          socket.removeListener(\"error\", onUpgradeError);\n          var transport = new transports[req._query.transport](req);\n\n          if (req._query && req._query.b64) {\n            transport.supportsBinary = false;\n          } else {\n            transport.supportsBinary = true;\n          }\n\n          transport.perMessageDeflate = this.perMessageDeflate;\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        // transport error handling takes over\n        socket.removeListener(\"error\", onUpgradeError);\n        this.handshake(req._query.transport, req);\n      }\n\n      function onUpgradeError() {\n        debug(\"websocket error before upgrade\"); // socket.close() not needed\n      }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(server, options) {\n      var self = this;\n      options = options || {};\n      var path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n      path += \"/\";\n\n      function check(req) {\n        return path === req.url.substr(0, path.length);\n      } // cache and clean up listeners\n\n\n      var listeners = server.listeners(\"request\").slice(0);\n      server.removeAllListeners(\"request\");\n      server.on(\"close\", self.close.bind(self));\n      server.on(\"listening\", self.init.bind(self)); // add request handler\n\n      server.on(\"request\", function (req, res) {\n        if (check(req)) {\n          debug('intercepting request for path \"%s\"', path);\n          self.handleRequest(req, res);\n        } else {\n          var i = 0;\n          var l = listeners.length;\n\n          for (; i < l; i++) {\n            listeners[i].call(server, req, res);\n          }\n        }\n      });\n\n      if (~self.opts.transports.indexOf(\"websocket\")) {\n        server.on(\"upgrade\", function (req, socket, head) {\n          if (check(req)) {\n            self.handleUpgrade(req, socket, head);\n          } else if (false !== options.destroyUpgrade) {\n            // default node behavior is to disconnect when no handlers\n            // but by adding a handler, we prevent that\n            // and if no eio thing handles the upgrade\n            // then the socket needs to die!\n            setTimeout(function () {\n              if (socket.writable && socket.bytesWritten <= 0) {\n                return socket.end();\n              }\n            }, destroyUpgradeTimeout);\n          }\n        });\n      }\n    }\n  }]);\n\n  return Server;\n}(EventEmitter);\n/**\n * Protocol errors mappings.\n */\n\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4\n};\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\"\n};\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\nfunction sendErrorMessage(req, res, code) {\n  var headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  var isForbidden = !Server.errorMessages.hasOwnProperty(code);\n\n  if (isForbidden) {\n    res.writeHead(403, headers);\n    res.end(JSON.stringify({\n      code: Server.errors.FORBIDDEN,\n      message: code || Server.errorMessages[Server.errors.FORBIDDEN]\n    }));\n    return;\n  }\n\n  if (res !== undefined) {\n    res.writeHead(400, headers);\n    res.end(JSON.stringify({\n      code: code,\n      message: Server.errorMessages[code]\n    }));\n  }\n}\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\n\nfunction abortConnection(socket, code) {\n  socket.on(\"error\", function () {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : String(code || \"\");\n    var length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n\nmodule.exports = Server;\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\n\nvar validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (var i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/engine.io/lib/server.js"],"names":["qs","require","parse","base64id","transports","EventEmitter","Socket","debug","cookieMod","Server","opts","clients","clientsCount","Object","assign","wsEngine","process","env","EIO_WS_ENGINE","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","keys","allowUpgrades","httpCompression","threshold","cors","cookie","name","path","httpOnly","sameSite","corsMiddleware","perMessageDeflate","init","indexOf","ws","close","wsModule","noServer","clientTracking","maxPayload","transport","upgradesTo","req","upgrade","fn","_query","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","sid","hasOwnProperty","UNKNOWN_SID","method","BAD_HANDSHAKE_METHOD","allowRequest","url","query","i","res","prepare","callback","err","success","sendErrorMessage","onRequest","handshake","call","verify","generateId","transportName","id","b64","supportsBinary","socket","self","on","serialize","once","emit","upgradeHead","abortConnection","head","Buffer","from","handleUpgrade","conn","onWebSocket","onUpgradeError","undefined","prototype","handlesUpgrades","websocket","client","upgrading","upgraded","removeListener","maybeUpgrade","server","options","replace","destroyUpgradeTimeout","check","substr","length","listeners","slice","removeAllListeners","bind","handleRequest","l","destroyUpgrade","setTimeout","writable","bytesWritten","end","FORBIDDEN","errorMessages","code","isForbidden","writeHead","JSON","stringify","message","String","byteLength","write","destroy","module","exports","validHdrChars","val","charCodeAt"],"mappings":"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","sourcesContent":["const qs = require(\"querystring\");\nconst parse = require(\"url\").parse;\nconst base64id = require(\"base64id\");\nconst transports = require(\"./transports\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst Socket = require(\"./socket\");\nconst debug = require(\"debug\")(\"engine\");\nconst cookieMod = require(\"cookie\");\n\nclass Server extends EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: process.env.EIO_WS_ENGINE || \"ws\",\n        pingTimeout: 5000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024\n        },\n        cors: false\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\"\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    // add explicit require for bundlers like webpack\n    const wsModule =\n      this.opts.wsEngine === \"ws\" ? require(\"ws\") : require(this.opts.wsEngine);\n    this.ws = new wsModule.Server({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, false);\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, false);\n      }\n      if (!upgrade && this.clients[sid].transport.name !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, false);\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method)\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n      if (!this.opts.allowRequest) return fn(null, true);\n      return this.opts.allowRequest(req, fn);\n    }\n\n    fn(null, true);\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n    return this;\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {http.ServerResponse|http.OutgoingMessage} response\n   * @api public\n   */\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (err, success) => {\n      if (!success) {\n        sendErrorMessage(req, res, err);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        this.handshake(req._query.transport, req);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @api private\n   */\n  async handshake(transportName, req) {\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = new transports[transportName](req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req);\n    const self = this;\n\n    if (this.opts.cookie) {\n      transport.on(\"headers\", headers => {\n        headers[\"Set-Cookie\"] = cookieMod.serialize(\n          this.opts.cookie.name,\n          id,\n          this.opts.cookie\n        );\n      });\n    }\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", function() {\n      delete self.clients[id];\n      self.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n\n    const self = this;\n    this.verify(req, true, function(err, success) {\n      if (!success) {\n        abortConnection(socket, err);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n      upgradeHead = null;\n\n      // delegate to ws\n      self.ws.handleUpgrade(req, socket, head, function(conn) {\n        self.onWebSocket(req, conn);\n      });\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  onWebSocket(req, socket) {\n    socket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      socket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = socket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        socket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        socket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        socket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        socket.removeListener(\"error\", onUpgradeError);\n\n        const transport = new transports[req._query.transport](req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      // transport error handling takes over\n      socket.removeListener(\"error\", onUpgradeError);\n\n      this.handshake(req._query.transport, req);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // socket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  attach(server, options) {\n    const self = this;\n    options = options || {};\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    // normalize path\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", self.close.bind(self));\n    server.on(\"listening\", self.init.bind(self));\n\n    // add request handler\n    server.on(\"request\", function(req, res) {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        self.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~self.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", function(req, socket, head) {\n        if (check(req)) {\n          self.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function() {\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4\n};\n\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\"\n};\n\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\nfunction sendErrorMessage(req, res, code) {\n  const headers = { \"Content-Type\": \"application/json\" };\n\n  const isForbidden = !Server.errorMessages.hasOwnProperty(code);\n  if (isForbidden) {\n    res.writeHead(403, headers);\n    res.end(\n      JSON.stringify({\n        code: Server.errors.FORBIDDEN,\n        message: code || Server.errorMessages[Server.errors.FORBIDDEN]\n      })\n    );\n    return;\n  }\n  if (res !== undefined) {\n    res.writeHead(400, headers);\n    res.end(\n      JSON.stringify({\n        code: code,\n        message: Server.errorMessages[code]\n      })\n    );\n  }\n}\n\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\nfunction abortConnection(socket, code) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = Server.errorMessages.hasOwnProperty(code)\n      ? Server.errorMessages[code]\n      : String(code || \"\");\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\nmodule.exports = Server;\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}