{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n(function (exports, io, global) {\n  /**\n   * Expose constructor.\n   */\n  exports.websocket = WS;\n  /**\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n   * persistent connection with the Socket.IO server. This transport will also\n   * be inherited by the FlashSocket fallback as it provides a API compatible\n   * polyfill for the WebSockets.\n   *\n   * @constructor\n   * @extends {io.Transport}\n   * @api public\n   */\n\n  function WS(socket) {\n    io.Transport.apply(this, arguments);\n  }\n\n  ;\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(WS, io.Transport);\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  WS.prototype.name = 'websocket';\n  /**\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n   * all the appropriate listeners to handle the responses from the server.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.open = function () {\n    var query = io.util.query(this.socket.options.query),\n        self = this,\n        Socket; // if node\n\n    Socket = require('ws'); // end node\n\n    if (!Socket) {\n      Socket = global.MozWebSocket || global.WebSocket;\n    }\n\n    this.websocket = new Socket(this.prepareUrl() + query);\n\n    this.websocket.onopen = function () {\n      self.onOpen();\n      self.socket.setBuffer(false);\n    };\n\n    this.websocket.onmessage = function (ev) {\n      self.onData(ev.data);\n    };\n\n    this.websocket.onclose = function () {\n      self.onClose();\n      self.socket.setBuffer(true);\n    };\n\n    this.websocket.onerror = function (e) {\n      self.onError(e);\n    };\n\n    return this;\n  };\n  /**\n   * Send a message to the Socket.IO server. The message will automatically be\n   * encoded in the correct message format.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n  // Do to a bug in the current IDevices browser, we need to wrap the send in a \n  // setTimeout, when they resume from sleeping the browser will crash if \n  // we don't allow the browser time to detect the socket has been closed\n\n\n  if (io.util.ua.iDevice) {\n    WS.prototype.send = function (data) {\n      var self = this;\n      setTimeout(function () {\n        self.websocket.send(data);\n      }, 0);\n      return this;\n    };\n  } else {\n    WS.prototype.send = function (data) {\n      this.websocket.send(data);\n      return this;\n    };\n  }\n  /**\n   * Payload\n   *\n   * @api private\n   */\n\n\n  WS.prototype.payload = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      this.packet(arr[i]);\n    }\n\n    return this;\n  };\n  /**\n   * Disconnect the established `WebSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n\n  WS.prototype.close = function () {\n    this.websocket.close();\n    return this;\n  };\n  /**\n   * Handle the errors that `WebSocket` might be giving when we\n   * are attempting to connect or send messages.\n   *\n   * @param {Error} e The error.\n   * @api private\n   */\n\n\n  WS.prototype.onError = function (e) {\n    this.socket.onError(e);\n  };\n  /**\n   * Returns the appropriate scheme for the URI generation.\n   *\n   * @api private\n   */\n\n\n  WS.prototype.scheme = function () {\n    return this.socket.options.secure ? 'wss' : 'ws';\n  };\n  /**\n   * Checks if the browser has support for native `WebSockets` and that\n   * it's not the polyfill created for the FlashSocket transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n\n  WS.check = function () {\n    // if node\n    return true; // end node\n\n    return 'WebSocket' in global && !('__addTask' in WebSocket) || 'MozWebSocket' in global;\n  };\n  /**\n   * Check if the `WebSocket` transport support cross domain communications.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n\n  WS.xdomainCheck = function () {\n    return true;\n  };\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n\n  io.transports.push('websocket');\n})('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/transports/websocket.js"],"names":["exports","io","global","websocket","WS","socket","Transport","apply","arguments","util","inherit","prototype","name","open","query","options","self","Socket","require","MozWebSocket","WebSocket","prepareUrl","onopen","onOpen","setBuffer","onmessage","ev","onData","data","onclose","onClose","onerror","e","onError","ua","iDevice","send","setTimeout","payload","arr","i","l","length","packet","close","scheme","secure","check","xdomainCheck","transports","push","module","parent"],"mappings":"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","sourcesContent":["\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.websocket = WS;\n\n  /**\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n   * persistent connection with the Socket.IO server. This transport will also\n   * be inherited by the FlashSocket fallback as it provides a API compatible\n   * polyfill for the WebSockets.\n   *\n   * @constructor\n   * @extends {io.Transport}\n   * @api public\n   */\n\n  function WS (socket) {\n    io.Transport.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(WS, io.Transport);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  WS.prototype.name = 'websocket';\n\n  /**\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n   * all the appropriate listeners to handle the responses from the server.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.open = function () {\n    var query = io.util.query(this.socket.options.query)\n      , self = this\n      , Socket\n\n    // if node\n    Socket = require('ws');\n    // end node\n\n    if (!Socket) {\n      Socket = global.MozWebSocket || global.WebSocket;\n    }\n\n    this.websocket = new Socket(this.prepareUrl() + query);\n\n    this.websocket.onopen = function () {\n      self.onOpen();\n      self.socket.setBuffer(false);\n    };\n    this.websocket.onmessage = function (ev) {\n      self.onData(ev.data);\n    };\n    this.websocket.onclose = function () {\n      self.onClose();\n      self.socket.setBuffer(true);\n    };\n    this.websocket.onerror = function (e) {\n      self.onError(e);\n    };\n\n    return this;\n  };\n\n  /**\n   * Send a message to the Socket.IO server. The message will automatically be\n   * encoded in the correct message format.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  // Do to a bug in the current IDevices browser, we need to wrap the send in a \n  // setTimeout, when they resume from sleeping the browser will crash if \n  // we don't allow the browser time to detect the socket has been closed\n  if (io.util.ua.iDevice) {\n    WS.prototype.send = function (data) {\n      var self = this;\n      setTimeout(function() {\n         self.websocket.send(data);\n      },0);\n      return this;\n    };\n  } else {\n    WS.prototype.send = function (data) {\n      this.websocket.send(data);\n      return this;\n    };\n  }\n\n  /**\n   * Payload\n   *\n   * @api private\n   */\n\n  WS.prototype.payload = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      this.packet(arr[i]);\n    }\n    return this;\n  };\n\n  /**\n   * Disconnect the established `WebSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.close = function () {\n    this.websocket.close();\n    return this;\n  };\n\n  /**\n   * Handle the errors that `WebSocket` might be giving when we\n   * are attempting to connect or send messages.\n   *\n   * @param {Error} e The error.\n   * @api private\n   */\n\n  WS.prototype.onError = function (e) {\n    this.socket.onError(e);\n  };\n\n  /**\n   * Returns the appropriate scheme for the URI generation.\n   *\n   * @api private\n   */\n  WS.prototype.scheme = function () {\n    return this.socket.options.secure ? 'wss' : 'ws';\n  };\n\n  /**\n   * Checks if the browser has support for native `WebSockets` and that\n   * it's not the polyfill created for the FlashSocket transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  WS.check = function () {\n    // if node\n    return true;\n    // end node\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\n          || 'MozWebSocket' in global;\n  };\n\n  /**\n   * Check if the `WebSocket` transport support cross domain communications.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  WS.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('websocket');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n"]},"metadata":{},"sourceType":"script"}