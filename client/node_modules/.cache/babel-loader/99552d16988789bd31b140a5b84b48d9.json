{"ast":null,"code":"import { Scene } from 'phaser';\nimport Player from \"../sprites/Player.js\";\nimport Controls from \"../controls/Controls.js\";\nimport MagicBlast from \"../sprites/MagicBlast.js\";\nimport SwordSwing from \"../sprites/SwordSwing.js\";\nimport Phaser from 'phaser';\nimport bckg from '../assets/bckg.png';\nimport HealthBar from \"../sprites/HealthBar.js\";\nimport CoolDown from \"../sprites/CoolDown.js\";\nimport LightningBolt from '../sprites/lightningBolt.js';\nimport LightningHB from '../sprites/lightningBoltHitbox.js';\nimport io from 'socket.io-client'; //import proxy from 'socket.io-proxy';\n\nlet LocalGameScene = {\n  preload: function () {\n    //I load the images from my publicly hosted imgur\n    //because the file system seems to break for some reason when this is run in IonPhaser\n    //(Which is inside a React application)\n    //I make these drawings/spritesheets in piskel\n    this.load.image('bckg', 'https://i.imgur.com/DMVC2IQ.png');\n    this.load.image('wall', 'https://i.imgur.com/av8q7Or.png');\n    this.load.image('vwall', 'https://i.imgur.com/UB2GdEL.png');\n    this.load.spritesheet('swordSwing', 'https://i.imgur.com/ULyXfap.png', {\n      frameWidth: 500,\n      frameHeight: 500\n    });\n    this.load.image('swordCool', 'https://i.imgur.com/SnLjQdR.png');\n    this.load.image('blastCool', 'https://i.imgur.com/d4Enueh.png');\n    this.load.spritesheet('magicBlast', 'https://i.imgur.com/dEhNPqO.png', {\n      frameWidth: 150,\n      frameHeight: 150\n    });\n    this.load.spritesheet('explosion', 'https://i.imgur.com/UHZiUKC.png', {\n      frameWidth: 192,\n      frameHeight: 192\n    });\n    this.load.spritesheet('player', 'https://i.imgur.com/WlEeiKT.png', {\n      frameWidth: 68,\n      frameHeight: 68\n    });\n    this.load.spritesheet('otherPlayer', 'https://i.imgur.com/NYAJusD.png', {\n      frameWidth: 68,\n      frameHeight: 68\n    });\n    this.load.spritesheet('Background', 'https://i.imgur.com/8SzCikO.png', {\n      frameWidth: 800,\n      frameHeight: 600\n    });\n    this.load.image('dodgeCool', 'https://i.imgur.com/mTklmkU.png');\n    this.load.spritesheet('lightningBolt', 'https://i.imgur.com/3MskIUy.png', {\n      frameWidth: 16,\n      frameHeight: 1000\n    });\n    this.load.image('lightningCool', 'https://i.imgur.com/FVquIxw.png');\n  },\n  create: function () {\n    let self = this;\n    /*I define some of the functions ex:this.deflectBlast\r\n    this way instead of outside of the preload/create/update\r\n    because that is the way they don't throw an error while using IonPhaser,\r\n    Perhaps they can be moved to another file and imported in*/\n    //Deflect Magic Blast with sword\n\n    this.deflectBlast = function (magicBlast, swordHitbox) {\n      if (swordHitbox.inSwordSweep(magicBlast)) {\n        magicBlast.deflectFrom(swordHitbox.getOwner());\n      }\n    }; //Create explosion animation\n\n\n    this.explosionAnim = this.anims.create({\n      key: 'explode',\n      frames: this.anims.generateFrameNumbers('explosion', {\n        start: 1,\n        end: 23\n      }),\n      frameRate: 10,\n      repeat: -1\n    }); //This needs to be added because the player2 animation breaks when called for some reason, unsure why?\n    //It must have to do with something where 'explode' is played\n\n    this.explosionAnim = this.anims.create({\n      key: 'explode2',\n      frames: this.anims.generateFrameNumbers('explosion', {\n        start: 1,\n        end: 23\n      }),\n      frameRate: 10,\n      repeat: -1\n    }); //Callback function for player/magicBlast Collision\n\n    this.playerHit = function (magicBlast, player) {\n      //Check that the magicBlast is hitting the right player\n      if (magicBlast.getOwner() !== player) {\n        //In online mode, only the opposing player(who does not active hitbox in your game) will get hit, when they do, this is called\n        //Depending on how we implement magic blasts, this may require an index to be sent through for selecting and destroy the object\n        console.log('this.roomName is: ' + self.roomName);\n        self.socket.emit('destroyMagicBlast', self.roomName);\n        magicBlast.explode(); //Check if player is stunned or dodging, if neither is true, play stun animation and calculate damage\n\n        if (player.getStun() === false || player.getDodging() === false) {\n          self.socket.emit('damagePlayer', self.roomName);\n          player.playStun(); //Reduce player health\n          //When the healthbar reaches 0, this evaluates to true\n\n          if (player.getHealthBar().decrease(4)) {\n            //This function has the player blow up\n            player.gameOver();\n            player.anims.play('explode', true); //Win Screen and link people back to main menu   \n            //How could we access the react router DOM here?\n\n            let timedEvent = player.scene.time.delayedCall(3000, player.scene.redirect, [], this);\n          }\n\n          ; //Knock opponent backwards\n\n          player.knockBack(magicBlast);\n        }\n      }\n    }; //Collision between lightning and player\n\n\n    this.playerHitLightning = function (lightningBolt, player) {\n      //Players cannot hit themselves with their own attacks\n      if (lightningBolt.getOwner() !== player) {\n        if (player.getStun() === false && player.getDodging() === false) {\n          //Stun is started for player\n          player.playStun();\n          self.socket.emit('destroyLightningBolt', self.roomName);\n          self.socket.emit('damagePlayer', self.roomName);\n\n          if (player.getHealthBar().decrease(4)) {\n            //Player dies\n            player.gameOver();\n            player.anims.play('explode', true); //Send players back to main menu\n\n            let timedEvent = player.scene.time.delayedCall(3000, player.scene.redirect, [], this);\n          }\n\n          player.knockBack(lightningBolt); //Destroy the animation associated with these hitboxes\n\n          lightningBolt.destroyAnimationSprite(); //Find all other associated lightning bolt hitboxes and destroy them\n\n          lightningBolt.scene.lightningBolts.getChildren().forEach(lightningBolt => {\n            if (lightningBolt.getOwner() !== player) {\n              lightningBolt.body.enable = false;\n            }\n          });\n        }\n      }\n    }; //Callback for sending user back to main page when game ends\n\n\n    this.redirect = function () {\n      window.location.replace('http://localhost:3000/');\n    }; //Glowing Background Sprite\n\n\n    this.background = this.add.sprite(400, 300, 'Background');\n    this.anims.create({\n      key: 'glow',\n      frames: this.anims.generateFrameNumbers('Background', {\n        start: 1,\n        end: 12\n      }),\n      frameRate: 4,\n      repeat: -1,\n      yoyo: true\n    });\n    this.background.anims.play('glow'); //Refactoring idea: make every variable passed into constructors \n    //descriptive javascript properties for readability\n    //Create Health Bars\n\n    this.healthBarP1 = new HealthBar({\n      scene: this,\n      x: 0,\n      y: 584\n    });\n    this.healthBarP2 = new HealthBar({\n      scene: this,\n      x: 0,\n      y: 0\n    });\n    console.log('gameconfig is: ' + this.gameConfig);\n\n    if (this.gameConfig === 'joinOnline') {\n      this.player1 = new Player(this, 400, 200, 'otherPlayer', this.explosionAnim);\n      this.player2 = new Player(this, 400, 500, 'player', this.explosionAnim);\n      this.player1.setHealthBar(this.healthBarP2);\n      this.player2.setHealthBar(this.healthBarP1);\n      this.player1.createAnimations(this);\n      this.player2.createAnimations(this);\n      console.log('my id is: ' + this.socket.id);\n      this.player2.setVisible(true);\n    }\n\n    if (this.gameConfig === 'createOnline') {\n      this.player1 = new Player(this, 400, 500, 'player', this.explosionAnim);\n      this.player2 = new Player(this, 400, 200, 'otherPlayer', this.explosionAnim);\n      this.player1.setHealthBar(this.healthBarP1);\n      this.player2.setHealthBar(this.healthBarP2);\n      this.player1.createAnimations(this);\n      this.player2.createAnimations(this);\n      this.player2.setVisible(false);\n      this.socket.emit('createOnlineRoom');\n      this.socket.emit('getRoomName');\n    }\n\n    this.playerSetup = function (player, healthbar, swordCoolDown, winText) {};\n\n    this.player2.moving = false;\n    this.player2.moveTimer = 0;\n    this.socket.on('yourRoomName', function (roomName) {\n      console.log('myroomName is called here');\n      self.roomName = roomName;\n    });\n    this.socket.on('opponentJoined', function (opponentSocketId) {\n      self.player2.setVisible(true);\n      console.log('opponentJoined, id: ' + opponentSocketId);\n      self.opponentSocketId = opponentSocketId;\n      self.socket.emit('confirmJoinRoom', opponentSocketId);\n    });\n    this.socket.on('joinedRoom', function (opponentSocketId) {\n      console.log('joined Room socket event happened');\n      self.opponentSocketId = opponentSocketId;\n    });\n    this.socket.on('playerMoved', function (player2Movement) {\n      self.player2.moving = true;\n      self.player2.x = player2Movement.x;\n      self.player2.y = player2Movement.y;\n      self.player2.setOrientationVector(player2Movement.direction);\n\n      if (self.player2.isAlive()) {\n        self.player2.setMovementAnim(player2Movement.direction);\n      }\n    });\n    this.socket.on('swordSwung', function () {\n      self.onlinePlayerSwing(self.player2, self.swordCoolDownP2);\n    });\n    this.socket.on('magicBlastCreated', function () {\n      self.magicCoolDownP2.startCoolDown();\n      self.createMagicBlast(self.player2);\n    });\n    this.socket.on('magicBlastDestroyed', function () {\n      console.log('magicBlastDestroyed ran');\n      self.magicBlasts.getChildren().forEach(magicBlast => {\n        if (magicBlast.getOwner() !== self.player2) {\n          magicBlast.explode();\n        }\n      });\n    });\n    this.socket.on('playerDamaged', function () {\n      self.player2.playStun();\n\n      if (self.player2.getHealthBar().decrease(4)) {\n        self.player2.gameOver();\n        self.player2.anims.play('explode2', false);\n        let timedEvent = self.time.delayedCall(3000, self.redirect, [], self);\n      }\n    });\n    this.socket.on('lightningBoltCreated', function () {\n      self.createLightningBolt(self.player2);\n    });\n    this.socket.on('lightningBoltDestroyed', function () {\n      console.log('animation destruction ran'); //Destroy the animation associated with these hitboxes\n\n      let lightningAnimDestroyed = false; //Find all other associated lightning bolt hitboxes and destroy them\n\n      self.lightningBolts.getChildren().forEach(lightningBolt => {\n        if (lightningBolt.getOwner() !== self.player2) {\n          lightningBolt.body.enable = false;\n\n          if (lightningAnimDestroyed === false) {\n            console.log('animation destruction ran');\n            lightningAnimDestroyed = true;\n            lightningBolt.destroyAnimationSprite();\n          }\n        }\n      });\n    }); //Create Win Text\n\n    this.youWin = this.add.text(150, 300 - 60, 'PLAYER2 WINS ', {\n      fontSize: '70px',\n      color: '#66FF00'\n    });\n    this.youWin.setVisible(false); //Create Cooldowns: Note, final variable passed in is a timer, it sets how long the cooldown lasts in milliseconds            \n\n    this.swordCoolDownP1 = new CoolDown(this, 230, 560, 'swordCool', 700);\n    this.swordCoolDownP2 = new CoolDown(this, 570, 40, 'swordCool', 700);\n    this.magicCoolDownP1 = new CoolDown(this, 278, 560, 'blastCool', 1000);\n    this.magicCoolDownP2 = new CoolDown(this, 618, 40, 'blastCool', 1000);\n    this.dodgeCoolDownP1 = new CoolDown(this, 326, 560, 'dodgeCool', 1000);\n    this.dodgeCoolDownP2 = new CoolDown(this, 665, 40, 'dodgeCool', 1000);\n    this.lightningCoolDownP1 = new CoolDown(this, 374, 560, 'lightningCool', 5000);\n    this.lightningCoolDownP2 = new CoolDown(this, 713, 40, 'lightningCool', 5000); //Checks for the amount of gamepads connected to the phaser game, if the passed controls do not match the quantity of connected gamepads,\n    //the controls will be reset, this can be fixed later\n\n    let pad;\n    let gamePadCount = this.controlConfig.player1.Movement === 'GamePad' ? 1 : 0; //Create controls object which can be accessed in the update logic for game object interactions\n\n    this.controlsP1 = new Controls(this, {\n      directionals: this.controlConfig.player1.Movement,\n      magicBlast: this.controlConfig.player1.MagicBlast,\n      swordSwing: this.controlConfig.player1.SwordSlash\n    }, gamePadCount, 1); //These phaser groups allow for collisino detection of classes of objects at scale, for example all magic blasts have the same collision callack that is called\n\n    this.magicBlasts = this.physics.add.group();\n    this.swordHitBoxes = this.physics.add.group();\n    this.lightningBolts = this.physics.add.group(); //Create a sprite group in order to handle collisions\n\n    this.players = this.physics.add.group();\n    this.players.add(this.player1); //Attach healthbars to the selected players, this is so the game knows whose healthbar is whose\n    //this.player1.setHealthBar(this.healthBarP1);\n    //phaser has a prebuilt bounce physics setup, any value greater than 1 causes an exponential growth in object velocity as it multiplies each bounce\n\n    this.player1.setBounce(1); //Collision handling for object groups (group1, group2, callback)\n\n    this.physics.add.overlap(this.magicBlasts, this.swordHitBoxes, this.deflectBlast);\n    this.physics.add.overlap(this.magicBlasts, this.players, this.playerHit);\n    this.physics.add.overlap(this.lightningBolts, this.players, this.playerHitLightning); //4 walls on the outside\n\n    this.leftWall = this.physics.add.sprite(-55, 300, 'vwall'); //Set immovable allows the objects to not move on collision\n\n    this.leftWall.body.immovable = true;\n    this.rightWall = this.physics.add.sprite(855, 300, 'vwall');\n    this.rightWall.body.immovable = true;\n    this.topWall = this.physics.add.sprite(400, -55, 'wall');\n    this.topWall.body.immovable = true;\n    this.bottomWall = this.physics.add.sprite(400, 655, 'wall');\n    this.bottomWall.body.immovable = true; //staticGroup is a different type of group that doesn't move I believe\n\n    this.walls = this.physics.add.staticGroup();\n    this.walls.add(this.leftWall);\n    this.walls.add(this.rightWall);\n    this.walls.add(this.topWall);\n    this.walls.add(this.bottomWall); //midline barrier wall\n\n    this.midWall = this.physics.add.sprite(400, 300, 'wall');\n    this.midWall.setScale(1, .08);\n    this.midWall.setVisible(false);\n    this.midWall.body.immovable = true;\n    this.physics.add.collider(this.midWall, this.players); //The order of the objects in the collider matters, magicBlasts \n    //will only bounce off the walls if this.magicBlasts is the first argument\n\n    this.physics.add.collider(this.magicBlasts, this.walls);\n    this.physics.add.collider(this.walls, this.players);\n\n    this.createMagicBlast = function (player) {\n      //Create magic Blast\n      var magicBlast = new MagicBlast(this, player.getX(), player.getY(), 'magicBlast', {\n        owner: player\n      }); //Add to collision group\n\n      this.magicBlasts.add(magicBlast); //Fire in direction of player orientation\n\n      magicBlast.setMagicBlastVelocity(player.getOrientationVector()); //Set magicBlast bounce\n\n      magicBlast.setCollideWorldBounds(true);\n      magicBlast.setBounce(1);\n    };\n\n    this.createLightningBolt = function (player) {\n      //DO NOT CALL SOCKET EMITS IN HERE, INFINITE FEEDBACK LOOP\n      //create lightning Bolt animation object\n      let lightningBolt = new LightningBolt(this, player.getX(), player.getY(), 'lightningBolt', {\n        owner: player\n      }); //Creates 4 lightning bolt hitboxes which are the WIDTH of the lightning bolt, they travel \n      //at a speed so fast that it mimics a diagonal hitbox. This normally\n      //can't be created using Arcade physics and its Axis aligned bounding boxes;\n\n      let lightningBoltHB1 = new LightningHB(this, player.getX(), player.getY(), 'magicBlast', {\n        owner: player,\n        animationSprite: lightningBolt,\n        Olength: 100\n      });\n      let lightningBoltHB2 = new LightningHB(this, player.getX(), player.getY(), 'magicBlast', {\n        owner: player,\n        animationSprite: lightningBolt,\n        Olength: 50\n      });\n      let lightningBoltHB3 = new LightningHB(this, player.getX(), player.getY(), 'magicBlast', {\n        owner: player,\n        animationSprite: lightningBolt,\n        Olength: 25\n      });\n      let lightningBoltHB4 = new LightningHB(this, player.getX(), player.getY(), 'magicBlast', {\n        owner: player,\n        animationSprite: lightningBolt,\n        Olength: 75\n      }); //Add to collision group\n\n      this.lightningBolts.add(lightningBoltHB1);\n      this.lightningBolts.add(lightningBoltHB2);\n      this.lightningBolts.add(lightningBoltHB3);\n      this.lightningBolts.add(lightningBoltHB4);\n    };\n\n    this.checkForSwingThenSwing = function (attackInput, player, coolDown) {\n      //Check if swordSwing exists, and then check if it belongs to the player\n      this.swordHitBoxes.getChildren().forEach(swordSwing => {\n        if (swordSwing.getOwner() === player) {\n          let swordToCheck = swordSwing;\n        }\n      }); //Check if sword swing can be activated\n      //if the attack button is pressed,\n      //and there is no sword currently active on the player,\n      //and the cooldown is no active, then the sword can be swung\n\n      if (attackInput.swordSwingFiring && typeof swordToCheck == 'undefined' && !coolDown.isActive()) {\n        //Send sword swing to server\n        this.socket.emit('swingSword', this.roomName); //Set sword swing spawn point\n\n        let swordSpawnX = player.getX();\n        let swordSpawnY = player.getY(); //emit sword swing event:\n        //Create new sword swing\n\n        let newSwordSwing = new SwordSwing(this, swordSpawnX, swordSpawnY, 'swordSwing', {\n          owner: player\n        });\n        newSwordSwing.swingSword();\n        coolDown.startCoolDown();\n        this.swordHitBoxes.add(newSwordSwing);\n      }\n    };\n\n    this.onlinePlayerSwing = function (player, coolDown) {\n      //Set sword swing spawn point\n      let swordSpawnX = player.getX();\n      let swordSpawnY = player.getY(); //emit sword swing event:\n      //Create new sword swing\n\n      let newSwordSwing = new SwordSwing(this, swordSpawnX, swordSpawnY, 'swordSwing', {\n        owner: player\n      });\n      newSwordSwing.body.active = false;\n      newSwordSwing.swingSword();\n      coolDown.startCoolDown();\n      this.swordHitBoxes.add(newSwordSwing);\n    };\n  },\n  update: function () {\n    //Checks if player 1 or player2 have lost, can events be used for this instead?\n    if (!this.player1.isAlive()) {\n      this.youWin.setVisible(true);\n      this.youWin.setText('OPPONENT WINS');\n    } //Checks if player 1 or player2 have lost, can events be used for this instead?\n    else if (!this.player2.isAlive()) {\n        this.youWin.setVisible(true);\n        this.youWin.setText('YOU WIN');\n        console.log(\"is player 2 anim playing?\" + this.player2.anims.getTotalFrames());\n      } //Get Player input\n\n\n    this.movementVectorP1 = this.controlsP1.getMovementVector(); //Set the orientation of the player\n\n    this.player1.setOrientationVector(this.movementVectorP1); // emit player movement data\n\n    var x = this.player1.x;\n    var y = this.player1.y;\n    var d = this.player1.getOrientationVector();\n\n    if (this.player1.oldPosition && (x !== this.player1.oldPosition.x || y !== this.player1.oldPosition.y || d !== this.player1.oldPosition.direction)) {\n      this.socket.emit('playerMovement', {\n        x: x,\n        y: y,\n        direction: d,\n        roomName: this.roomName\n      });\n    } // save old position data\n\n\n    this.player1.oldPosition = {\n      x: x,\n      y: y,\n      direction: d\n    }; //Stop animation if not moving and alive(explode animation can play)\n\n    if (this.player2.moving === false && this.player2.isAlive()) {\n      this.player2.anims.pause();\n    } else {\n      //Count some update frames, compensating for server delay,\n      //If there is an acceptable delay from the server, then it can be assumed that the opponent\n      //has stopped moving since the last time\n      //They triggered a movmement event\n      this.player2.moveTimer += 1;\n\n      if (this.player2.moveTimer > 17) {\n        this.player2.moving = false;\n        this.player2.moveTimer = 0;\n      }\n    } //Check to make sure the player is not stunned, alive, and is not dodging\n\n\n    if (!this.player1.getStun() && this.player1.isAlive() && !this.player1.getDodging()) {\n      this.player1.setPlayerVelocity(this.movementVectorP1);\n      this.player1.setMovementAnim(this.movementVectorP1);\n    } //Get attack inputs every update cycle\n\n\n    let attackInputsP1 = this.controlsP1.getMoveInput(); //Check for user firing magic blast and that the cooldown is not active\n\n    if (attackInputsP1.magicBlastFiring && !this.magicCoolDownP1.isActive()) {\n      this.magicCoolDownP1.startCoolDown();\n      this.socket.emit('createMagicBlast', this.roomName);\n      this.createMagicBlast(this.player1);\n    }\n\n    ; //Check for user firing Lightning Bolt\n\n    if (attackInputsP1.lightningBoltFiring && !this.lightningCoolDownP1.isActive()) {\n      this.lightningCoolDownP1.startCoolDown();\n      this.socket.emit('createLightningBolt', this.roomName);\n      this.createLightningBolt(this.player1);\n    }\n\n    ; //Check for user dodging and check that they aren't already in dodge mode\n\n    if (attackInputsP1.dodgeFiring && !this.player1.getDodging() && !this.dodgeCoolDownP1.isActive()) {\n      this.dodgeCoolDownP1.startCoolDown();\n      this.player1.dodge();\n    }\n\n    ; //Check if sword swings exist, and update them as needed, \n    //this is the best way I can think of for tracking and following player position in the main loop\n    //Perhaps there's a better way? Without it \n    //the sword is stuck in place, perhaps it can be attached to a reference to player position?\n    //I took a look at an update pattern for a situation like this\n\n    let swordSwings = this.swordHitBoxes.getChildren();\n\n    if (swordSwings.length > 0) {\n      swordSwings.forEach(swordSwing => {\n        swordSwing.update();\n      });\n    } //Check for user swinging sword and then swing, starting the cooldown\n    //I think functions are supposed to do only one thing, I'll fix this later\n\n\n    this.checkForSwingThenSwing(attackInputsP1, this.player1, this.swordCoolDownP1);\n  }\n};\nexport default LocalGameScene;","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/src/phaser/scenes/OnlineGameScene.js"],"names":["Scene","Player","Controls","MagicBlast","SwordSwing","Phaser","bckg","HealthBar","CoolDown","LightningBolt","LightningHB","io","LocalGameScene","preload","load","image","spritesheet","frameWidth","frameHeight","create","self","deflectBlast","magicBlast","swordHitbox","inSwordSweep","deflectFrom","getOwner","explosionAnim","anims","key","frames","generateFrameNumbers","start","end","frameRate","repeat","playerHit","player","console","log","roomName","socket","emit","explode","getStun","getDodging","playStun","getHealthBar","decrease","gameOver","play","timedEvent","scene","time","delayedCall","redirect","knockBack","playerHitLightning","lightningBolt","destroyAnimationSprite","lightningBolts","getChildren","forEach","body","enable","window","location","replace","background","add","sprite","yoyo","healthBarP1","x","y","healthBarP2","gameConfig","player1","player2","setHealthBar","createAnimations","id","setVisible","playerSetup","healthbar","swordCoolDown","winText","moving","moveTimer","on","opponentSocketId","player2Movement","setOrientationVector","direction","isAlive","setMovementAnim","onlinePlayerSwing","swordCoolDownP2","magicCoolDownP2","startCoolDown","createMagicBlast","magicBlasts","createLightningBolt","lightningAnimDestroyed","youWin","text","fontSize","color","swordCoolDownP1","magicCoolDownP1","dodgeCoolDownP1","dodgeCoolDownP2","lightningCoolDownP1","lightningCoolDownP2","pad","gamePadCount","controlConfig","Movement","controlsP1","directionals","swordSwing","SwordSlash","physics","group","swordHitBoxes","players","setBounce","overlap","leftWall","immovable","rightWall","topWall","bottomWall","walls","staticGroup","midWall","setScale","collider","getX","getY","owner","setMagicBlastVelocity","getOrientationVector","setCollideWorldBounds","lightningBoltHB1","animationSprite","Olength","lightningBoltHB2","lightningBoltHB3","lightningBoltHB4","checkForSwingThenSwing","attackInput","coolDown","swordToCheck","swordSwingFiring","isActive","swordSpawnX","swordSpawnY","newSwordSwing","swingSword","active","update","setText","getTotalFrames","movementVectorP1","getMovementVector","d","oldPosition","pause","setPlayerVelocity","attackInputsP1","getMoveInput","magicBlastFiring","lightningBoltFiring","dodgeFiring","dodge","swordSwings","length"],"mappings":"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","sourcesContent":["import { Scene } from 'phaser';\r\nimport Player from \"../sprites/Player.js\";\r\nimport Controls from \"../controls/Controls.js\";\r\nimport MagicBlast from \"../sprites/MagicBlast.js\";\r\nimport SwordSwing from \"../sprites/SwordSwing.js\";\r\nimport Phaser from 'phaser';\r\nimport bckg from '../assets/bckg.png';\r\nimport HealthBar from \"../sprites/HealthBar.js\";\r\nimport CoolDown from \"../sprites/CoolDown.js\";\r\nimport LightningBolt from '../sprites/lightningBolt.js';\r\nimport LightningHB from '../sprites/lightningBoltHitbox.js';\r\nimport io from 'socket.io-client';\r\n//import proxy from 'socket.io-proxy';\r\nlet LocalGameScene = {\r\n    \r\n    \r\n    preload: function()\r\n        {\r\n            //I load the images from my publicly hosted imgur\r\n            //because the file system seems to break for some reason when this is run in IonPhaser\r\n            //(Which is inside a React application)\r\n            //I make these drawings/spritesheets in piskel\r\n            this.load.image('bckg', 'https://i.imgur.com/DMVC2IQ.png');\r\n            this.load.image('wall', 'https://i.imgur.com/av8q7Or.png');\r\n            this.load.image('vwall', 'https://i.imgur.com/UB2GdEL.png');\r\n            this.load.spritesheet('swordSwing', 'https://i.imgur.com/ULyXfap.png', {frameWidth: 500, frameHeight: 500});\r\n            this.load.image('swordCool', 'https://i.imgur.com/SnLjQdR.png');\r\n            this.load.image('blastCool', 'https://i.imgur.com/d4Enueh.png');\r\n            this.load.spritesheet('magicBlast', 'https://i.imgur.com/dEhNPqO.png', {frameWidth: 150, frameHeight: 150});\r\n            this.load.spritesheet('explosion','https://i.imgur.com/UHZiUKC.png', {frameWidth: 192, frameHeight: 192});\r\n            this.load.spritesheet('player', 'https://i.imgur.com/WlEeiKT.png', { frameWidth: 68, frameHeight: 68 });\r\n            this.load.spritesheet('otherPlayer','https://i.imgur.com/NYAJusD.png', { frameWidth: 68, frameHeight: 68 });\r\n            this.load.spritesheet('Background','https://i.imgur.com/8SzCikO.png', {frameWidth: 800, frameHeight: 600});\r\n            this.load.image('dodgeCool', 'https://i.imgur.com/mTklmkU.png');\r\n            this.load.spritesheet('lightningBolt', 'https://i.imgur.com/3MskIUy.png', {frameWidth: 16, frameHeight: 1000});\r\n            this.load.image('lightningCool', 'https://i.imgur.com/FVquIxw.png');\r\n        },\r\n\r\n    create: function()\r\n        {   \r\n             let self = this;\r\n           /*I define some of the functions ex:this.deflectBlast\r\n           this way instead of outside of the preload/create/update\r\n           because that is the way they don't throw an error while using IonPhaser,\r\n           Perhaps they can be moved to another file and imported in*/\r\n\r\n          //Deflect Magic Blast with sword\r\n            this.deflectBlast = function(magicBlast,swordHitbox){\r\n                if(swordHitbox.inSwordSweep(magicBlast)){\r\n                    magicBlast.deflectFrom(swordHitbox.getOwner());\r\n                }\r\n            };\r\n           //Create explosion animation\r\n            this.explosionAnim = this.anims.create({\r\n                key: 'explode',\r\n                frames: this.anims.generateFrameNumbers('explosion',{ start: 1, end: 23}),\r\n                frameRate: 10,\r\n                repeat: -1\r\n            });\r\n            //This needs to be added because the player2 animation breaks when called for some reason, unsure why?\r\n            //It must have to do with something where 'explode' is played\r\n            this.explosionAnim = this.anims.create({\r\n                key: 'explode2',\r\n                frames: this.anims.generateFrameNumbers('explosion',{ start: 1, end: 23}),\r\n                frameRate: 10,\r\n                repeat: -1\r\n            });\r\n            //Callback function for player/magicBlast Collision\r\n            this.playerHit = function(magicBlast,player){\r\n               //Check that the magicBlast is hitting the right player\r\n                if (magicBlast.getOwner()!==player){\r\n                    //In online mode, only the opposing player(who does not active hitbox in your game) will get hit, when they do, this is called\r\n                    //Depending on how we implement magic blasts, this may require an index to be sent through for selecting and destroy the object\r\n                    console.log('this.roomName is: ' + self.roomName);\r\n                    self.socket.emit('destroyMagicBlast', self.roomName);\r\n                   \r\n                    magicBlast.explode();\r\n                    //Check if player is stunned or dodging, if neither is true, play stun animation and calculate damage\r\n                    if (player.getStun() === false || player.getDodging() === false){\r\n                        self.socket.emit('damagePlayer', self.roomName);\r\n                        player.playStun();\r\n                        //Reduce player health\r\n                        //When the healthbar reaches 0, this evaluates to true\r\n                        if(player.getHealthBar().decrease(4)){\r\n                            //This function has the player blow up\r\n                            player.gameOver();\r\n                            player.anims.play('explode', true);\r\n                            //Win Screen and link people back to main menu   \r\n                            //How could we access the react router DOM here?\r\n\r\n                            let timedEvent = player.scene.time.delayedCall(3000, player.scene.redirect, [], this);\r\n                        };\r\n                        //Knock opponent backwards\r\n                        player.knockBack(magicBlast);\r\n                    }\r\n                    \r\n                }\r\n            }\r\n            \r\n            //Collision between lightning and player\r\n            this.playerHitLightning = function(lightningBolt,player){\r\n                //Players cannot hit themselves with their own attacks\r\n                if(lightningBolt.getOwner()!==player){\r\n                   \r\n                    if (player.getStun() === false && player.getDodging() === false){\r\n                        \r\n                        //Stun is started for player\r\n                        player.playStun();\r\n                        self.socket.emit('destroyLightningBolt', self.roomName);\r\n                        self.socket.emit('damagePlayer', self.roomName);\r\n                        if(player.getHealthBar().decrease(4)){\r\n                           \r\n                            //Player dies\r\n                            player.gameOver();\r\n                            player.anims.play('explode', true);\r\n                            //Send players back to main menu\r\n                            let timedEvent = player.scene.time.delayedCall(3000, player.scene.redirect, [], this);\r\n                        }\r\n                        \r\n                        player.knockBack(lightningBolt);\r\n                      \r\n                        //Destroy the animation associated with these hitboxes\r\n                        lightningBolt.destroyAnimationSprite();\r\n\r\n                        //Find all other associated lightning bolt hitboxes and destroy them\r\n                        lightningBolt.scene.lightningBolts.getChildren().forEach(lightningBolt => {\r\n                            if (lightningBolt.getOwner() !== player) {\r\n                                lightningBolt.body.enable = false;\r\n                            }\r\n                    });\r\n                }\r\n            }\r\n            }\r\n            //Callback for sending user back to main page when game ends\r\n            this.redirect = function(){\r\n                 window.location.replace('http://localhost:3000/');\r\n            }\r\n            //Glowing Background Sprite\r\n            this.background = this.add.sprite(400,300,'Background');\r\n            this.anims.create({\r\n                key: 'glow',\r\n                frames: this.anims.generateFrameNumbers('Background', { start: 1, end: 12 }),\r\n                frameRate: 4,\r\n                repeat: -1,\r\n                yoyo: true\r\n            });\r\n            this.background.anims.play('glow');\r\n            \r\n            //Refactoring idea: make every variable passed into constructors \r\n            //descriptive javascript properties for readability\r\n\r\n           //Create Health Bars\r\n            this.healthBarP1 = new HealthBar({scene: this, x: 0, y:584});\r\n            this.healthBarP2 = new HealthBar({scene: this, x: 0, y:0});\r\n\r\n            console.log('gameconfig is: ' + this.gameConfig);\r\n            if (this.gameConfig === 'joinOnline') {\r\n                this.player1 = new Player(this, 400, 200,'otherPlayer', this.explosionAnim);\r\n                this.player2 = new Player(this, 400, 500,'player', this.explosionAnim);\r\n                this.player1.setHealthBar(this.healthBarP2);\r\n                this.player2.setHealthBar(this.healthBarP1);\r\n                this.player1.createAnimations(this);\r\n                this.player2.createAnimations(this);\r\n                console.log('my id is: ' + this.socket.id);    \r\n                this.player2.setVisible(true);\r\n                \r\n               \r\n            }\r\n            if (this.gameConfig === 'createOnline'){\r\n                this.player1 = new Player(this, 400, 500,'player', this.explosionAnim);\r\n                this.player2 = new Player(this, 400, 200,'otherPlayer', this.explosionAnim);\r\n                this.player1.setHealthBar(this.healthBarP1);\r\n                this.player2.setHealthBar(this.healthBarP2);\r\n                this.player1.createAnimations(this);\r\n                this.player2.createAnimations(this);\r\n                this.player2.setVisible(false);\r\n                this.socket.emit('createOnlineRoom');\r\n                this.socket.emit('getRoomName');\r\n                \r\n            }\r\n            this.playerSetup = function(player, healthbar, swordCoolDown, winText){\r\n                \r\n            }\r\n            this.player2.moving = false;\r\n            this.player2.moveTimer = 0;\r\n            this.socket.on('yourRoomName', function(roomName) {\r\n                console.log('myroomName is called here');\r\n                self.roomName = roomName;\r\n            });\r\n            this.socket.on('opponentJoined', function(opponentSocketId) {\r\n                self.player2.setVisible(true);\r\n                console.log('opponentJoined, id: ' + opponentSocketId);\r\n                self.opponentSocketId = opponentSocketId;\r\n                self.socket.emit('confirmJoinRoom', opponentSocketId);\r\n            });\r\n            this.socket.on('joinedRoom', function(opponentSocketId) {\r\n                console.log('joined Room socket event happened')\r\n                self.opponentSocketId = opponentSocketId;\r\n            });\r\n            this.socket.on('playerMoved', function (player2Movement){\r\n               \r\n                    self.player2.moving = true;\r\n                    self.player2.x = player2Movement.x;\r\n                    self.player2.y = player2Movement.y;\r\n                    self.player2.setOrientationVector(player2Movement.direction);\r\n                    if(self.player2.isAlive()){\r\n                         self.player2.setMovementAnim(player2Movement.direction);\r\n                    }\r\n                   \r\n            });\r\n           this.socket.on('swordSwung', function(){\r\n               self.onlinePlayerSwing(self.player2, self.swordCoolDownP2);\r\n           })\r\n           this.socket.on('magicBlastCreated', function(){\r\n               self.magicCoolDownP2.startCoolDown();\r\n               self.createMagicBlast(self.player2);\r\n           });\r\n           this.socket.on('magicBlastDestroyed', function(){\r\n               console.log('magicBlastDestroyed ran');\r\n               \r\n                self.magicBlasts.getChildren().forEach(magicBlast => {\r\n                    if (magicBlast.getOwner() !== self.player2) {\r\n                        magicBlast.explode();\r\n                    }\r\n                });\r\n           });\r\n           this.socket.on('playerDamaged', function() {\r\n               self.player2.playStun();\r\n               if (self.player2.getHealthBar().decrease(4)){\r\n                   self.player2.gameOver();\r\n                   self.player2.anims.play('explode2', false);\r\n                   \r\n                   \r\n                   let timedEvent = self.time.delayedCall(3000, self.redirect, [], self);\r\n               }\r\n           });\r\n           this.socket.on('lightningBoltCreated', function(){\r\n               self.createLightningBolt(self.player2);\r\n           });\r\n           this.socket.on('lightningBoltDestroyed', function(){\r\n               console.log('animation destruction ran');\r\n                         //Destroy the animation associated with these hitboxes\r\n                        let lightningAnimDestroyed = false;\r\n                        //Find all other associated lightning bolt hitboxes and destroy them\r\n                        self.lightningBolts.getChildren().forEach(lightningBolt => {\r\n                            if (lightningBolt.getOwner() !== self.player2) {\r\n                                lightningBolt.body.enable = false;\r\n                                if (lightningAnimDestroyed === false){\r\n                                    console.log('animation destruction ran');\r\n                                    lightningAnimDestroyed = true;\r\n                                    lightningBolt.destroyAnimationSprite();\r\n                                }\r\n                            }\r\n                    });\r\n           });\r\n            //Create Win Text\r\n            this.youWin = this.add.text(150,300-60,'PLAYER2 WINS ',{fontSize: '70px', color: '#66FF00'});\r\n            this.youWin.setVisible(false);\r\n\r\n            \r\n            //Create Cooldowns: Note, final variable passed in is a timer, it sets how long the cooldown lasts in milliseconds            \r\n            this.swordCoolDownP1 = new CoolDown(this, 230, 560, 'swordCool', 700);\r\n            this.swordCoolDownP2 = new CoolDown(this, 570, 40, 'swordCool', 700);\r\n           \r\n            this.magicCoolDownP1 = new CoolDown(this, 278, 560, 'blastCool', 1000);\r\n            this.magicCoolDownP2 = new CoolDown(this, 618, 40, 'blastCool', 1000);\r\n            \r\n            this.dodgeCoolDownP1 = new CoolDown(this, 326, 560, 'dodgeCool', 1000);\r\n            this.dodgeCoolDownP2 = new CoolDown(this, 665, 40, 'dodgeCool', 1000);\r\n\r\n            this.lightningCoolDownP1 = new CoolDown(this, 374, 560, 'lightningCool', 5000);\r\n            this.lightningCoolDownP2 = new CoolDown(this, 713, 40, 'lightningCool', 5000);\r\n\r\n            //Checks for the amount of gamepads connected to the phaser game, if the passed controls do not match the quantity of connected gamepads,\r\n            //the controls will be reset, this can be fixed later\r\n            let pad: Phaser.Input.Gamepad.Gamepad;\r\n            let gamePadCount = ((this.controlConfig.player1.Movement==='GamePad')? 1:0);\r\n           \r\n\r\n            //Create controls object which can be accessed in the update logic for game object interactions\r\n            this.controlsP1 = new Controls(this,{directionals: this.controlConfig.player1.Movement, magicBlast: this.controlConfig.player1.MagicBlast, swordSwing: this.controlConfig.player1.SwordSlash},gamePadCount,1);\r\n           \r\n            \r\n            //These phaser groups allow for collisino detection of classes of objects at scale, for example all magic blasts have the same collision callack that is called\r\n            this.magicBlasts = this.physics.add.group();\r\n            this.swordHitBoxes = this.physics.add.group();\r\n            this.lightningBolts = this.physics.add.group();\r\n\r\n            //Create a sprite group in order to handle collisions\r\n            this.players = this.physics.add.group();\r\n            this.players.add(this.player1);\r\n          \r\n\r\n            //Attach healthbars to the selected players, this is so the game knows whose healthbar is whose\r\n            //this.player1.setHealthBar(this.healthBarP1);\r\n\r\n          \r\n\r\n            //phaser has a prebuilt bounce physics setup, any value greater than 1 causes an exponential growth in object velocity as it multiplies each bounce\r\n            this.player1.setBounce(1);\r\n\r\n\r\n            //Collision handling for object groups (group1, group2, callback)\r\n            this.physics.add.overlap(this.magicBlasts,this.swordHitBoxes,this.deflectBlast);\r\n            this.physics.add.overlap(this.magicBlasts,this.players,this.playerHit);\r\n            this.physics.add.overlap(this.lightningBolts,this.players,this.playerHitLightning);\r\n            \r\n            //4 walls on the outside\r\n            this.leftWall = this.physics.add.sprite(-55,300,'vwall');\r\n            //Set immovable allows the objects to not move on collision\r\n            this.leftWall.body.immovable = true;\r\n            this.rightWall = this.physics.add.sprite(855,300,'vwall');\r\n            this.rightWall.body.immovable = true;\r\n            this.topWall = this.physics.add.sprite(400,-55,'wall');\r\n            this.topWall.body.immovable = true;\r\n            this.bottomWall = this.physics.add.sprite(400,655,'wall');\r\n            this.bottomWall.body.immovable = true;\r\n            \r\n            //staticGroup is a different type of group that doesn't move I believe\r\n            this.walls = this.physics.add.staticGroup();\r\n            this.walls.add(this.leftWall);\r\n            this.walls.add(this.rightWall);\r\n            this.walls.add(this.topWall);\r\n            this.walls.add(this.bottomWall);\r\n            \r\n            //midline barrier wall\r\n            this.midWall = this.physics.add.sprite(400,300,'wall');\r\n            this.midWall.setScale(1,.08);\r\n            this.midWall.setVisible(false);\r\n            this.midWall.body.immovable = true;\r\n\r\n            this.physics.add.collider(this.midWall,this.players);\r\n            \r\n            //The order of the objects in the collider matters, magicBlasts \r\n            //will only bounce off the walls if this.magicBlasts is the first argument\r\n            this.physics.add.collider(this.magicBlasts,this.walls);\r\n            this.physics.add.collider(this.walls,this.players);\r\n             \r\n            this.createMagicBlast = function(player){\r\n                    //Create magic Blast\r\n                    var magicBlast = new MagicBlast(this,player.getX(),\r\n                    player.getY(),'magicBlast',{owner: player});\r\n                    //Add to collision group\r\n                    this.magicBlasts.add(magicBlast);\r\n                    //Fire in direction of player orientation\r\n                    magicBlast.setMagicBlastVelocity(player.getOrientationVector());\r\n                    //Set magicBlast bounce\r\n                    magicBlast.setCollideWorldBounds(true);\r\n                    magicBlast.setBounce(1);\r\n                    \r\n            };\r\n            this.createLightningBolt = function(player)\r\n            {\r\n                //DO NOT CALL SOCKET EMITS IN HERE, INFINITE FEEDBACK LOOP\r\n                 //create lightning Bolt animation object\r\n                let lightningBolt = new LightningBolt(this,player.getX(),player.getY(),'lightningBolt',{owner: player});\r\n                //Creates 4 lightning bolt hitboxes which are the WIDTH of the lightning bolt, they travel \r\n                //at a speed so fast that it mimics a diagonal hitbox. This normally\r\n                //can't be created using Arcade physics and its Axis aligned bounding boxes;\r\n                let lightningBoltHB1 = new LightningHB(this,player.getX(),player.getY(),'magicBlast',{owner: player, animationSprite: lightningBolt, Olength: 100});\r\n                let lightningBoltHB2 = new LightningHB(this,player.getX(),player.getY(),'magicBlast',{owner: player, animationSprite: lightningBolt, Olength: 50});\r\n                let lightningBoltHB3 = new LightningHB(this,player.getX(),player.getY(),'magicBlast',{owner: player, animationSprite: lightningBolt, Olength: 25});\r\n                let lightningBoltHB4 = new LightningHB(this,player.getX(),player.getY(),'magicBlast',{owner: player, animationSprite: lightningBolt, Olength: 75});\r\n                //Add to collision group\r\n                this.lightningBolts.add(lightningBoltHB1);\r\n                this.lightningBolts.add(lightningBoltHB2);\r\n                this.lightningBolts.add(lightningBoltHB3);\r\n                this.lightningBolts.add(lightningBoltHB4);\r\n\r\n            }\r\n            this.checkForSwingThenSwing = function(attackInput, player, coolDown){\r\n                //Check if swordSwing exists, and then check if it belongs to the player\r\n                this.swordHitBoxes.getChildren().forEach(swordSwing => {\r\n                    if (swordSwing.getOwner() === player) {\r\n                        let swordToCheck = swordSwing;\r\n                    }\r\n                });\r\n                //Check if sword swing can be activated\r\n                //if the attack button is pressed,\r\n                //and there is no sword currently active on the player,\r\n                //and the cooldown is no active, then the sword can be swung\r\n                 if ((attackInput.swordSwingFiring && typeof swordToCheck == 'undefined' && !coolDown.isActive())){\r\n                   \r\n                   \r\n                    //Send sword swing to server\r\n                    this.socket.emit('swingSword',this.roomName);\r\n                    //Set sword swing spawn point\r\n                    let swordSpawnX = player.getX();\r\n                    let swordSpawnY = player.getY();\r\n                    //emit sword swing event:\r\n                    //Create new sword swing\r\n                    let newSwordSwing = new SwordSwing(this,swordSpawnX,swordSpawnY,'swordSwing',{owner: player});\r\n                    newSwordSwing.swingSword();\r\n                    coolDown.startCoolDown();\r\n                    this.swordHitBoxes.add(newSwordSwing);\r\n                   \r\n                 }\r\n            };\r\n            this.onlinePlayerSwing = function (player, coolDown){\r\n                //Set sword swing spawn point\r\n                let swordSpawnX = player.getX();\r\n                let swordSpawnY = player.getY();\r\n                //emit sword swing event:\r\n                //Create new sword swing\r\n                let newSwordSwing = new SwordSwing(this,swordSpawnX,swordSpawnY,'swordSwing',{owner: player});\r\n                newSwordSwing.body.active = false;\r\n                newSwordSwing.swingSword();\r\n                coolDown.startCoolDown();\r\n                this.swordHitBoxes.add(newSwordSwing);\r\n            };\r\n           \r\n        },\r\n\r\n    update: function()\r\n        {\r\n        \r\n        //Checks if player 1 or player2 have lost, can events be used for this instead?\r\n        if (!this.player1.isAlive()){\r\n            this.youWin.setVisible(true);\r\n           this.youWin.setText('OPPONENT WINS');\r\n        }\r\n        //Checks if player 1 or player2 have lost, can events be used for this instead?\r\n        else if (!this.player2.isAlive()){\r\n            this.youWin.setVisible(true);\r\n            this.youWin.setText('YOU WIN');\r\n            console.log(\"is player 2 anim playing?\" + this.player2.anims.getTotalFrames());\r\n        }\r\n        \r\n        //Get Player input\r\n        this.movementVectorP1 = this.controlsP1.getMovementVector();\r\n        \r\n\r\n        //Set the orientation of the player\r\n        this.player1.setOrientationVector(this.movementVectorP1);\r\n        \r\n        // emit player movement data\r\n        var x = this.player1.x;\r\n        var y = this.player1.y;\r\n        var d = this.player1.getOrientationVector();\r\n        if (this.player1.oldPosition && (x !== this.player1.oldPosition.x || y !== this.player1.oldPosition.y || d !== this.player1.oldPosition.direction)) {\r\n         \r\n            this.socket.emit('playerMovement', { x: x, y: y, direction: d , roomName: this.roomName});\r\n        }\r\n \r\n        // save old position data\r\n        this.player1.oldPosition = {\r\n          x: x,\r\n          y: y,\r\n          direction: d\r\n        };\r\n        //Stop animation if not moving and alive(explode animation can play)\r\n        if (this.player2.moving === false && this.player2.isAlive())\r\n        {\r\n            this.player2.anims.pause();\r\n            \r\n            \r\n        }\r\n        else\r\n        {\r\n            \r\n            //Count some update frames, compensating for server delay,\r\n            //If there is an acceptable delay from the server, then it can be assumed that the opponent\r\n            //has stopped moving since the last time\r\n            //They triggered a movmement event\r\n            this.player2.moveTimer += 1;\r\n            if (this.player2.moveTimer > 17){\r\n                this.player2.moving = false;\r\n                this.player2.moveTimer = 0;\r\n            }\r\n            \r\n        }\r\n        //Check to make sure the player is not stunned, alive, and is not dodging\r\n        if(!this.player1.getStun() && this.player1.isAlive() && !this.player1.getDodging()){\r\n            this.player1.setPlayerVelocity(this.movementVectorP1);\r\n            this.player1.setMovementAnim(this.movementVectorP1);\r\n        }\r\n\r\n\r\n\r\n        //Get attack inputs every update cycle\r\n        let attackInputsP1 = this.controlsP1.getMoveInput();\r\n       \r\n        //Check for user firing magic blast and that the cooldown is not active\r\n        if (attackInputsP1.magicBlastFiring && !this.magicCoolDownP1.isActive()){\r\n           this.magicCoolDownP1.startCoolDown();\r\n           this.socket.emit('createMagicBlast', this.roomName);\r\n           this.createMagicBlast(this.player1);\r\n        };\r\n        \r\n        //Check for user firing Lightning Bolt\r\n        if (attackInputsP1.lightningBoltFiring && !this.lightningCoolDownP1.isActive()){\r\n           this.lightningCoolDownP1.startCoolDown();\r\n           this.socket.emit('createLightningBolt',this.roomName);\r\n           this.createLightningBolt(this.player1);\r\n          \r\n        };\r\n        \r\n\r\n       \r\n        //Check for user dodging and check that they aren't already in dodge mode\r\n        if (attackInputsP1.dodgeFiring && !this.player1.getDodging() && !this.dodgeCoolDownP1.isActive()){\r\n            this.dodgeCoolDownP1.startCoolDown();\r\n            this.player1.dodge();\r\n        };\r\n       \r\n\r\n        //Check if sword swings exist, and update them as needed, \r\n        //this is the best way I can think of for tracking and following player position in the main loop\r\n        //Perhaps there's a better way? Without it \r\n        //the sword is stuck in place, perhaps it can be attached to a reference to player position?\r\n        //I took a look at an update pattern for a situation like this\r\n        let swordSwings = this.swordHitBoxes.getChildren();\r\n        if (swordSwings.length>0){\r\n            swordSwings.forEach(swordSwing => {\r\n                swordSwing.update();\r\n            }\r\n            );\r\n            \r\n        }\r\n        \r\n        //Check for user swinging sword and then swing, starting the cooldown\r\n        //I think functions are supposed to do only one thing, I'll fix this later\r\n        this.checkForSwingThenSwing(attackInputsP1, this.player1, this.swordCoolDownP1);\r\n\r\n        }\r\n    \r\n    \r\n\r\n\r\n}\r\n\r\nexport default LocalGameScene;"]},"metadata":{},"sourceType":"module"}