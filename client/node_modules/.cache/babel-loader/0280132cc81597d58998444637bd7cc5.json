{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Based on JSON2 (http://www.JSON.org/js.html).\n */\n(function (exports, nativeJSON) {\n  \"use strict\"; // use native JSON if it's available\n\n  if (nativeJSON && nativeJSON.parse) {\n    return exports.JSON = {\n      parse: nativeJSON.parse,\n      stringify: nativeJSON.stringify\n    };\n  }\n\n  var JSON = exports.JSON = {};\n\n  function f(n) {\n    // Format integers to have at least two digits.\n    return n < 10 ? '0' + n : n;\n  }\n\n  function date(d, key) {\n    return isFinite(d.valueOf()) ? d.getUTCFullYear() + '-' + f(d.getUTCMonth() + 1) + '-' + f(d.getUTCDate()) + 'T' + f(d.getUTCHours()) + ':' + f(d.getUTCMinutes()) + ':' + f(d.getUTCSeconds()) + 'Z' : null;\n  }\n\n  ;\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = {\n    // table of character substitutions\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  },\n      rep;\n\n  function quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n      var c = meta[a];\n      return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n  }\n\n  function str(key, holder) {\n    // Produce a string from holder[key].\n    var i,\n        // The loop counter.\n    k,\n        // The member key.\n    v,\n        // The member value.\n    length,\n        mind = gap,\n        partial,\n        value = holder[key]; // If the value has a toJSON method, call it to obtain a replacement value.\n\n    if (value instanceof Date) {\n      value = date(key);\n    } // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n\n\n    if (typeof rep === 'function') {\n      value = rep.call(holder, key, value);\n    } // What happens next depends on the value's type.\n\n\n    switch (typeof value) {\n      case 'string':\n        return quote(value);\n\n      case 'number':\n        // JSON numbers must be finite. Encode non-finite numbers as null.\n        return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n      case 'null':\n        // If the value is a boolean or null, convert it to a string. Note:\n        // typeof null does not produce 'null'. The case is included here in\n        // the remote chance that this gets fixed someday.\n        return String(value);\n      // If the type is 'object', we might be dealing with an object or an array or\n      // null.\n\n      case 'object':\n        // Due to a specification blunder in ECMAScript, typeof null is 'object',\n        // so watch out for that case.\n        if (!value) {\n          return 'null';\n        } // Make an array to hold the partial results of stringifying this object value.\n\n\n        gap += indent;\n        partial = []; // Is the value an array?\n\n        if (Object.prototype.toString.apply(value) === '[object Array]') {\n          // The value is an array. Stringify every element. Use null as a placeholder\n          // for non-JSON values.\n          length = value.length;\n\n          for (i = 0; i < length; i += 1) {\n            partial[i] = str(i, value) || 'null';\n          } // Join all of the elements together, separated with commas, and wrap them in\n          // brackets.\n\n\n          v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n          gap = mind;\n          return v;\n        } // If the replacer is an array, use it to select the members to be stringified.\n\n\n        if (rep && typeof rep === 'object') {\n          length = rep.length;\n\n          for (i = 0; i < length; i += 1) {\n            if (typeof rep[i] === 'string') {\n              k = rep[i];\n              v = str(k, value);\n\n              if (v) {\n                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n              }\n            }\n          }\n        } else {\n          // Otherwise, iterate through all of the keys in the object.\n          for (k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              v = str(k, value);\n\n              if (v) {\n                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n              }\n            }\n          }\n        } // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n\n        v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n  } // If the JSON object does not yet have a stringify method, give it one.\n\n\n  JSON.stringify = function (value, replacer, space) {\n    // The stringify method takes a value and an optional replacer, and an optional\n    // space parameter, and returns a JSON text. The replacer can be a function\n    // that can replace values, or an array of strings that will select the keys.\n    // A default replacer method can be provided. Use of the space parameter can\n    // produce text that is more easily readable.\n    var i;\n    gap = '';\n    indent = ''; // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n\n    if (typeof space === 'number') {\n      for (i = 0; i < space; i += 1) {\n        indent += ' ';\n      } // If the space parameter is a string, it will be used as the indent string.\n\n    } else if (typeof space === 'string') {\n      indent = space;\n    } // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n\n\n    rep = replacer;\n\n    if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n      throw new Error('JSON.stringify');\n    } // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n\n\n    return str('', {\n      '': value\n    });\n  }; // If the JSON object does not yet have a parse method, give it one.\n\n\n  JSON.parse = function (text, reviver) {\n    // The parse method takes a text and an optional reviver function, and returns\n    // a JavaScript value if the text is a valid JSON text.\n    var j;\n\n    function walk(holder, key) {\n      // The walk method is used to recursively walk the resulting structure so\n      // that modifications can be made.\n      var k,\n          v,\n          value = holder[key];\n\n      if (value && typeof value === 'object') {\n        for (k in value) {\n          if (Object.prototype.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n\n      return reviver.call(holder, key, value);\n    } // Parsing happens in four stages. In the first stage, we replace certain\n    // Unicode characters with escape sequences. JavaScript handles many characters\n    // incorrectly, either silently deleting them, or treating them as line endings.\n\n\n    text = String(text);\n    cx.lastIndex = 0;\n\n    if (cx.test(text)) {\n      text = text.replace(cx, function (a) {\n        return '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      });\n    } // In the second stage, we run the text against regular expressions that look\n    // for non-JSON patterns. We are especially concerned with '()' and 'new'\n    // because they can cause invocation, and '=' because it can cause mutation.\n    // But just to be safe, we want to reject all unexpected forms.\n    // We split the second stage into 4 regexp operations in order to work around\n    // crippling inefficiencies in IE's and Safari's regexp engines. First we\n    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n    // replace all simple value tokens with ']' characters. Third, we delete all\n    // open brackets that follow a colon or comma or that begin the text. Finally,\n    // we look to see that the remaining characters are only whitespace or ']' or\n    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n\n    if (/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']').replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n      // In the third stage we use the eval function to compile the text into a\n      // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n      // in JavaScript: it can begin a block or an object literal. We wrap the text\n      // in parens to eliminate the ambiguity.\n      j = eval('(' + text + ')'); // In the optional fourth stage, we recursively walk the new structure, passing\n      // each name/value pair to a reviver function for possible transformation.\n\n      return typeof reviver === 'function' ? walk({\n        '': j\n      }, '') : j;\n    } // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n\n    throw new SyntaxError('JSON.parse');\n  };\n})('undefined' != typeof io ? io : module.exports, typeof JSON !== 'undefined' ? JSON : undefined);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/json.js"],"names":["exports","nativeJSON","parse","JSON","stringify","f","n","date","d","key","isFinite","valueOf","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","cx","escapable","gap","indent","meta","rep","quote","string","lastIndex","test","replace","a","c","charCodeAt","toString","slice","str","holder","i","k","v","length","mind","partial","value","Date","call","String","Object","prototype","apply","join","push","hasOwnProperty","replacer","space","Error","text","reviver","j","walk","undefined","eval","SyntaxError","io","module"],"mappings":"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","sourcesContent":["\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Based on JSON2 (http://www.JSON.org/js.html).\n */\n\n(function (exports, nativeJSON) {\n  \"use strict\";\n\n  // use native JSON if it's available\n  if (nativeJSON && nativeJSON.parse){\n    return exports.JSON = {\n      parse: nativeJSON.parse\n    , stringify: nativeJSON.stringify\n    };\n  }\n\n  var JSON = exports.JSON = {};\n\n  function f(n) {\n      // Format integers to have at least two digits.\n      return n < 10 ? '0' + n : n;\n  }\n\n  function date(d, key) {\n    return isFinite(d.valueOf()) ?\n        d.getUTCFullYear()     + '-' +\n        f(d.getUTCMonth() + 1) + '-' +\n        f(d.getUTCDate())      + 'T' +\n        f(d.getUTCHours())     + ':' +\n        f(d.getUTCMinutes())   + ':' +\n        f(d.getUTCSeconds())   + 'Z' : null;\n  };\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = {    // table of character substitutions\n          '\\b': '\\\\b',\n          '\\t': '\\\\t',\n          '\\n': '\\\\n',\n          '\\f': '\\\\f',\n          '\\r': '\\\\r',\n          '\"' : '\\\\\"',\n          '\\\\': '\\\\\\\\'\n      },\n      rep;\n\n\n  function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n      escapable.lastIndex = 0;\n      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n          var c = meta[a];\n          return typeof c === 'string' ? c :\n              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + string + '\"';\n  }\n\n\n  function str(key, holder) {\n\n// Produce a string from holder[key].\n\n      var i,          // The loop counter.\n          k,          // The member key.\n          v,          // The member value.\n          length,\n          mind = gap,\n          partial,\n          value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n      if (value instanceof Date) {\n          value = date(key);\n      }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n      if (typeof rep === 'function') {\n          value = rep.call(holder, key, value);\n      }\n\n// What happens next depends on the value's type.\n\n      switch (typeof value) {\n      case 'string':\n          return quote(value);\n\n      case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n          return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n      case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n          return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n      case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n          if (!value) {\n              return 'null';\n          }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n          gap += indent;\n          partial = [];\n\n// Is the value an array?\n\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n              length = value.length;\n              for (i = 0; i < length; i += 1) {\n                  partial[i] = str(i, value) || 'null';\n              }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n              v = partial.length === 0 ? '[]' : gap ?\n                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                  '[' + partial.join(',') + ']';\n              gap = mind;\n              return v;\n          }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n          if (rep && typeof rep === 'object') {\n              length = rep.length;\n              for (i = 0; i < length; i += 1) {\n                  if (typeof rep[i] === 'string') {\n                      k = rep[i];\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n          v = partial.length === 0 ? '{}' : gap ?\n              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n              '{' + partial.join(',') + '}';\n          gap = mind;\n          return v;\n      }\n  }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n  JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n      var i;\n      gap = '';\n      indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n      if (typeof space === 'number') {\n          for (i = 0; i < space; i += 1) {\n              indent += ' ';\n          }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n      } else if (typeof space === 'string') {\n          indent = space;\n      }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n      rep = replacer;\n      if (replacer && typeof replacer !== 'function' &&\n              (typeof replacer !== 'object' ||\n              typeof replacer.length !== 'number')) {\n          throw new Error('JSON.stringify');\n      }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n      return str('', {'': value});\n  };\n\n// If the JSON object does not yet have a parse method, give it one.\n\n  JSON.parse = function (text, reviver) {\n  // The parse method takes a text and an optional reviver function, and returns\n  // a JavaScript value if the text is a valid JSON text.\n\n      var j;\n\n      function walk(holder, key) {\n\n  // The walk method is used to recursively walk the resulting structure so\n  // that modifications can be made.\n\n          var k, v, value = holder[key];\n          if (value && typeof value === 'object') {\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = walk(value, k);\n                      if (v !== undefined) {\n                          value[k] = v;\n                      } else {\n                          delete value[k];\n                      }\n                  }\n              }\n          }\n          return reviver.call(holder, key, value);\n      }\n\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n\n      text = String(text);\n      cx.lastIndex = 0;\n      if (cx.test(text)) {\n          text = text.replace(cx, function (a) {\n              return '\\\\u' +\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          });\n      }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n      if (/^[\\],:{}\\s]*$/\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n  // In the third stage we use the eval function to compile the text into a\n  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n  // in JavaScript: it can begin a block or an object literal. We wrap the text\n  // in parens to eliminate the ambiguity.\n\n          j = eval('(' + text + ')');\n\n  // In the optional fourth stage, we recursively walk the new structure, passing\n  // each name/value pair to a reviver function for possible transformation.\n\n          return typeof reviver === 'function' ?\n              walk({'': j}, '') : j;\n      }\n\n  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n      throw new SyntaxError('JSON.parse');\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , typeof JSON !== 'undefined' ? JSON : undefined\n);\n"]},"metadata":{},"sourceType":"script"}