{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n(function (exports, io) {\n  /**\n   * Expose constructor.\n   */\n  exports.htmlfile = HTMLFile;\n  /**\n   * The HTMLFile transport creates a `forever iframe` based transport\n   * for Internet Explorer. Regular forever iframe implementations will \n   * continuously trigger the browsers buzy indicators. If the forever iframe\n   * is created inside a `htmlfile` these indicators will not be trigged.\n   *\n   * @constructor\n   * @extends {io.Transport.XHR}\n   * @api public\n   */\n\n  function HTMLFile(socket) {\n    io.Transport.XHR.apply(this, arguments);\n  }\n\n  ;\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(HTMLFile, io.Transport.XHR);\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  HTMLFile.prototype.name = 'htmlfile';\n  /**\n   * Creates a new ActiveX `htmlfile` with a forever loading iframe\n   * that can be used to listen to messages. Inside the generated\n   * `htmlfile` a reference will be made to the HTMLFile transport.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.get = function () {\n    this.doc = new ActiveXObject('htmlfile');\n    this.doc.open();\n    this.doc.write('<html></html>');\n    this.doc.close();\n    this.doc.parentWindow.s = this;\n    var iframeC = this.doc.createElement('div');\n    iframeC.className = 'socketio';\n    this.doc.body.appendChild(iframeC);\n    this.iframe = this.doc.createElement('iframe');\n    iframeC.appendChild(this.iframe);\n    var self = this,\n        query = io.util.query(this.socket.options.query, 't=' + +new Date());\n    this.iframe.src = this.prepareUrl() + query;\n    io.util.on(window, 'unload', function () {\n      self.destroy();\n    });\n  };\n  /**\n   * The Socket.IO server will write script tags inside the forever\n   * iframe, this function will be used as callback for the incoming\n   * information.\n   *\n   * @param {String} data The message\n   * @param {document} doc Reference to the context\n   * @api private\n   */\n\n\n  HTMLFile.prototype._ = function (data, doc) {\n    // unescape all forward slashes. see GH-1251\n    data = data.replace(/\\\\\\//g, '/');\n    this.onData(data);\n\n    try {\n      var script = doc.getElementsByTagName('script')[0];\n      script.parentNode.removeChild(script);\n    } catch (e) {}\n  };\n  /**\n   * Destroy the established connection, iframe and `htmlfile`.\n   * And calls the `CollectGarbage` function of Internet Explorer\n   * to release the memory.\n   *\n   * @api private\n   */\n\n\n  HTMLFile.prototype.destroy = function () {\n    if (this.iframe) {\n      try {\n        this.iframe.src = 'about:blank';\n      } catch (e) {}\n\n      this.doc = null;\n      this.iframe.parentNode.removeChild(this.iframe);\n      this.iframe = null;\n      CollectGarbage();\n    }\n  };\n  /**\n   * Disconnects the established connection.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n\n  HTMLFile.prototype.close = function () {\n    this.destroy();\n    return io.Transport.XHR.prototype.close.call(this);\n  };\n  /**\n   * Checks if the browser supports this transport. The browser\n   * must have an `ActiveXObject` implementation.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n\n  HTMLFile.check = function (socket) {\n    if (typeof window != \"undefined\" && 'ActiveXObject' in window) {\n      try {\n        var a = new ActiveXObject('htmlfile');\n        return a && io.Transport.XHR.check(socket);\n      } catch (e) {}\n    }\n\n    return false;\n  };\n  /**\n   * Check if cross domain requests are supported.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n\n  HTMLFile.xdomainCheck = function () {\n    // we can probably do handling for sub-domains, we should\n    // test that it's cross domain but a subdomain here\n    return false;\n  };\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n\n  io.transports.push('htmlfile');\n})('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/transports/htmlfile.js"],"names":["exports","io","htmlfile","HTMLFile","socket","Transport","XHR","apply","arguments","util","inherit","prototype","name","get","doc","ActiveXObject","open","write","close","parentWindow","s","iframeC","createElement","className","body","appendChild","iframe","self","query","options","Date","src","prepareUrl","on","window","destroy","_","data","replace","onData","script","getElementsByTagName","parentNode","removeChild","e","CollectGarbage","call","check","a","xdomainCheck","transports","push","module","parent"],"mappings":"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","sourcesContent":["/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.htmlfile = HTMLFile;\n\n  /**\n   * The HTMLFile transport creates a `forever iframe` based transport\n   * for Internet Explorer. Regular forever iframe implementations will \n   * continuously trigger the browsers buzy indicators. If the forever iframe\n   * is created inside a `htmlfile` these indicators will not be trigged.\n   *\n   * @constructor\n   * @extends {io.Transport.XHR}\n   * @api public\n   */\n\n  function HTMLFile (socket) {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(HTMLFile, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  HTMLFile.prototype.name = 'htmlfile';\n\n  /**\n   * Creates a new ActiveX `htmlfile` with a forever loading iframe\n   * that can be used to listen to messages. Inside the generated\n   * `htmlfile` a reference will be made to the HTMLFile transport.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.get = function () {\n    this.doc = new ActiveXObject('htmlfile');\n    this.doc.open();\n    this.doc.write('<html></html>');\n    this.doc.close();\n    this.doc.parentWindow.s = this;\n\n    var iframeC = this.doc.createElement('div');\n    iframeC.className = 'socketio';\n\n    this.doc.body.appendChild(iframeC);\n    this.iframe = this.doc.createElement('iframe');\n\n    iframeC.appendChild(this.iframe);\n\n    var self = this\n      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\n    this.iframe.src = this.prepareUrl() + query;\n\n    io.util.on(window, 'unload', function () {\n      self.destroy();\n    });\n  };\n\n  /**\n   * The Socket.IO server will write script tags inside the forever\n   * iframe, this function will be used as callback for the incoming\n   * information.\n   *\n   * @param {String} data The message\n   * @param {document} doc Reference to the context\n   * @api private\n   */\n\n  HTMLFile.prototype._ = function (data, doc) {\n    // unescape all forward slashes. see GH-1251\n    data = data.replace(/\\\\\\//g, '/');\n    this.onData(data);\n    try {\n      var script = doc.getElementsByTagName('script')[0];\n      script.parentNode.removeChild(script);\n    } catch (e) { }\n  };\n\n  /**\n   * Destroy the established connection, iframe and `htmlfile`.\n   * And calls the `CollectGarbage` function of Internet Explorer\n   * to release the memory.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.destroy = function () {\n    if (this.iframe){\n      try {\n        this.iframe.src = 'about:blank';\n      } catch(e){}\n\n      this.doc = null;\n      this.iframe.parentNode.removeChild(this.iframe);\n      this.iframe = null;\n\n      CollectGarbage();\n    }\n  };\n\n  /**\n   * Disconnects the established connection.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  HTMLFile.prototype.close = function () {\n    this.destroy();\n    return io.Transport.XHR.prototype.close.call(this);\n  };\n\n  /**\n   * Checks if the browser supports this transport. The browser\n   * must have an `ActiveXObject` implementation.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  HTMLFile.check = function (socket) {\n    if (typeof window != \"undefined\" && 'ActiveXObject' in window){\n      try {\n        var a = new ActiveXObject('htmlfile');\n        return a && io.Transport.XHR.check(socket);\n      } catch(e){}\n    }\n    return false;\n  };\n\n  /**\n   * Check if cross domain requests are supported.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  HTMLFile.xdomainCheck = function () {\n    // we can probably do handling for sub-domains, we should\n    // test that it's cross domain but a subdomain here\n    return false;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('htmlfile');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n"]},"metadata":{},"sourceType":"script"}