{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n(function (exports, io) {\n  /**\n   * Expose constructor.\n   */\n  exports.Transport = Transport;\n  /**\n   * This is the transport template for all supported transport methods.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function Transport(socket, sessid) {\n    this.socket = socket;\n    this.sessid = sessid;\n  }\n\n  ;\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Transport, io.EventEmitter);\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  Transport.prototype.heartbeats = function () {\n    return true;\n  };\n  /**\n   * Handles the response from the server. When a new response is received\n   * it will automatically update the timeout, decode the message and\n   * forwards the response to the onMessage function for further processing.\n   *\n   * @param {String} data Response from the server.\n   * @api private\n   */\n\n\n  Transport.prototype.onData = function (data) {\n    this.clearCloseTimeout(); // If the connection in currently open (or in a reopening state) reset the close\n    // timeout since we have just received data. This check is necessary so\n    // that we don't reset the timeout on an explicitly disconnected connection.\n\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\n      this.setCloseTimeout();\n    }\n\n    if (data !== '') {\n      // todo: we should only do decodePayload for xhr transports\n      var msgs = io.parser.decodePayload(data);\n\n      if (msgs && msgs.length) {\n        for (var i = 0, l = msgs.length; i < l; i++) {\n          this.onPacket(msgs[i]);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Handles packets.\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.onPacket = function (packet) {\n    this.socket.setHeartbeatTimeout();\n\n    if (packet.type == 'heartbeat') {\n      return this.onHeartbeat();\n    }\n\n    if (packet.type == 'connect' && packet.endpoint == '') {\n      this.onConnect();\n    }\n\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\n      this.isOpen = false;\n    }\n\n    this.socket.onPacket(packet);\n    return this;\n  };\n  /**\n   * Sets close timeout\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.setCloseTimeout = function () {\n    if (!this.closeTimeout) {\n      var self = this;\n      this.closeTimeout = setTimeout(function () {\n        self.onDisconnect();\n      }, this.socket.closeTimeout);\n    }\n  };\n  /**\n   * Called when transport disconnects.\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.onDisconnect = function () {\n    if (this.isOpen) this.close();\n    this.clearTimeouts();\n    this.socket.onDisconnect();\n    return this;\n  };\n  /**\n   * Called when transport connects\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.onConnect = function () {\n    this.socket.onConnect();\n    return this;\n  };\n  /**\n   * Clears close timeout\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.clearCloseTimeout = function () {\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = null;\n    }\n  };\n  /**\n   * Clear timeouts\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.clearTimeouts = function () {\n    this.clearCloseTimeout();\n\n    if (this.reopenTimeout) {\n      clearTimeout(this.reopenTimeout);\n    }\n  };\n  /**\n   * Sends a packet\n   *\n   * @param {Object} packet object.\n   * @api private\n   */\n\n\n  Transport.prototype.packet = function (packet) {\n    this.send(io.parser.encodePacket(packet));\n  };\n  /**\n   * Send the received heartbeat message back to server. So the server\n   * knows we are still connected.\n   *\n   * @param {String} heartbeat Heartbeat response from the server.\n   * @api private\n   */\n\n\n  Transport.prototype.onHeartbeat = function (heartbeat) {\n    this.packet({\n      type: 'heartbeat'\n    });\n  };\n  /**\n   * Called when the transport opens.\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.onOpen = function () {\n    this.isOpen = true;\n    this.clearCloseTimeout();\n    this.socket.onOpen();\n  };\n  /**\n   * Notifies the base when the connection with the Socket.IO server\n   * has been disconnected.\n   *\n   * @api private\n   */\n\n\n  Transport.prototype.onClose = function () {\n    var self = this;\n    /* FIXME: reopen delay causing a infinit loop\n    this.reopenTimeout = setTimeout(function () {\n      self.open();\n    }, this.socket.options['reopen delay']);*/\n\n    this.isOpen = false;\n    this.socket.onClose();\n    this.onDisconnect();\n  };\n  /**\n   * Generates a connection url based on the Socket.IO URL Protocol.\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\n   *\n   * @returns {String} Connection url\n   * @api private\n   */\n\n\n  Transport.prototype.prepareUrl = function () {\n    var options = this.socket.options;\n    return this.scheme() + '://' + options.host + ':' + options.port + '/' + options.resource + '/' + io.protocol + '/' + this.name + '/' + this.sessid;\n  };\n  /**\n   * Checks if the transport is ready to start a connection.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n\n  Transport.prototype.ready = function (socket, fn) {\n    fn.call(this);\n  };\n})('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/transport.js"],"names":["exports","io","Transport","socket","sessid","util","mixin","EventEmitter","prototype","heartbeats","onData","data","clearCloseTimeout","connected","connecting","reconnecting","setCloseTimeout","msgs","parser","decodePayload","length","i","l","onPacket","packet","setHeartbeatTimeout","type","onHeartbeat","endpoint","onConnect","advice","isOpen","closeTimeout","self","setTimeout","onDisconnect","close","clearTimeouts","clearTimeout","reopenTimeout","send","encodePacket","heartbeat","onOpen","onClose","prepareUrl","options","scheme","host","port","resource","protocol","name","ready","fn","call","module","parent"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,CAAC,UAAUA,OAAV,EAAmBC,EAAnB,EAAuB;AAEtB;AACF;AACA;AAEED,EAAAA,OAAO,CAACE,SAAR,GAAoBA,SAApB;AAEA;AACF;AACA;AACA;AACA;AACA;;AAEE,WAASA,SAAT,CAAoBC,MAApB,EAA4BC,MAA5B,EAAoC;AAClC,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD;;AAAA;AAED;AACF;AACA;;AAEEH,EAAAA,EAAE,CAACI,IAAH,CAAQC,KAAR,CAAcJ,SAAd,EAAyBD,EAAE,CAACM,YAA5B;AAGA;AACF;AACA;AACA;AACA;;AAEEL,EAAAA,SAAS,CAACM,SAAV,CAAoBC,UAApB,GAAiC,YAAY;AAC3C,WAAO,IAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEP,EAAAA,SAAS,CAACM,SAAV,CAAoBE,MAApB,GAA6B,UAAUC,IAAV,EAAgB;AAC3C,SAAKC,iBAAL,GAD2C,CAG3C;AACA;AACA;;AACA,QAAI,KAAKT,MAAL,CAAYU,SAAZ,IAAyB,KAAKV,MAAL,CAAYW,UAArC,IAAmD,KAAKX,MAAL,CAAYY,YAAnE,EAAiF;AAC/E,WAAKC,eAAL;AACD;;AAED,QAAIL,IAAI,KAAK,EAAb,EAAiB;AACf;AACA,UAAIM,IAAI,GAAGhB,EAAE,CAACiB,MAAH,CAAUC,aAAV,CAAwBR,IAAxB,CAAX;;AAEA,UAAIM,IAAI,IAAIA,IAAI,CAACG,MAAjB,EAAyB;AACvB,aAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGL,IAAI,CAACG,MAAzB,EAAiCC,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,eAAKE,QAAL,CAAcN,IAAI,CAACI,CAAD,CAAlB;AACD;AACF;AACF;;AAED,WAAO,IAAP;AACD,GAtBD;AAwBA;AACF;AACA;AACA;AACA;;;AAEEnB,EAAAA,SAAS,CAACM,SAAV,CAAoBe,QAApB,GAA+B,UAAUC,MAAV,EAAkB;AAC/C,SAAKrB,MAAL,CAAYsB,mBAAZ;;AAEA,QAAID,MAAM,CAACE,IAAP,IAAe,WAAnB,EAAgC;AAC9B,aAAO,KAAKC,WAAL,EAAP;AACD;;AAED,QAAIH,MAAM,CAACE,IAAP,IAAe,SAAf,IAA4BF,MAAM,CAACI,QAAP,IAAmB,EAAnD,EAAuD;AACrD,WAAKC,SAAL;AACD;;AAED,QAAIL,MAAM,CAACE,IAAP,IAAe,OAAf,IAA0BF,MAAM,CAACM,MAAP,IAAiB,WAA/C,EAA4D;AAC1D,WAAKC,MAAL,GAAc,KAAd;AACD;;AAED,SAAK5B,MAAL,CAAYoB,QAAZ,CAAqBC,MAArB;AAEA,WAAO,IAAP;AACD,GAlBD;AAoBA;AACF;AACA;AACA;AACA;;;AAEEtB,EAAAA,SAAS,CAACM,SAAV,CAAoBQ,eAApB,GAAsC,YAAY;AAChD,QAAI,CAAC,KAAKgB,YAAV,EAAwB;AACtB,UAAIC,IAAI,GAAG,IAAX;AAEA,WAAKD,YAAL,GAAoBE,UAAU,CAAC,YAAY;AACzCD,QAAAA,IAAI,CAACE,YAAL;AACD,OAF6B,EAE3B,KAAKhC,MAAL,CAAY6B,YAFe,CAA9B;AAGD;AACF,GARD;AAUA;AACF;AACA;AACA;AACA;;;AAEE9B,EAAAA,SAAS,CAACM,SAAV,CAAoB2B,YAApB,GAAmC,YAAY;AAC7C,QAAI,KAAKJ,MAAT,EAAiB,KAAKK,KAAL;AACjB,SAAKC,aAAL;AACA,SAAKlC,MAAL,CAAYgC,YAAZ;AACA,WAAO,IAAP;AACD,GALD;AAOA;AACF;AACA;AACA;AACA;;;AAEEjC,EAAAA,SAAS,CAACM,SAAV,CAAoBqB,SAApB,GAAgC,YAAY;AAC1C,SAAK1B,MAAL,CAAY0B,SAAZ;AACA,WAAO,IAAP;AACD,GAHD;AAKA;AACF;AACA;AACA;AACA;;;AAEE3B,EAAAA,SAAS,CAACM,SAAV,CAAoBI,iBAApB,GAAwC,YAAY;AAClD,QAAI,KAAKoB,YAAT,EAAuB;AACrBM,MAAAA,YAAY,CAAC,KAAKN,YAAN,CAAZ;AACA,WAAKA,YAAL,GAAoB,IAApB;AACD;AACF,GALD;AAOA;AACF;AACA;AACA;AACA;;;AAEE9B,EAAAA,SAAS,CAACM,SAAV,CAAoB6B,aAApB,GAAoC,YAAY;AAC9C,SAAKzB,iBAAL;;AAEA,QAAI,KAAK2B,aAAT,EAAwB;AACtBD,MAAAA,YAAY,CAAC,KAAKC,aAAN,CAAZ;AACD;AACF,GAND;AAQA;AACF;AACA;AACA;AACA;AACA;;;AAEErC,EAAAA,SAAS,CAACM,SAAV,CAAoBgB,MAApB,GAA6B,UAAUA,MAAV,EAAkB;AAC7C,SAAKgB,IAAL,CAAUvC,EAAE,CAACiB,MAAH,CAAUuB,YAAV,CAAuBjB,MAAvB,CAAV;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;AACA;AACA;;;AAEEtB,EAAAA,SAAS,CAACM,SAAV,CAAoBmB,WAApB,GAAkC,UAAUe,SAAV,EAAqB;AACrD,SAAKlB,MAAL,CAAY;AAAEE,MAAAA,IAAI,EAAE;AAAR,KAAZ;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AAEExB,EAAAA,SAAS,CAACM,SAAV,CAAoBmC,MAApB,GAA6B,YAAY;AACvC,SAAKZ,MAAL,GAAc,IAAd;AACA,SAAKnB,iBAAL;AACA,SAAKT,MAAL,CAAYwC,MAAZ;AACD,GAJD;AAMA;AACF;AACA;AACA;AACA;AACA;;;AAEEzC,EAAAA,SAAS,CAACM,SAAV,CAAoBoC,OAApB,GAA8B,YAAY;AACxC,QAAIX,IAAI,GAAG,IAAX;AAEA;AACJ;AACA;AACA;;AAEI,SAAKF,MAAL,GAAc,KAAd;AACA,SAAK5B,MAAL,CAAYyC,OAAZ;AACA,SAAKT,YAAL;AACD,GAXD;AAaA;AACF;AACA;AACA;AACA;AACA;AACA;;;AAEEjC,EAAAA,SAAS,CAACM,SAAV,CAAoBqC,UAApB,GAAiC,YAAY;AAC3C,QAAIC,OAAO,GAAG,KAAK3C,MAAL,CAAY2C,OAA1B;AAEA,WAAO,KAAKC,MAAL,KAAgB,KAAhB,GACHD,OAAO,CAACE,IADL,GACY,GADZ,GACkBF,OAAO,CAACG,IAD1B,GACiC,GADjC,GAEHH,OAAO,CAACI,QAFL,GAEgB,GAFhB,GAEsBjD,EAAE,CAACkD,QAFzB,GAGH,GAHG,GAGG,KAAKC,IAHR,GAGe,GAHf,GAGqB,KAAKhD,MAHjC;AAID,GAPD;AASA;AACF;AACA;AACA;AACA;AACA;AACA;;;AAEEF,EAAAA,SAAS,CAACM,SAAV,CAAoB6C,KAApB,GAA4B,UAAUlD,MAAV,EAAkBmD,EAAlB,EAAsB;AAChDA,IAAAA,EAAE,CAACC,IAAH,CAAQ,IAAR;AACD,GAFD;AAGD,CAtPD,EAuPI,eAAe,OAAOtD,EAAtB,GAA2BA,EAA3B,GAAgCuD,MAAM,CAACxD,OAvP3C,EAwPI,eAAe,OAAOC,EAAtB,GAA2BA,EAA3B,GAAgCuD,MAAM,CAACC,MAAP,CAAczD,OAxPlD","sourcesContent":["/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Transport = Transport;\n\n  /**\n   * This is the transport template for all supported transport methods.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function Transport (socket, sessid) {\n    this.socket = socket;\n    this.sessid = sessid;\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Transport, io.EventEmitter);\n\n\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  Transport.prototype.heartbeats = function () {\n    return true;\n  };\n\n  /**\n   * Handles the response from the server. When a new response is received\n   * it will automatically update the timeout, decode the message and\n   * forwards the response to the onMessage function for further processing.\n   *\n   * @param {String} data Response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onData = function (data) {\n    this.clearCloseTimeout();\n\n    // If the connection in currently open (or in a reopening state) reset the close\n    // timeout since we have just received data. This check is necessary so\n    // that we don't reset the timeout on an explicitly disconnected connection.\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\n      this.setCloseTimeout();\n    }\n\n    if (data !== '') {\n      // todo: we should only do decodePayload for xhr transports\n      var msgs = io.parser.decodePayload(data);\n\n      if (msgs && msgs.length) {\n        for (var i = 0, l = msgs.length; i < l; i++) {\n          this.onPacket(msgs[i]);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles packets.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onPacket = function (packet) {\n    this.socket.setHeartbeatTimeout();\n\n    if (packet.type == 'heartbeat') {\n      return this.onHeartbeat();\n    }\n\n    if (packet.type == 'connect' && packet.endpoint == '') {\n      this.onConnect();\n    }\n\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\n      this.isOpen = false;\n    }\n\n    this.socket.onPacket(packet);\n\n    return this;\n  };\n\n  /**\n   * Sets close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.setCloseTimeout = function () {\n    if (!this.closeTimeout) {\n      var self = this;\n\n      this.closeTimeout = setTimeout(function () {\n        self.onDisconnect();\n      }, this.socket.closeTimeout);\n    }\n  };\n\n  /**\n   * Called when transport disconnects.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onDisconnect = function () {\n    if (this.isOpen) this.close();\n    this.clearTimeouts();\n    this.socket.onDisconnect();\n    return this;\n  };\n\n  /**\n   * Called when transport connects\n   *\n   * @api private\n   */\n\n  Transport.prototype.onConnect = function () {\n    this.socket.onConnect();\n    return this;\n  };\n\n  /**\n   * Clears close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearCloseTimeout = function () {\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = null;\n    }\n  };\n\n  /**\n   * Clear timeouts\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearTimeouts = function () {\n    this.clearCloseTimeout();\n\n    if (this.reopenTimeout) {\n      clearTimeout(this.reopenTimeout);\n    }\n  };\n\n  /**\n   * Sends a packet\n   *\n   * @param {Object} packet object.\n   * @api private\n   */\n\n  Transport.prototype.packet = function (packet) {\n    this.send(io.parser.encodePacket(packet));\n  };\n\n  /**\n   * Send the received heartbeat message back to server. So the server\n   * knows we are still connected.\n   *\n   * @param {String} heartbeat Heartbeat response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onHeartbeat = function (heartbeat) {\n    this.packet({ type: 'heartbeat' });\n  };\n\n  /**\n   * Called when the transport opens.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onOpen = function () {\n    this.isOpen = true;\n    this.clearCloseTimeout();\n    this.socket.onOpen();\n  };\n\n  /**\n   * Notifies the base when the connection with the Socket.IO server\n   * has been disconnected.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onClose = function () {\n    var self = this;\n\n    /* FIXME: reopen delay causing a infinit loop\n    this.reopenTimeout = setTimeout(function () {\n      self.open();\n    }, this.socket.options['reopen delay']);*/\n\n    this.isOpen = false;\n    this.socket.onClose();\n    this.onDisconnect();\n  };\n\n  /**\n   * Generates a connection url based on the Socket.IO URL Protocol.\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\n   *\n   * @returns {String} Connection url\n   * @api private\n   */\n\n  Transport.prototype.prepareUrl = function () {\n    var options = this.socket.options;\n\n    return this.scheme() + '://'\n      + options.host + ':' + options.port + '/'\n      + options.resource + '/' + io.protocol\n      + '/' + this.name + '/' + this.sessid;\n  };\n\n  /**\n   * Checks if the transport is ready to start a connection.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Transport.prototype.ready = function (socket, fn) {\n    fn.call(this);\n  };\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n"]},"metadata":{},"sourceType":"script"}