{"ast":null,"code":"export function attachEventProps(node, newProps, oldProps = {}) {\n  const className = getClassName(node.classList, newProps, oldProps);\n\n  if (className) {\n    node.className = className;\n  }\n\n  Object.keys(newProps).forEach(name => {\n    if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n      return;\n    }\n\n    if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n      const eventName = name.substring(2);\n      const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n      if (!isCoveredByReact(eventNameLc)) {\n        syncEvent(node, eventNameLc, newProps[name]);\n      }\n    } else {\n      node[name] = newProps[name];\n    }\n  });\n}\nexport function getClassName(classList, newProps, oldProps) {\n  // map the classes to Maps for performance\n  const currentClasses = arrayToMap(classList);\n  const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n  const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n  const finalClassNames = []; // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n\n  currentClasses.forEach(currentClass => {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(s => finalClassNames.push(s));\n  return finalClassNames.join(' ');\n}\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\n\nexport function isCoveredByReact(eventNameSuffix, doc = document) {\n  const eventName = 'on' + eventNameSuffix;\n  let isSupported = (eventName in doc);\n\n  if (!isSupported) {\n    const element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\nexport function syncEvent(node, eventName, newEventHandler) {\n  const eventStore = node.__events || (node.__events = {});\n  const oldEventHandler = eventStore[eventName]; // Remove old listener so they don't double up.\n\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  }\n\n  if (newEventHandler != null) {\n    // Bind new listener.\n    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n      newEventHandler.call(this, e);\n    });\n  }\n}\n\nfunction arrayToMap(arr) {\n  const map = new Map();\n  arr.forEach(s => map.set(s, s));\n  return map;\n}","map":{"version":3,"sources":["../../../src/react-component-lib/utils/attachEventProps.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export function attachEventProps(node, newProps, oldProps = {}) {\n    const className = getClassName(node.classList, newProps, oldProps);\n    if (className) {\n        node.className = className;\n    }\n    Object.keys(newProps).forEach(name => {\n        if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n            return;\n        }\n        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n            const eventName = name.substring(2);\n            const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n            if (!isCoveredByReact(eventNameLc)) {\n                syncEvent(node, eventNameLc, newProps[name]);\n            }\n        }\n        else {\n            node[name] = newProps[name];\n        }\n    });\n}\nexport function getClassName(classList, newProps, oldProps) {\n    // map the classes to Maps for performance\n    const currentClasses = arrayToMap(classList);\n    const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n    const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n    const finalClassNames = [];\n    // loop through each of the current classes on the component\n    // to see if it should be a part of the classNames added\n    currentClasses.forEach(currentClass => {\n        if (incomingPropClasses.has(currentClass)) {\n            // add it as its already included in classnames coming in from newProps\n            finalClassNames.push(currentClass);\n            incomingPropClasses.delete(currentClass);\n        }\n        else if (!oldPropClasses.has(currentClass)) {\n            // add it as it has NOT been removed by user\n            finalClassNames.push(currentClass);\n        }\n    });\n    incomingPropClasses.forEach(s => finalClassNames.push(s));\n    return finalClassNames.join(' ');\n}\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nexport function isCoveredByReact(eventNameSuffix, doc = document) {\n    const eventName = 'on' + eventNameSuffix;\n    let isSupported = eventName in doc;\n    if (!isSupported) {\n        const element = doc.createElement('div');\n        element.setAttribute(eventName, 'return;');\n        isSupported = typeof element[eventName] === 'function';\n    }\n    return isSupported;\n}\nexport function syncEvent(node, eventName, newEventHandler) {\n    const eventStore = node.__events || (node.__events = {});\n    const oldEventHandler = eventStore[eventName];\n    // Remove old listener so they don't double up.\n    if (oldEventHandler) {\n        node.removeEventListener(eventName, oldEventHandler);\n    }\n    if (newEventHandler != null) {\n        // Bind new listener.\n        node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {\n            newEventHandler.call(this, e);\n        }));\n    }\n}\nfunction arrayToMap(arr) {\n    const map = new Map();\n    arr.forEach((s) => map.set(s, s));\n    return map;\n}\n//# sourceMappingURL=attachEventProps.js.map"]},"metadata":{},"sourceType":"module"}