{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n(function (exports, io, global) {\n  /**\n   * Expose constructor.\n   */\n  exports['xhr-polling'] = XHRPolling;\n  /**\n   * The XHR-polling transport uses long polling XHR requests to create a\n   * \"persistent\" connection with the server.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function XHRPolling() {\n    io.Transport.XHR.apply(this, arguments);\n  }\n\n  ;\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(XHRPolling, io.Transport.XHR);\n  /**\n   * Merge the properties from XHR transport\n   */\n\n  io.util.merge(XHRPolling, io.Transport.XHR);\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  XHRPolling.prototype.name = 'xhr-polling';\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.heartbeats = function () {\n    return false;\n  };\n  /** \n   * Establish a connection, for iPhone and Android this will be done once the page\n   * is loaded.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n\n  XHRPolling.prototype.open = function () {\n    var self = this;\n    io.Transport.XHR.prototype.open.call(self);\n    return false;\n  };\n  /**\n   * Starts a XHR request to wait for incoming messages.\n   *\n   * @api private\n   */\n\n\n  function empty() {}\n\n  ;\n\n  XHRPolling.prototype.get = function () {\n    if (!this.isOpen) return;\n    var self = this;\n\n    function stateChange() {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n\n        if (this.status == 200) {\n          self.onData(this.responseText);\n          self.get();\n        } else {\n          self.onClose();\n        }\n      }\n    }\n\n    ;\n\n    function onload() {\n      this.onload = empty;\n      this.onerror = empty;\n      self.retryCounter = 1;\n      self.onData(this.responseText);\n      self.get();\n    }\n\n    ;\n\n    function onerror() {\n      self.retryCounter++;\n\n      if (!self.retryCounter || self.retryCounter > 3) {\n        self.onClose();\n      } else {\n        self.get();\n      }\n    }\n\n    ;\n    this.xhr = this.request();\n\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n      this.xhr.onload = onload;\n      this.xhr.onerror = onerror;\n    } else {\n      this.xhr.onreadystatechange = stateChange;\n    }\n\n    this.xhr.send(null);\n  };\n  /**\n   * Handle the unclean close behavior.\n   *\n   * @api private\n   */\n\n\n  XHRPolling.prototype.onClose = function () {\n    io.Transport.XHR.prototype.onClose.call(this);\n\n    if (this.xhr) {\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\n\n      try {\n        this.xhr.abort();\n      } catch (e) {}\n\n      this.xhr = null;\n    }\n  };\n  /**\n   * Webkit based browsers show a infinit spinner when you start a XHR request\n   * before the browsers onload event is called so we need to defer opening of\n   * the transport until the onload event is called. Wrapping the cb in our\n   * defer method solve this.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n\n  XHRPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n    io.util.defer(function () {\n      fn.call(self);\n    });\n  };\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n\n  io.transports.push('xhr-polling');\n})('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/transports/xhr-polling.js"],"names":["exports","io","global","XHRPolling","Transport","XHR","apply","arguments","util","inherit","merge","prototype","name","heartbeats","open","self","call","empty","get","isOpen","stateChange","readyState","onreadystatechange","status","onData","responseText","onClose","onload","onerror","retryCounter","xhr","request","XDomainRequest","send","abort","e","ready","socket","fn","defer","transports","push","module","parent"],"mappings":"AACA;AACA;AACA;AACA;AACA;AAEA,CAAC,UAAUA,OAAV,EAAmBC,EAAnB,EAAuBC,MAAvB,EAA+B;AAE9B;AACF;AACA;AAEEF,EAAAA,OAAO,CAAC,aAAD,CAAP,GAAyBG,UAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE,WAASA,UAAT,GAAuB;AACrBF,IAAAA,EAAE,CAACG,SAAH,CAAaC,GAAb,CAAiBC,KAAjB,CAAuB,IAAvB,EAA6BC,SAA7B;AACD;;AAAA;AAED;AACF;AACA;;AAEEN,EAAAA,EAAE,CAACO,IAAH,CAAQC,OAAR,CAAgBN,UAAhB,EAA4BF,EAAE,CAACG,SAAH,CAAaC,GAAzC;AAEA;AACF;AACA;;AAEEJ,EAAAA,EAAE,CAACO,IAAH,CAAQE,KAAR,CAAcP,UAAd,EAA0BF,EAAE,CAACG,SAAH,CAAaC,GAAvC;AAEA;AACF;AACA;AACA;AACA;;AAEEF,EAAAA,UAAU,CAACQ,SAAX,CAAqBC,IAArB,GAA4B,aAA5B;AAEA;AACF;AACA;AACA;AACA;;AAEET,EAAAA,UAAU,CAACQ,SAAX,CAAqBE,UAArB,GAAkC,YAAY;AAC5C,WAAO,KAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;AACA;AACA;;;AAEEV,EAAAA,UAAU,CAACQ,SAAX,CAAqBG,IAArB,GAA4B,YAAY;AACtC,QAAIC,IAAI,GAAG,IAAX;AAEAd,IAAAA,EAAE,CAACG,SAAH,CAAaC,GAAb,CAAiBM,SAAjB,CAA2BG,IAA3B,CAAgCE,IAAhC,CAAqCD,IAArC;AACA,WAAO,KAAP;AACD,GALD;AAOA;AACF;AACA;AACA;AACA;;;AAEE,WAASE,KAAT,GAAkB,CAAE;;AAAA;;AAEpBd,EAAAA,UAAU,CAACQ,SAAX,CAAqBO,GAArB,GAA2B,YAAY;AACrC,QAAI,CAAC,KAAKC,MAAV,EAAkB;AAElB,QAAIJ,IAAI,GAAG,IAAX;;AAEA,aAASK,WAAT,GAAwB;AACtB,UAAI,KAAKC,UAAL,IAAmB,CAAvB,EAA0B;AACxB,aAAKC,kBAAL,GAA0BL,KAA1B;;AAEA,YAAI,KAAKM,MAAL,IAAe,GAAnB,EAAwB;AACtBR,UAAAA,IAAI,CAACS,MAAL,CAAY,KAAKC,YAAjB;AACAV,UAAAA,IAAI,CAACG,GAAL;AACD,SAHD,MAGO;AACLH,UAAAA,IAAI,CAACW,OAAL;AACD;AACF;AACF;;AAAA;;AAED,aAASC,MAAT,GAAmB;AACjB,WAAKA,MAAL,GAAcV,KAAd;AACA,WAAKW,OAAL,GAAeX,KAAf;AACAF,MAAAA,IAAI,CAACc,YAAL,GAAoB,CAApB;AACAd,MAAAA,IAAI,CAACS,MAAL,CAAY,KAAKC,YAAjB;AACAV,MAAAA,IAAI,CAACG,GAAL;AACD;;AAAA;;AAED,aAASU,OAAT,GAAoB;AAClBb,MAAAA,IAAI,CAACc,YAAL;;AACA,UAAG,CAACd,IAAI,CAACc,YAAN,IAAsBd,IAAI,CAACc,YAAL,GAAoB,CAA7C,EAAgD;AAC9Cd,QAAAA,IAAI,CAACW,OAAL;AACD,OAFD,MAEO;AACLX,QAAAA,IAAI,CAACG,GAAL;AACD;AACF;;AAAA;AAED,SAAKY,GAAL,GAAW,KAAKC,OAAL,EAAX;;AAEA,QAAI7B,MAAM,CAAC8B,cAAP,IAAyB,KAAKF,GAAL,YAAoBE,cAAjD,EAAiE;AAC/D,WAAKF,GAAL,CAASH,MAAT,GAAkBA,MAAlB;AACA,WAAKG,GAAL,CAASF,OAAT,GAAmBA,OAAnB;AACD,KAHD,MAGO;AACL,WAAKE,GAAL,CAASR,kBAAT,GAA8BF,WAA9B;AACD;;AAED,SAAKU,GAAL,CAASG,IAAT,CAAc,IAAd;AACD,GA7CD;AA+CA;AACF;AACA;AACA;AACA;;;AAEE9B,EAAAA,UAAU,CAACQ,SAAX,CAAqBe,OAArB,GAA+B,YAAY;AACzCzB,IAAAA,EAAE,CAACG,SAAH,CAAaC,GAAb,CAAiBM,SAAjB,CAA2Be,OAA3B,CAAmCV,IAAnC,CAAwC,IAAxC;;AAEA,QAAI,KAAKc,GAAT,EAAc;AACZ,WAAKA,GAAL,CAASR,kBAAT,GAA8B,KAAKQ,GAAL,CAASH,MAAT,GAAkB,KAAKG,GAAL,CAASF,OAAT,GAAmBX,KAAnE;;AACA,UAAI;AACF,aAAKa,GAAL,CAASI,KAAT;AACD,OAFD,CAEE,OAAMC,CAAN,EAAQ,CAAE;;AACZ,WAAKL,GAAL,GAAW,IAAX;AACD;AACF,GAVD;AAYA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEE3B,EAAAA,UAAU,CAACQ,SAAX,CAAqByB,KAArB,GAA6B,UAAUC,MAAV,EAAkBC,EAAlB,EAAsB;AACjD,QAAIvB,IAAI,GAAG,IAAX;AAEAd,IAAAA,EAAE,CAACO,IAAH,CAAQ+B,KAAR,CAAc,YAAY;AACxBD,MAAAA,EAAE,CAACtB,IAAH,CAAQD,IAAR;AACD,KAFD;AAGD,GAND;AAQA;AACF;AACA;AACA;AACA;;;AAEEd,EAAAA,EAAE,CAACuC,UAAH,CAAcC,IAAd,CAAmB,aAAnB;AAED,CArKD,EAsKI,eAAe,OAAOxC,EAAtB,GAA2BA,EAAE,CAACG,SAA9B,GAA0CsC,MAAM,CAAC1C,OAtKrD,EAuKI,eAAe,OAAOC,EAAtB,GAA2BA,EAA3B,GAAgCyC,MAAM,CAACC,MAAP,CAAc3C,OAvKlD,EAwKI,IAxKJ","sourcesContent":["\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['xhr-polling'] = XHRPolling;\n\n  /**\n   * The XHR-polling transport uses long polling XHR requests to create a\n   * \"persistent\" connection with the server.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function XHRPolling () {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Merge the properties from XHR transport\n   */\n\n  io.util.merge(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  XHRPolling.prototype.name = 'xhr-polling';\n\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.heartbeats = function () {\n    return false;\n  };\n\n  /** \n   * Establish a connection, for iPhone and Android this will be done once the page\n   * is loaded.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  XHRPolling.prototype.open = function () {\n    var self = this;\n\n    io.Transport.XHR.prototype.open.call(self);\n    return false;\n  };\n\n  /**\n   * Starts a XHR request to wait for incoming messages.\n   *\n   * @api private\n   */\n\n  function empty () {};\n\n  XHRPolling.prototype.get = function () {\n    if (!this.isOpen) return;\n\n    var self = this;\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n\n        if (this.status == 200) {\n          self.onData(this.responseText);\n          self.get();\n        } else {\n          self.onClose();\n        }\n      }\n    };\n\n    function onload () {\n      this.onload = empty;\n      this.onerror = empty;\n      self.retryCounter = 1;\n      self.onData(this.responseText);\n      self.get();\n    };\n\n    function onerror () {\n      self.retryCounter ++;\n      if(!self.retryCounter || self.retryCounter > 3) {\n        self.onClose();  \n      } else {\n        self.get();\n      }\n    };\n\n    this.xhr = this.request();\n\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n      this.xhr.onload = onload;\n      this.xhr.onerror = onerror;\n    } else {\n      this.xhr.onreadystatechange = stateChange;\n    }\n\n    this.xhr.send(null);\n  };\n\n  /**\n   * Handle the unclean close behavior.\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.onClose = function () {\n    io.Transport.XHR.prototype.onClose.call(this);\n\n    if (this.xhr) {\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\n      try {\n        this.xhr.abort();\n      } catch(e){}\n      this.xhr = null;\n    }\n  };\n\n  /**\n   * Webkit based browsers show a infinit spinner when you start a XHR request\n   * before the browsers onload event is called so we need to defer opening of\n   * the transport until the onload event is called. Wrapping the cb in our\n   * defer method solve this.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  XHRPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n\n    io.util.defer(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('xhr-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n"]},"metadata":{},"sourceType":"script"}