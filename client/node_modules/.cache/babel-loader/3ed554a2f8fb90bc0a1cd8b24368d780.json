{"ast":null,"code":"/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n(function (exports, io, global) {\n  /**\n   * Expose constructor.\n   */\n  exports.Socket = Socket;\n  /**\n   * Create a new `Socket.IO client` which can establish a persistent\n   * connection with a Socket.IO enabled server.\n   *\n   * @api public\n   */\n\n  function Socket(options) {\n    this.options = {\n      port: 80,\n      secure: false,\n      document: 'document' in global ? document : false,\n      resource: 'socket.io',\n      transports: io.transports,\n      'connect timeout': 10000,\n      'try multiple transports': true,\n      'reconnect': true,\n      'reconnection delay': 500,\n      'reconnection limit': Infinity,\n      'reopen delay': 3000,\n      'max reconnection attempts': 10,\n      'sync disconnect on unload': false,\n      'auto connect': true,\n      'flash policy port': 10843,\n      'manualFlush': false\n    };\n    io.util.merge(this.options, options);\n    this.connected = false;\n    this.open = false;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.namespaces = {};\n    this.buffer = [];\n    this.doBuffer = false;\n\n    if (this.options['sync disconnect on unload'] && (!this.isXDomain() || io.util.ua.hasCORS)) {\n      var self = this;\n      io.util.on(global, 'beforeunload', function () {\n        self.disconnectSync();\n      }, false);\n    }\n\n    if (this.options['auto connect']) {\n      this.connect();\n    }\n  }\n\n  ;\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Socket, io.EventEmitter);\n  /**\n   * Returns a namespace listener/emitter for this socket\n   *\n   * @api public\n   */\n\n  Socket.prototype.of = function (name) {\n    if (!this.namespaces[name]) {\n      this.namespaces[name] = new io.SocketNamespace(this, name);\n\n      if (name !== '') {\n        this.namespaces[name].packet({\n          type: 'connect'\n        });\n      }\n    }\n\n    return this.namespaces[name];\n  };\n  /**\n   * Emits the given event to the Socket and all namespaces\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.publish = function () {\n    this.emit.apply(this, arguments);\n    var nsp;\n\n    for (var i in this.namespaces) {\n      if (this.namespaces.hasOwnProperty(i)) {\n        nsp = this.of(i);\n        nsp.$emit.apply(nsp, arguments);\n      }\n    }\n  };\n  /**\n   * Performs the handshake\n   *\n   * @api private\n   */\n\n\n  function empty() {}\n\n  ;\n\n  Socket.prototype.handshake = function (fn) {\n    var self = this,\n        options = this.options;\n\n    function complete(data) {\n      if (data instanceof Error) {\n        self.connecting = false;\n        self.onError(data.message);\n      } else {\n        fn.apply(null, data.split(':'));\n      }\n    }\n\n    ;\n    var url = ['http' + (options.secure ? 's' : '') + ':/', options.host + ':' + options.port, options.resource, io.protocol, io.util.query(this.options.query, 't=' + +new Date())].join('/');\n\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\n      var insertAt = document.getElementsByTagName('script')[0],\n          script = document.createElement('script');\n      script.src = url + '&jsonp=' + io.j.length;\n      insertAt.parentNode.insertBefore(script, insertAt);\n      io.j.push(function (data) {\n        complete(data);\n        script.parentNode.removeChild(script);\n      });\n    } else {\n      var xhr = io.util.request();\n      xhr.open('GET', url, true);\n\n      if (this.isXDomain()) {\n        xhr.withCredentials = true;\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          xhr.onreadystatechange = empty;\n\n          if (xhr.status == 200) {\n            complete(xhr.responseText);\n          } else if (xhr.status == 403) {\n            self.onError(xhr.responseText);\n          } else {\n            self.connecting = false;\n            !self.reconnecting && self.onError(xhr.responseText);\n          }\n        }\n      };\n\n      xhr.send(null);\n    }\n  };\n  /**\n   * Find an available transport based on the options supplied in the constructor.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.getTransport = function (override) {\n    var transports = override || this.transports,\n        match;\n\n    for (var i = 0, transport; transport = transports[i]; i++) {\n      if (io.Transport[transport] && io.Transport[transport].check(this) && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\n        return new io.Transport[transport](this, this.sessionid);\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Connects to the server.\n   *\n   * @param {Function} [fn] Callback.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n\n  Socket.prototype.connect = function (fn) {\n    if (this.connecting) {\n      return this;\n    }\n\n    var self = this;\n    self.connecting = true;\n    this.handshake(function (sid, heartbeat, close, transports) {\n      self.sessionid = sid;\n      self.closeTimeout = close * 1000;\n      self.heartbeatTimeout = heartbeat * 1000;\n      if (!self.transports) self.transports = self.origTransports = transports ? io.util.intersect(transports.split(','), self.options.transports) : self.options.transports;\n      self.setHeartbeatTimeout();\n\n      function connect(transports) {\n        if (self.transport) self.transport.clearTimeouts();\n        self.transport = self.getTransport(transports);\n        if (!self.transport) return self.publish('connect_failed'); // once the transport is ready\n\n        self.transport.ready(self, function () {\n          self.connecting = true;\n          self.publish('connecting', self.transport.name);\n          self.transport.open();\n\n          if (self.options['connect timeout']) {\n            self.connectTimeoutTimer = setTimeout(function () {\n              if (!self.connected) {\n                self.connecting = false;\n\n                if (self.options['try multiple transports']) {\n                  var remaining = self.transports;\n\n                  while (remaining.length > 0 && remaining.splice(0, 1)[0] != self.transport.name) {}\n\n                  if (remaining.length) {\n                    connect(remaining);\n                  } else {\n                    self.publish('connect_failed');\n                  }\n                }\n              }\n            }, self.options['connect timeout']);\n          }\n        });\n      }\n\n      connect(self.transports);\n      self.once('connect', function () {\n        clearTimeout(self.connectTimeoutTimer);\n        fn && typeof fn == 'function' && fn();\n      });\n    });\n    return this;\n  };\n  /**\n   * Clears and sets a new heartbeat timeout using the value given by the\n   * server during the handshake.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.setHeartbeatTimeout = function () {\n    clearTimeout(this.heartbeatTimeoutTimer);\n    if (this.transport && !this.transport.heartbeats()) return;\n    var self = this;\n    this.heartbeatTimeoutTimer = setTimeout(function () {\n      self.transport.onClose();\n    }, this.heartbeatTimeout);\n  };\n  /**\n   * Sends a message.\n   *\n   * @param {Object} data packet.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n\n  Socket.prototype.packet = function (data) {\n    if (this.connected && !this.doBuffer) {\n      this.transport.packet(data);\n    } else {\n      this.buffer.push(data);\n    }\n\n    return this;\n  };\n  /**\n   * Sets buffer state\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.setBuffer = function (v) {\n    this.doBuffer = v;\n\n    if (!v && this.connected && this.buffer.length) {\n      if (!this.options['manualFlush']) {\n        this.flushBuffer();\n      }\n    }\n  };\n  /**\n   * Flushes the buffer data over the wire.\n   * To be invoked manually when 'manualFlush' is set to true.\n   *\n   * @api public\n   */\n\n\n  Socket.prototype.flushBuffer = function () {\n    this.transport.payload(this.buffer);\n    this.buffer = [];\n  };\n  /**\n   * Disconnect the established connect.\n   *\n   * @returns {io.Socket}\n   * @api public\n   */\n\n\n  Socket.prototype.disconnect = function () {\n    if (this.connected || this.connecting) {\n      if (this.open) {\n        this.of('').packet({\n          type: 'disconnect'\n        });\n      } // handle disconnection immediately\n\n\n      this.onDisconnect('booted');\n    }\n\n    return this;\n  };\n  /**\n   * Disconnects the socket with a sync XHR.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.disconnectSync = function () {\n    // ensure disconnection\n    var xhr = io.util.request();\n    var uri = ['http' + (this.options.secure ? 's' : '') + ':/', this.options.host + ':' + this.options.port, this.options.resource, io.protocol, '', this.sessionid].join('/') + '/?disconnect=1';\n    xhr.open('GET', uri, false);\n    xhr.send(null); // handle disconnection immediately\n\n    this.onDisconnect('booted');\n  };\n  /**\n   * Check if we need to use cross domain enabled transports. Cross domain would\n   * be a different port or different domain name.\n   *\n   * @returns {Boolean}\n   * @api private\n   */\n\n\n  Socket.prototype.isXDomain = function () {\n    // if node\n    return false; // end node\n\n    var port = global.location.port || ('https:' == global.location.protocol ? 443 : 80);\n    return this.options.host !== global.location.hostname || this.options.port != port;\n  };\n  /**\n   * Called upon handshake.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.onConnect = function () {\n    if (!this.connected) {\n      this.connected = true;\n      this.connecting = false;\n\n      if (!this.doBuffer) {\n        // make sure to flush the buffer\n        this.setBuffer(false);\n      }\n\n      this.emit('connect');\n    }\n  };\n  /**\n   * Called when the transport opens\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.onOpen = function () {\n    this.open = true;\n  };\n  /**\n   * Called when the transport closes.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.onClose = function () {\n    this.open = false;\n    clearTimeout(this.heartbeatTimeoutTimer);\n  };\n  /**\n   * Called when the transport first opens a connection\n   *\n   * @param text\n   */\n\n\n  Socket.prototype.onPacket = function (packet) {\n    this.of(packet.endpoint).onPacket(packet);\n  };\n  /**\n   * Handles an error.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.onError = function (err) {\n    if (err && err.advice) {\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\n        this.disconnect();\n\n        if (this.options.reconnect) {\n          this.reconnect();\n        }\n      }\n    }\n\n    this.publish('error', err && err.reason ? err.reason : err);\n  };\n  /**\n   * Called when the transport disconnects.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.onDisconnect = function (reason) {\n    var wasConnected = this.connected,\n        wasConnecting = this.connecting;\n    this.connected = false;\n    this.connecting = false;\n    this.open = false;\n\n    if (wasConnected || wasConnecting) {\n      this.transport.close();\n      this.transport.clearTimeouts();\n\n      if (wasConnected) {\n        this.publish('disconnect', reason);\n\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n          this.reconnect();\n        }\n      }\n    }\n  };\n  /**\n   * Called upon reconnection.\n   *\n   * @api private\n   */\n\n\n  Socket.prototype.reconnect = function () {\n    this.reconnecting = true;\n    this.reconnectionAttempts = 0;\n    this.reconnectionDelay = this.options['reconnection delay'];\n    var self = this,\n        maxAttempts = this.options['max reconnection attempts'],\n        tryMultiple = this.options['try multiple transports'],\n        limit = this.options['reconnection limit'];\n\n    function reset() {\n      if (self.connected) {\n        for (var i in self.namespaces) {\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n            self.namespaces[i].packet({\n              type: 'connect'\n            });\n          }\n        }\n\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n      }\n\n      clearTimeout(self.reconnectionTimer);\n      self.removeListener('connect_failed', maybeReconnect);\n      self.removeListener('connect', maybeReconnect);\n      self.reconnecting = false;\n      delete self.reconnectionAttempts;\n      delete self.reconnectionDelay;\n      delete self.reconnectionTimer;\n      delete self.redoTransports;\n      self.options['try multiple transports'] = tryMultiple;\n    }\n\n    ;\n\n    function maybeReconnect() {\n      if (!self.reconnecting) {\n        return;\n      }\n\n      if (self.connected) {\n        return reset();\n      }\n\n      ;\n\n      if (self.connecting && self.reconnecting) {\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n      }\n\n      if (self.reconnectionAttempts++ >= maxAttempts) {\n        if (!self.redoTransports) {\n          self.on('connect_failed', maybeReconnect);\n          self.options['try multiple transports'] = true;\n          self.transports = self.origTransports;\n          self.transport = self.getTransport();\n          self.redoTransports = true;\n          self.connect();\n        } else {\n          self.publish('reconnect_failed');\n          reset();\n        }\n      } else {\n        if (self.reconnectionDelay < limit) {\n          self.reconnectionDelay *= 2; // exponential back off\n        }\n\n        self.connect();\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n      }\n    }\n\n    ;\n    this.options['try multiple transports'] = false;\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n    this.on('connect', maybeReconnect);\n  };\n})('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/socket.io-proxy/node_modules/socket.io-client/lib/socket.js"],"names":["exports","io","global","Socket","options","port","secure","document","resource","transports","Infinity","util","merge","connected","open","connecting","reconnecting","namespaces","buffer","doBuffer","isXDomain","ua","hasCORS","self","on","disconnectSync","connect","mixin","EventEmitter","prototype","of","name","SocketNamespace","packet","type","publish","emit","apply","arguments","nsp","i","hasOwnProperty","$emit","empty","handshake","fn","complete","data","Error","onError","message","split","url","host","protocol","query","Date","join","insertAt","getElementsByTagName","script","createElement","src","j","length","parentNode","insertBefore","push","removeChild","xhr","request","withCredentials","onreadystatechange","readyState","status","responseText","send","getTransport","override","match","transport","Transport","check","xdomainCheck","sessionid","sid","heartbeat","close","closeTimeout","heartbeatTimeout","origTransports","intersect","setHeartbeatTimeout","clearTimeouts","ready","connectTimeoutTimer","setTimeout","remaining","splice","once","clearTimeout","heartbeatTimeoutTimer","heartbeats","onClose","setBuffer","v","flushBuffer","payload","disconnect","onDisconnect","uri","location","hostname","onConnect","onOpen","onPacket","endpoint","err","advice","reconnect","reason","wasConnected","wasConnecting","reconnectionAttempts","reconnectionDelay","maxAttempts","tryMultiple","limit","reset","reconnectionTimer","removeListener","maybeReconnect","redoTransports","module","parent"],"mappings":"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","sourcesContent":["/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Socket = Socket;\n\n  /**\n   * Create a new `Socket.IO client` which can establish a persistent\n   * connection with a Socket.IO enabled server.\n   *\n   * @api public\n   */\n\n  function Socket (options) {\n    this.options = {\n        port: 80\n      , secure: false\n      , document: 'document' in global ? document : false\n      , resource: 'socket.io'\n      , transports: io.transports\n      , 'connect timeout': 10000\n      , 'try multiple transports': true\n      , 'reconnect': true\n      , 'reconnection delay': 500\n      , 'reconnection limit': Infinity\n      , 'reopen delay': 3000\n      , 'max reconnection attempts': 10\n      , 'sync disconnect on unload': false\n      , 'auto connect': true\n      , 'flash policy port': 10843\n      , 'manualFlush': false\n    };\n\n    io.util.merge(this.options, options);\n\n    this.connected = false;\n    this.open = false;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.namespaces = {};\n    this.buffer = [];\n    this.doBuffer = false;\n\n    if (this.options['sync disconnect on unload'] &&\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\n      var self = this;\n      io.util.on(global, 'beforeunload', function () {\n        self.disconnectSync();\n      }, false);\n    }\n\n    if (this.options['auto connect']) {\n      this.connect();\n    }\n};\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Socket, io.EventEmitter);\n\n  /**\n   * Returns a namespace listener/emitter for this socket\n   *\n   * @api public\n   */\n\n  Socket.prototype.of = function (name) {\n    if (!this.namespaces[name]) {\n      this.namespaces[name] = new io.SocketNamespace(this, name);\n\n      if (name !== '') {\n        this.namespaces[name].packet({ type: 'connect' });\n      }\n    }\n\n    return this.namespaces[name];\n  };\n\n  /**\n   * Emits the given event to the Socket and all namespaces\n   *\n   * @api private\n   */\n\n  Socket.prototype.publish = function () {\n    this.emit.apply(this, arguments);\n\n    var nsp;\n\n    for (var i in this.namespaces) {\n      if (this.namespaces.hasOwnProperty(i)) {\n        nsp = this.of(i);\n        nsp.$emit.apply(nsp, arguments);\n      }\n    }\n  };\n\n  /**\n   * Performs the handshake\n   *\n   * @api private\n   */\n\n  function empty () { };\n\n  Socket.prototype.handshake = function (fn) {\n    var self = this\n      , options = this.options;\n\n    function complete (data) {\n      if (data instanceof Error) {\n        self.connecting = false;\n        self.onError(data.message);\n      } else {\n        fn.apply(null, data.split(':'));\n      }\n    };\n\n    var url = [\n          'http' + (options.secure ? 's' : '') + ':/'\n        , options.host + ':' + options.port\n        , options.resource\n        , io.protocol\n        , io.util.query(this.options.query, 't=' + +new Date)\n      ].join('/');\n\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\n      var insertAt = document.getElementsByTagName('script')[0]\n        , script = document.createElement('script');\n\n      script.src = url + '&jsonp=' + io.j.length;\n      insertAt.parentNode.insertBefore(script, insertAt);\n\n      io.j.push(function (data) {\n        complete(data);\n        script.parentNode.removeChild(script);\n      });\n    } else {\n      var xhr = io.util.request();\n\n      xhr.open('GET', url, true);\n      if (this.isXDomain()) {\n        xhr.withCredentials = true;\n      }\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          xhr.onreadystatechange = empty;\n\n          if (xhr.status == 200) {\n            complete(xhr.responseText);\n          } else if (xhr.status == 403) {\n            self.onError(xhr.responseText);\n          } else {\n            self.connecting = false;            \n            !self.reconnecting && self.onError(xhr.responseText);\n          }\n        }\n      };\n      xhr.send(null);\n    }\n  };\n\n  /**\n   * Find an available transport based on the options supplied in the constructor.\n   *\n   * @api private\n   */\n\n  Socket.prototype.getTransport = function (override) {\n    var transports = override || this.transports, match;\n\n    for (var i = 0, transport; transport = transports[i]; i++) {\n      if (io.Transport[transport]\n        && io.Transport[transport].check(this)\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\n        return new io.Transport[transport](this, this.sessionid);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Connects to the server.\n   *\n   * @param {Function} [fn] Callback.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.connect = function (fn) {\n    if (this.connecting) {\n      return this;\n    }\n\n    var self = this;\n    self.connecting = true;\n    \n    this.handshake(function (sid, heartbeat, close, transports) {\n      self.sessionid = sid;\n      self.closeTimeout = close * 1000;\n      self.heartbeatTimeout = heartbeat * 1000;\n      if(!self.transports)\n          self.transports = self.origTransports = (transports ? io.util.intersect(\n              transports.split(',')\n            , self.options.transports\n          ) : self.options.transports);\n\n      self.setHeartbeatTimeout();\n\n      function connect (transports){\n        if (self.transport) self.transport.clearTimeouts();\n\n        self.transport = self.getTransport(transports);\n        if (!self.transport) return self.publish('connect_failed');\n\n        // once the transport is ready\n        self.transport.ready(self, function () {\n          self.connecting = true;\n          self.publish('connecting', self.transport.name);\n          self.transport.open();\n\n          if (self.options['connect timeout']) {\n            self.connectTimeoutTimer = setTimeout(function () {\n              if (!self.connected) {\n                self.connecting = false;\n\n                if (self.options['try multiple transports']) {\n                  var remaining = self.transports;\n\n                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n                         self.transport.name) {}\n\n                    if (remaining.length){\n                      connect(remaining);\n                    } else {\n                      self.publish('connect_failed');\n                    }\n                }\n              }\n            }, self.options['connect timeout']);\n          }\n        });\n      }\n\n      connect(self.transports);\n\n      self.once('connect', function (){\n        clearTimeout(self.connectTimeoutTimer);\n\n        fn && typeof fn == 'function' && fn();\n      });\n    });\n\n    return this;\n  };\n\n  /**\n   * Clears and sets a new heartbeat timeout using the value given by the\n   * server during the handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.setHeartbeatTimeout = function () {\n    clearTimeout(this.heartbeatTimeoutTimer);\n    if(this.transport && !this.transport.heartbeats()) return;\n\n    var self = this;\n    this.heartbeatTimeoutTimer = setTimeout(function () {\n      self.transport.onClose();\n    }, this.heartbeatTimeout);\n  };\n\n  /**\n   * Sends a message.\n   *\n   * @param {Object} data packet.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.packet = function (data) {\n    if (this.connected && !this.doBuffer) {\n      this.transport.packet(data);\n    } else {\n      this.buffer.push(data);\n    }\n\n    return this;\n  };\n\n  /**\n   * Sets buffer state\n   *\n   * @api private\n   */\n\n  Socket.prototype.setBuffer = function (v) {\n    this.doBuffer = v;\n\n    if (!v && this.connected && this.buffer.length) {\n      if (!this.options['manualFlush']) {\n        this.flushBuffer();\n      }\n    }\n  };\n\n  /**\n   * Flushes the buffer data over the wire.\n   * To be invoked manually when 'manualFlush' is set to true.\n   *\n   * @api public\n   */\n\n  Socket.prototype.flushBuffer = function() {\n    this.transport.payload(this.buffer);\n    this.buffer = [];\n  };\n  \n\n  /**\n   * Disconnect the established connect.\n   *\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.disconnect = function () {\n    if (this.connected || this.connecting) {\n      if (this.open) {\n        this.of('').packet({ type: 'disconnect' });\n      }\n\n      // handle disconnection immediately\n      this.onDisconnect('booted');\n    }\n\n    return this;\n  };\n\n  /**\n   * Disconnects the socket with a sync XHR.\n   *\n   * @api private\n   */\n\n  Socket.prototype.disconnectSync = function () {\n    // ensure disconnection\n    var xhr = io.util.request();\n    var uri = [\n        'http' + (this.options.secure ? 's' : '') + ':/'\n      , this.options.host + ':' + this.options.port\n      , this.options.resource\n      , io.protocol\n      , ''\n      , this.sessionid\n    ].join('/') + '/?disconnect=1';\n\n    xhr.open('GET', uri, false);\n    xhr.send(null);\n\n    // handle disconnection immediately\n    this.onDisconnect('booted');\n  };\n\n  /**\n   * Check if we need to use cross domain enabled transports. Cross domain would\n   * be a different port or different domain name.\n   *\n   * @returns {Boolean}\n   * @api private\n   */\n\n  Socket.prototype.isXDomain = function () {\n    // if node\n    return false;\n    // end node\n\n    var port = global.location.port ||\n      ('https:' == global.location.protocol ? 443 : 80);\n\n    return this.options.host !== global.location.hostname \n      || this.options.port != port;\n  };\n\n  /**\n   * Called upon handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onConnect = function () {\n    if (!this.connected) {\n      this.connected = true;\n      this.connecting = false;\n      if (!this.doBuffer) {\n        // make sure to flush the buffer\n        this.setBuffer(false);\n      }\n      this.emit('connect');\n    }\n  };\n\n  /**\n   * Called when the transport opens\n   *\n   * @api private\n   */\n\n  Socket.prototype.onOpen = function () {\n    this.open = true;\n  };\n\n  /**\n   * Called when the transport closes.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onClose = function () {\n    this.open = false;\n    clearTimeout(this.heartbeatTimeoutTimer);\n  };\n\n  /**\n   * Called when the transport first opens a connection\n   *\n   * @param text\n   */\n\n  Socket.prototype.onPacket = function (packet) {\n    this.of(packet.endpoint).onPacket(packet);\n  };\n\n  /**\n   * Handles an error.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onError = function (err) {\n    if (err && err.advice) {\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\n        this.disconnect();\n        if (this.options.reconnect) {\n          this.reconnect();\n        }\n      }\n    }\n\n    this.publish('error', err && err.reason ? err.reason : err);\n  };\n\n  /**\n   * Called when the transport disconnects.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onDisconnect = function (reason) {\n    var wasConnected = this.connected\n      , wasConnecting = this.connecting;\n\n    this.connected = false;\n    this.connecting = false;\n    this.open = false;\n\n    if (wasConnected || wasConnecting) {\n      this.transport.close();\n      this.transport.clearTimeouts();\n      if (wasConnected) {\n        this.publish('disconnect', reason);\n\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n          this.reconnect();\n        }\n      }\n    }\n  };\n\n  /**\n   * Called upon reconnection.\n   *\n   * @api private\n   */\n\n  Socket.prototype.reconnect = function () {\n    this.reconnecting = true;\n    this.reconnectionAttempts = 0;\n    this.reconnectionDelay = this.options['reconnection delay'];\n\n    var self = this\n      , maxAttempts = this.options['max reconnection attempts']\n      , tryMultiple = this.options['try multiple transports']\n      , limit = this.options['reconnection limit'];\n\n    function reset () {\n      if (self.connected) {\n        for (var i in self.namespaces) {\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n              self.namespaces[i].packet({ type: 'connect' });\n          }\n        }\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n      }\n\n      clearTimeout(self.reconnectionTimer);\n\n      self.removeListener('connect_failed', maybeReconnect);\n      self.removeListener('connect', maybeReconnect);\n\n      self.reconnecting = false;\n\n      delete self.reconnectionAttempts;\n      delete self.reconnectionDelay;\n      delete self.reconnectionTimer;\n      delete self.redoTransports;\n\n      self.options['try multiple transports'] = tryMultiple;\n    };\n\n    function maybeReconnect () {\n      if (!self.reconnecting) {\n        return;\n      }\n\n      if (self.connected) {\n        return reset();\n      };\n\n      if (self.connecting && self.reconnecting) {\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n      }\n\n      if (self.reconnectionAttempts++ >= maxAttempts) {\n        if (!self.redoTransports) {\n          self.on('connect_failed', maybeReconnect);\n          self.options['try multiple transports'] = true;\n          self.transports = self.origTransports;\n          self.transport = self.getTransport();\n          self.redoTransports = true;\n          self.connect();\n        } else {\n          self.publish('reconnect_failed');\n          reset();\n        }\n      } else {\n        if (self.reconnectionDelay < limit) {\n          self.reconnectionDelay *= 2; // exponential back off\n        }\n\n        self.connect();\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n      }\n    };\n\n    this.options['try multiple transports'] = false;\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\n    this.on('connect', maybeReconnect);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n"]},"metadata":{},"sourceType":"script"}