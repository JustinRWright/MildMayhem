{"ast":null,"code":"/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\nvar Url = require(\"url\"),\n    spawn = require(\"child_process\").spawn,\n    fs = require('fs');\n\nexports.XMLHttpRequest = function () {\n  /**\n   * Private variables\n   */\n  var self = this;\n\n  var http = require('http');\n\n  var https = require('https'); // Holds http.js objects\n\n\n  var client;\n  var request;\n  var response; // Request settings\n\n  var settings = {}; // Set some default headers\n\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n  var headers = defaultHeaders; // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n\n  var forbiddenRequestHeaders = [\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"content-transfer-encoding\", \"cookie\", \"cookie2\", \"date\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]; // These request methods are not allowed\n\n  var forbiddenRequestMethods = [\"TRACE\", \"TRACK\", \"CONNECT\"]; // Send flag\n\n  var sendFlag = false; // Error flag, used when errors occur or abort is called\n\n  var errorFlag = false; // Event listeners\n\n  var listeners = {};\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n  /**\n   * Public vars\n   */\n  // Current state\n\n  this.readyState = this.UNSENT; // default ready state change handler in case one is not set or is set late\n\n  this.onreadystatechange = null; // Result & response\n\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n  var isAllowedHttpHeader = function (header) {\n    return header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n  };\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n\n  var isAllowedHttpMethod = function (method) {\n    return method && forbiddenRequestMethods.indexOf(method) === -1;\n  };\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n\n\n  this.open = function (method, url, async, user, password) {\n    this.abort();\n    errorFlag = false; // Check for valid request method\n\n    if (!isAllowedHttpMethod(method)) {\n      throw \"SecurityError: Request method not allowed\";\n      return;\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": typeof async !== \"boolean\" ? true : async,\n      \"user\": user || null,\n      \"password\": password || null\n    };\n    setState(this.OPENED);\n  };\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n\n\n  this.setRequestHeader = function (header, value) {\n    if (this.readyState != this.OPENED) {\n      throw \"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\";\n    }\n\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return;\n    }\n\n    if (sendFlag) {\n      throw \"INVALID_STATE_ERR: send flag is true\";\n    }\n\n    headers[header] = value;\n  };\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n\n\n  this.getResponseHeader = function (header) {\n    if (typeof header === \"string\" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n\n\n  this.getAllResponseHeaders = function () {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n\n    return result.substr(0, result.length - 2);\n  };\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n\n\n  this.getRequestHeader = function (name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  };\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n\n\n  this.send = function (data) {\n    if (this.readyState != this.OPENED) {\n      throw \"INVALID_STATE_ERR: connection must be opened before send() is called\";\n    }\n\n    if (sendFlag) {\n      throw \"INVALID_STATE_ERR: send has already been called\";\n    }\n\n    var ssl = false,\n        local = false;\n    var url = Url.parse(settings.url); // Determine the server\n\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true;\n      // SSL & non-SSL both need host, no break here.\n\n      case 'http:':\n        var host = url.hostname;\n        break;\n\n      case 'file:':\n        local = true;\n        break;\n\n      case undefined:\n      case '':\n        var host = \"localhost\";\n        break;\n\n      default:\n        throw \"Protocol not supported.\";\n    } // Load files off the local filesystem (file://)\n\n\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw \"XMLHttpRequest: Only GET method is supported\";\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, 'utf8', function (error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, 'utf8');\n          this.status = 200;\n          setState(self.DONE);\n        } catch (e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    } // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n\n\n    var port = url.port || (ssl ? 443 : 80); // Add query string if one is used\n\n    var uri = url.pathname + (url.search ? url.search : ''); // Set the Host header or the server may reject the request\n\n    headers[\"Host\"] = host;\n\n    if (!(ssl && port === 443 || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    } // Set Basic Auth if necessary\n\n\n    if (settings.user) {\n      if (typeof settings.password == \"undefined\") {\n        settings.password = \"\";\n      }\n\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    } // Set content length header\n\n\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers\n    }; // Reset error flag\n\n    errorFlag = false; // Handle async requests\n\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request; // Request is being sent, set send flag\n\n      sendFlag = true; // As per spec, this is called here for historical reasons.\n\n      self.dispatchEvent(\"readystatechange\"); // Create the request\n\n      request = doRequest(options, function (resp) {\n        response = resp;\n        response.setEncoding(\"utf8\");\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n        response.on('data', function (chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          } // Don't emit state changes if the connection has been aborted.\n\n\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n        response.on('end', function () {\n          if (sendFlag) {\n            // Discard the 'end' event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n        response.on('error', function (error) {\n          self.handleError(error);\n        });\n      }).on('error', function (error) {\n        self.handleError(error);\n      }); // Node 0.4 and later won't accept empty data. Make sure it's needed.\n\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n      self.dispatchEvent(\"loadstart\");\n    } else {\n      // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\"); // The async request the other Node process executes\n\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + syncFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + syncFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + syncFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"});\" + (data ? \"req.write('\" + data.replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\"; // Start the other Node Process, executing this string\n\n      syncProc = spawn(process.argv[0], [\"-e\", execString]);\n\n      while ((self.responseText = fs.readFileSync(syncFile, 'utf8')) == \"\") {// Wait while the file is empty\n      } // Kill the child process once the file has data\n\n\n      syncProc.stdin.end(); // Remove the temporary file\n\n      fs.unlinkSync(syncFile);\n\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n        // If the file returned an error, handle it\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n        self.handleError(errorObj);\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n        setState(self.DONE);\n      }\n    }\n  };\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n\n\n  this.handleError = function (error) {\n    this.status = 503;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n  };\n  /**\n   * Aborts a request.\n   */\n\n\n  this.abort = function () {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = defaultHeaders;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n\n    this.readyState = this.UNSENT;\n  };\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n\n\n  this.addEventListener = function (event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    } // Currently allows duplicate callbacks. Should it?\n\n\n    listeners[event].push(callback);\n  };\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n\n\n  this.removeEventListener = function (event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function (ev) {\n        return ev !== callback;\n      });\n    }\n  };\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n\n\n  this.dispatchEvent = function (event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n\n\n  var setState = function (state) {\n    if (self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\"); // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/xmlhttprequest/lib/XMLHttpRequest.js"],"names":["Url","require","spawn","fs","exports","XMLHttpRequest","self","http","https","client","request","response","settings","defaultHeaders","headers","forbiddenRequestHeaders","forbiddenRequestMethods","sendFlag","errorFlag","listeners","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","readyState","onreadystatechange","responseText","responseXML","status","statusText","isAllowedHttpHeader","header","indexOf","toLowerCase","isAllowedHttpMethod","method","open","url","async","user","password","abort","toString","setState","setRequestHeader","value","console","warn","getResponseHeader","getAllResponseHeaders","result","i","substr","length","getRequestHeader","name","send","data","ssl","local","parse","protocol","host","hostname","undefined","readFile","pathname","error","handleError","readFileSync","e","port","uri","search","authBuf","Buffer","byteLength","options","path","doRequest","dispatchEvent","resp","setEncoding","statusCode","on","chunk","write","end","syncFile","process","pid","writeFileSync","execString","JSON","stringify","replace","syncProc","argv","stdin","unlinkSync","match","errorObj","stack","addEventListener","event","callback","push","removeEventListener","filter","ev","len","call","state"],"mappings":"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","sourcesContent":["/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar Url = require(\"url\")\n  , spawn = require(\"child_process\").spawn\n  , fs = require('fs');\n\nexports.XMLHttpRequest = function() {\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = require('http');\n  var https = require('https');\n\n  // Holds http.js objects\n  var client;\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\",\n  };\n\n  var headers = defaultHeaders;\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw \"SecurityError: Request method not allowed\";\n      return;\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState != this.OPENED) {\n      throw \"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\";\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return;\n    }\n    if (sendFlag) {\n      throw \"INVALID_STATE_ERR: send flag is true\";\n    }\n    headers[header] = value;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState != this.OPENED) {\n      throw \"INVALID_STATE_ERR: connection must be opened before send() is called\";\n    }\n\n    if (sendFlag) {\n      throw \"INVALID_STATE_ERR: send has already been called\";\n    }\n\n    var ssl = false, local = false;\n    var url = Url.parse(settings.url);\n\n    // Determine the server\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true;\n        // SSL & non-SSL both need host, no break here.\n      case 'http:':\n        var host = url.hostname;\n        break;\n\n      case 'file:':\n        local = true;\n        break;\n\n      case undefined:\n      case '':\n        var host = \"localhost\";\n        break;\n\n      default:\n        throw \"Protocol not supported.\";\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw \"XMLHttpRequest: Only GET method is supported\";\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, 'utf8', function(error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, 'utf8');\n          this.status = 200;\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : '');\n\n    // Set the Host header or the server may reject the request\n    headers[\"Host\"] = host;\n    if (!((ssl && port === 443) || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password == \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers\n    };\n\n    // Reset error flag\n    errorFlag = false;\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Create the request\n      request = doRequest(options, function(resp) {\n        response = resp;\n        response.setEncoding(\"utf8\");\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n\n        response.on('data', function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n\n        response.on('end', function() {\n          if (sendFlag) {\n            // Discard the 'end' event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n\n        response.on('error', function(error) {\n          self.handleError(error);\n        });\n      }).on('error', function(error) {\n        self.handleError(error);\n      });\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var responseText = '';\"\n        + \"var req = doRequest(options, function(response) {\"\n        + \"response.setEncoding('utf8');\"\n        + \"response.on('data', function(chunk) {\"\n        + \"responseText += chunk;\"\n        + \"});\"\n        + \"response.on('end', function() {\"\n        + \"fs.writeFileSync('\" + syncFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\"\n        + \"});\"\n        + \"response.on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + syncFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"});\"\n        + \"}).on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + syncFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"});\"\n        + (data ? \"req.write('\" + data.replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"req.end();\";\n      // Start the other Node Process, executing this string\n      syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      while((self.responseText = fs.readFileSync(syncFile, 'utf8')) == \"\") {\n        // Wait while the file is empty\n      }\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(syncFile);\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n        // If the file returned an error, handle it\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n        self.handleError(errorObj);\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function(error) {\n    this.status = 503;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = defaultHeaders;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function(event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if (self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\");\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}