{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n\n  This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n\n  This file implements some AST processors.  They work on data built\n  by parse-js.\n\n  Exported functions:\n\n    - ast_mangle(ast, options) -- mangles the variable/function names\n      in the AST.  Returns an AST.\n\n    - ast_squeeze(ast) -- employs various optimizations to make the\n      final generated code even smaller.  Returns an AST.\n\n    - gen_code(ast, options) -- generates JS code from the AST.  Pass\n      true (or an object, see the code for some options) as second\n      argument to get \"pretty\" (indented) code.\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nvar jsp = require(\"./parse-js\"),\n    slice = jsp.slice,\n    member = jsp.member,\n    PRECEDENCE = jsp.PRECEDENCE,\n    OPERATORS = jsp.OPERATORS;\n/* -----[ helper for AST traversal ]----- */\n\n\nfunction ast_walker() {\n  function _vardefs(defs) {\n    return [this[0], MAP(defs, function (def) {\n      var a = [def[0]];\n      if (def.length > 1) a[1] = walk(def[1]);\n      return a;\n    })];\n  }\n\n  ;\n\n  function _block(statements) {\n    var out = [this[0]];\n    if (statements != null) out.push(MAP(statements, walk));\n    return out;\n  }\n\n  ;\n  var walkers = {\n    \"string\": function (str) {\n      return [this[0], str];\n    },\n    \"num\": function (num) {\n      return [this[0], num];\n    },\n    \"name\": function (name) {\n      return [this[0], name];\n    },\n    \"toplevel\": function (statements) {\n      return [this[0], MAP(statements, walk)];\n    },\n    \"block\": _block,\n    \"splice\": _block,\n    \"var\": _vardefs,\n    \"const\": _vardefs,\n    \"try\": function (t, c, f) {\n      return [this[0], MAP(t, walk), c != null ? [c[0], MAP(c[1], walk)] : null, f != null ? MAP(f, walk) : null];\n    },\n    \"throw\": function (expr) {\n      return [this[0], walk(expr)];\n    },\n    \"new\": function (ctor, args) {\n      return [this[0], walk(ctor), MAP(args, walk)];\n    },\n    \"switch\": function (expr, body) {\n      return [this[0], walk(expr), MAP(body, function (branch) {\n        return [branch[0] ? walk(branch[0]) : null, MAP(branch[1], walk)];\n      })];\n    },\n    \"break\": function (label) {\n      return [this[0], label];\n    },\n    \"continue\": function (label) {\n      return [this[0], label];\n    },\n    \"conditional\": function (cond, t, e) {\n      return [this[0], walk(cond), walk(t), walk(e)];\n    },\n    \"assign\": function (op, lvalue, rvalue) {\n      return [this[0], op, walk(lvalue), walk(rvalue)];\n    },\n    \"dot\": function (expr) {\n      return [this[0], walk(expr)].concat(slice(arguments, 1));\n    },\n    \"call\": function (expr, args) {\n      return [this[0], walk(expr), MAP(args, walk)];\n    },\n    \"function\": function (name, args, body) {\n      return [this[0], name, args.slice(), MAP(body, walk)];\n    },\n    \"debugger\": function () {\n      return [this[0]];\n    },\n    \"defun\": function (name, args, body) {\n      return [this[0], name, args.slice(), MAP(body, walk)];\n    },\n    \"if\": function (conditional, t, e) {\n      return [this[0], walk(conditional), walk(t), walk(e)];\n    },\n    \"for\": function (init, cond, step, block) {\n      return [this[0], walk(init), walk(cond), walk(step), walk(block)];\n    },\n    \"for-in\": function (vvar, key, hash, block) {\n      return [this[0], walk(vvar), walk(key), walk(hash), walk(block)];\n    },\n    \"while\": function (cond, block) {\n      return [this[0], walk(cond), walk(block)];\n    },\n    \"do\": function (cond, block) {\n      return [this[0], walk(cond), walk(block)];\n    },\n    \"return\": function (expr) {\n      return [this[0], walk(expr)];\n    },\n    \"binary\": function (op, left, right) {\n      return [this[0], op, walk(left), walk(right)];\n    },\n    \"unary-prefix\": function (op, expr) {\n      return [this[0], op, walk(expr)];\n    },\n    \"unary-postfix\": function (op, expr) {\n      return [this[0], op, walk(expr)];\n    },\n    \"sub\": function (expr, subscript) {\n      return [this[0], walk(expr), walk(subscript)];\n    },\n    \"object\": function (props) {\n      return [this[0], MAP(props, function (p) {\n        return p.length == 2 ? [p[0], walk(p[1])] : [p[0], walk(p[1]), p[2]]; // get/set-ter\n      })];\n    },\n    \"regexp\": function (rx, mods) {\n      return [this[0], rx, mods];\n    },\n    \"array\": function (elements) {\n      return [this[0], MAP(elements, walk)];\n    },\n    \"stat\": function (stat) {\n      return [this[0], walk(stat)];\n    },\n    \"seq\": function () {\n      return [this[0]].concat(MAP(slice(arguments), walk));\n    },\n    \"label\": function (name, block) {\n      return [this[0], name, walk(block)];\n    },\n    \"with\": function (expr, block) {\n      return [this[0], walk(expr), walk(block)];\n    },\n    \"atom\": function (name) {\n      return [this[0], name];\n    }\n  };\n  var user = {};\n  var stack = [];\n\n  function walk(ast) {\n    if (ast == null) return null;\n\n    try {\n      stack.push(ast);\n      var type = ast[0];\n      var gen = user[type];\n\n      if (gen) {\n        var ret = gen.apply(ast, ast.slice(1));\n        if (ret != null) return ret;\n      }\n\n      gen = walkers[type];\n      return gen.apply(ast, ast.slice(1));\n    } finally {\n      stack.pop();\n    }\n  }\n\n  ;\n\n  function dive(ast) {\n    if (ast == null) return null;\n\n    try {\n      stack.push(ast);\n      return walkers[ast[0]].apply(ast, ast.slice(1));\n    } finally {\n      stack.pop();\n    }\n  }\n\n  ;\n\n  function with_walkers(walkers, cont) {\n    var save = {},\n        i;\n\n    for (i in walkers) if (HOP(walkers, i)) {\n      save[i] = user[i];\n      user[i] = walkers[i];\n    }\n\n    var ret = cont();\n\n    for (i in save) if (HOP(save, i)) {\n      if (!save[i]) delete user[i];else user[i] = save[i];\n    }\n\n    return ret;\n  }\n\n  ;\n  return {\n    walk: walk,\n    dive: dive,\n    with_walkers: with_walkers,\n    parent: function () {\n      return stack[stack.length - 2]; // last one is current node\n    },\n    stack: function () {\n      return stack;\n    }\n  };\n}\n\n;\n/* -----[ Scope and mangling ]----- */\n\nfunction Scope(parent) {\n  this.names = {}; // names defined in this scope\n\n  this.mangled = {}; // mangled names (orig.name => mangled)\n\n  this.rev_mangled = {}; // reverse lookup (mangled => orig.name)\n\n  this.cname = -1; // current mangled name\n\n  this.refs = {}; // names referenced from this scope\n\n  this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes\n\n  this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes\n\n  this.parent = parent; // parent scope\n\n  this.children = []; // sub-scopes\n\n  if (parent) {\n    this.level = parent.level + 1;\n    parent.children.push(this);\n  } else {\n    this.level = 0;\n  }\n}\n\n;\n\nvar base54 = function () {\n  var DIGITS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\";\n  return function (num) {\n    var ret = \"\";\n\n    do {\n      ret = DIGITS.charAt(num % 54) + ret;\n      num = Math.floor(num / 54);\n    } while (num > 0);\n\n    return ret;\n  };\n}();\n\nScope.prototype = {\n  has: function (name) {\n    for (var s = this; s; s = s.parent) if (HOP(s.names, name)) return s;\n  },\n  has_mangled: function (mname) {\n    for (var s = this; s; s = s.parent) if (HOP(s.rev_mangled, mname)) return s;\n  },\n  toJSON: function () {\n    return {\n      names: this.names,\n      uses_eval: this.uses_eval,\n      uses_with: this.uses_with\n    };\n  },\n  next_mangled: function () {\n    // we must be careful that the new mangled name:\n    //\n    // 1. doesn't shadow a mangled name from a parent\n    //    scope, unless we don't reference the original\n    //    name from this scope OR from any sub-scopes!\n    //    This will get slow.\n    //\n    // 2. doesn't shadow an original name from a parent\n    //    scope, in the event that the name is not mangled\n    //    in the parent scope and we reference that name\n    //    here OR IN ANY SUBSCOPES!\n    //\n    // 3. doesn't shadow a name that is referenced but not\n    //    defined (possibly global defined elsewhere).\n    for (;;) {\n      var m = base54(++this.cname),\n          prior; // case 1.\n\n      prior = this.has_mangled(m);\n      if (prior && this.refs[prior.rev_mangled[m]] === prior) continue; // case 2.\n\n      prior = this.has(m);\n      if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m)) continue; // case 3.\n\n      if (HOP(this.refs, m) && this.refs[m] == null) continue; // I got \"do\" once. :-/\n\n      if (!is_identifier(m)) continue;\n      return m;\n    }\n  },\n  set_mangle: function (name, m) {\n    this.rev_mangled[m] = name;\n    return this.mangled[name] = m;\n  },\n  get_mangled: function (name, newMangle) {\n    if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use\n\n    var s = this.has(name);\n    if (!s) return name; // not in visible scope, no mangle\n\n    if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope\n\n    if (!newMangle) return name; // not found and no mangling requested\n\n    return s.set_mangle(name, s.next_mangled());\n  },\n  references: function (name) {\n    return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];\n  },\n  define: function (name, type) {\n    if (name != null) {\n      if (type == \"var\" || !HOP(this.names, name)) this.names[name] = type || \"var\";\n      return name;\n    }\n  }\n};\n\nfunction ast_add_scope(ast) {\n  var current_scope = null;\n  var w = ast_walker(),\n      walk = w.walk;\n  var having_eval = [];\n\n  function with_new_scope(cont) {\n    current_scope = new Scope(current_scope);\n    current_scope.labels = new Scope();\n    var ret = current_scope.body = cont();\n    ret.scope = current_scope;\n    current_scope = current_scope.parent;\n    return ret;\n  }\n\n  ;\n\n  function define(name, type) {\n    return current_scope.define(name, type);\n  }\n\n  ;\n\n  function reference(name) {\n    current_scope.refs[name] = true;\n  }\n\n  ;\n\n  function _lambda(name, args, body) {\n    var is_defun = this[0] == \"defun\";\n    return [this[0], is_defun ? define(name, \"defun\") : name, args, with_new_scope(function () {\n      if (!is_defun) define(name, \"lambda\");\n      MAP(args, function (name) {\n        define(name, \"arg\");\n      });\n      return MAP(body, walk);\n    })];\n  }\n\n  ;\n\n  function _vardefs(type) {\n    return function (defs) {\n      MAP(defs, function (d) {\n        define(d[0], type);\n        if (d[1]) reference(d[0]);\n      });\n    };\n  }\n\n  ;\n\n  function _breacont(label) {\n    if (label) current_scope.labels.refs[label] = true;\n  }\n\n  ;\n  return with_new_scope(function () {\n    // process AST\n    var ret = w.with_walkers({\n      \"function\": _lambda,\n      \"defun\": _lambda,\n      \"label\": function (name, stat) {\n        current_scope.labels.define(name);\n      },\n      \"break\": _breacont,\n      \"continue\": _breacont,\n      \"with\": function (expr, block) {\n        for (var s = current_scope; s; s = s.parent) s.uses_with = true;\n      },\n      \"var\": _vardefs(\"var\"),\n      \"const\": _vardefs(\"const\"),\n      \"try\": function (t, c, f) {\n        if (c != null) return [this[0], MAP(t, walk), [define(c[0], \"catch\"), MAP(c[1], walk)], f != null ? MAP(f, walk) : null];\n      },\n      \"name\": function (name) {\n        if (name == \"eval\") having_eval.push(current_scope);\n        reference(name);\n      }\n    }, function () {\n      return walk(ast);\n    }); // the reason why we need an additional pass here is\n    // that names can be used prior to their definition.\n    // scopes where eval was detected and their parents\n    // are marked with uses_eval, unless they define the\n    // \"eval\" name.\n\n    MAP(having_eval, function (scope) {\n      if (!scope.has(\"eval\")) while (scope) {\n        scope.uses_eval = true;\n        scope = scope.parent;\n      }\n    }); // for referenced names it might be useful to know\n    // their origin scope.  current_scope here is the\n    // toplevel one.\n\n    function fixrefs(scope, i) {\n      // do children first; order shouldn't matter\n      for (i = scope.children.length; --i >= 0;) fixrefs(scope.children[i]);\n\n      for (i in scope.refs) if (HOP(scope.refs, i)) {\n        // find origin scope and propagate the reference to origin\n        for (var origin = scope.has(i), s = scope; s; s = s.parent) {\n          s.refs[i] = origin;\n          if (s === origin) break;\n        }\n      }\n    }\n\n    ;\n    fixrefs(current_scope);\n    return ret;\n  });\n}\n\n;\n/* -----[ mangle names ]----- */\n\nfunction ast_mangle(ast, options) {\n  var w = ast_walker(),\n      walk = w.walk,\n      scope;\n  options = options || {};\n\n  function get_mangled(name, newMangle) {\n    if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel\n\n    if (options.except && member(name, options.except)) return name;\n    return scope.get_mangled(name, newMangle);\n  }\n\n  ;\n\n  function get_define(name) {\n    if (options.defines) {\n      // we always lookup a defined symbol for the current scope FIRST, so declared\n      // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value\n      if (!scope.has(name)) {\n        if (HOP(options.defines, name)) {\n          return options.defines[name];\n        }\n      }\n\n      return null;\n    }\n  }\n\n  ;\n\n  function _lambda(name, args, body) {\n    if (!options.no_functions) {\n      var is_defun = this[0] == \"defun\",\n          extra;\n\n      if (name) {\n        if (is_defun) name = get_mangled(name);else if (body.scope.references(name)) {\n          extra = {};\n          if (!(scope.uses_eval || scope.uses_with)) name = extra[name] = scope.next_mangled();else extra[name] = name;\n        } else name = null;\n      }\n    }\n\n    body = with_scope(body.scope, function () {\n      args = MAP(args, function (name) {\n        return get_mangled(name);\n      });\n      return MAP(body, walk);\n    }, extra);\n    return [this[0], name, args, body];\n  }\n\n  ;\n\n  function with_scope(s, cont, extra) {\n    var _scope = scope;\n    scope = s;\n    if (extra) for (var i in extra) if (HOP(extra, i)) {\n      s.set_mangle(i, extra[i]);\n    }\n\n    for (var i in s.names) if (HOP(s.names, i)) {\n      get_mangled(i, true);\n    }\n\n    var ret = cont();\n    ret.scope = s;\n    scope = _scope;\n    return ret;\n  }\n\n  ;\n\n  function _vardefs(defs) {\n    return [this[0], MAP(defs, function (d) {\n      return [get_mangled(d[0]), walk(d[1])];\n    })];\n  }\n\n  ;\n\n  function _breacont(label) {\n    if (label) return [this[0], scope.labels.get_mangled(label)];\n  }\n\n  ;\n  return w.with_walkers({\n    \"function\": _lambda,\n    \"defun\": function () {\n      // move function declarations to the top when\n      // they are not in some block.\n      var ast = _lambda.apply(this, arguments);\n\n      switch (w.parent()[0]) {\n        case \"toplevel\":\n        case \"function\":\n        case \"defun\":\n          return MAP.at_top(ast);\n      }\n\n      return ast;\n    },\n    \"label\": function (label, stat) {\n      if (scope.labels.refs[label]) return [this[0], scope.labels.get_mangled(label, true), walk(stat)];\n      return walk(stat);\n    },\n    \"break\": _breacont,\n    \"continue\": _breacont,\n    \"var\": _vardefs,\n    \"const\": _vardefs,\n    \"name\": function (name) {\n      return get_define(name) || [this[0], get_mangled(name)];\n    },\n    \"try\": function (t, c, f) {\n      return [this[0], MAP(t, walk), c != null ? [get_mangled(c[0]), MAP(c[1], walk)] : null, f != null ? MAP(f, walk) : null];\n    },\n    \"toplevel\": function (body) {\n      var self = this;\n      return with_scope(self.scope, function () {\n        return [self[0], MAP(body, walk)];\n      });\n    }\n  }, function () {\n    return walk(ast_add_scope(ast));\n  });\n}\n\n;\n/* -----[\n   - compress foo[\"bar\"] into foo.bar,\n   - remove block brackets {} where possible\n   - join consecutive var declarations\n   - various optimizations for IFs:\n     - if (cond) foo(); else bar();  ==>  cond?foo():bar();\n     - if (cond) foo();  ==>  cond&&foo();\n     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw\n     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}\n   ]----- */\n\nvar warn = function () {};\n\nfunction best_of(ast1, ast2) {\n  return gen_code(ast1).length > gen_code(ast2[0] == \"stat\" ? ast2[1] : ast2).length ? ast2 : ast1;\n}\n\n;\n\nfunction last_stat(b) {\n  if (b[0] == \"block\" && b[1] && b[1].length > 0) return b[1][b[1].length - 1];\n  return b;\n}\n\nfunction aborts(t) {\n  if (t) switch (last_stat(t)[0]) {\n    case \"return\":\n    case \"break\":\n    case \"continue\":\n    case \"throw\":\n      return true;\n  }\n}\n\n;\n\nfunction boolean_expr(expr) {\n  return expr[0] == \"unary-prefix\" && member(expr[1], [\"!\", \"delete\"]) || expr[0] == \"binary\" && member(expr[1], [\"in\", \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"<\", \"<=\", \">=\", \">\"]) || expr[0] == \"binary\" && member(expr[1], [\"&&\", \"||\"]) && boolean_expr(expr[2]) && boolean_expr(expr[3]) || expr[0] == \"conditional\" && boolean_expr(expr[2]) && boolean_expr(expr[3]) || expr[0] == \"assign\" && expr[1] === true && boolean_expr(expr[3]) || expr[0] == \"seq\" && boolean_expr(expr[expr.length - 1]);\n}\n\n;\n\nfunction empty(b) {\n  return !b || b[0] == \"block\" && (!b[1] || b[1].length == 0);\n}\n\n;\n\nfunction is_string(node) {\n  return node[0] == \"string\" || node[0] == \"unary-prefix\" && node[1] == \"typeof\" || node[0] == \"binary\" && node[1] == \"+\" && (is_string(node[2]) || is_string(node[3]));\n}\n\n;\n\nvar when_constant = function () {\n  var $NOT_CONSTANT = {}; // this can only evaluate constant expressions.  If it finds anything\n  // not constant, it throws $NOT_CONSTANT.\n\n  function evaluate(expr) {\n    switch (expr[0]) {\n      case \"string\":\n      case \"num\":\n        return expr[1];\n\n      case \"name\":\n      case \"atom\":\n        switch (expr[1]) {\n          case \"true\":\n            return true;\n\n          case \"false\":\n            return false;\n\n          case \"null\":\n            return null;\n        }\n\n        break;\n\n      case \"unary-prefix\":\n        switch (expr[1]) {\n          case \"!\":\n            return !evaluate(expr[2]);\n\n          case \"typeof\":\n            return typeof evaluate(expr[2]);\n\n          case \"~\":\n            return ~evaluate(expr[2]);\n\n          case \"-\":\n            return -evaluate(expr[2]);\n\n          case \"+\":\n            return +evaluate(expr[2]);\n        }\n\n        break;\n\n      case \"binary\":\n        var left = expr[2],\n            right = expr[3];\n\n        switch (expr[1]) {\n          case \"&&\":\n            return evaluate(left) && evaluate(right);\n\n          case \"||\":\n            return evaluate(left) || evaluate(right);\n\n          case \"|\":\n            return evaluate(left) | evaluate(right);\n\n          case \"&\":\n            return evaluate(left) & evaluate(right);\n\n          case \"^\":\n            return evaluate(left) ^ evaluate(right);\n\n          case \"+\":\n            return evaluate(left) + evaluate(right);\n\n          case \"*\":\n            return evaluate(left) * evaluate(right);\n\n          case \"/\":\n            return evaluate(left) / evaluate(right);\n\n          case \"%\":\n            return evaluate(left) % evaluate(right);\n\n          case \"-\":\n            return evaluate(left) - evaluate(right);\n\n          case \"<<\":\n            return evaluate(left) << evaluate(right);\n\n          case \">>\":\n            return evaluate(left) >> evaluate(right);\n\n          case \">>>\":\n            return evaluate(left) >>> evaluate(right);\n\n          case \"==\":\n            return evaluate(left) == evaluate(right);\n\n          case \"===\":\n            return evaluate(left) === evaluate(right);\n\n          case \"!=\":\n            return evaluate(left) != evaluate(right);\n\n          case \"!==\":\n            return evaluate(left) !== evaluate(right);\n\n          case \"<\":\n            return evaluate(left) < evaluate(right);\n\n          case \"<=\":\n            return evaluate(left) <= evaluate(right);\n\n          case \">\":\n            return evaluate(left) > evaluate(right);\n\n          case \">=\":\n            return evaluate(left) >= evaluate(right);\n\n          case \"in\":\n            return evaluate(left) in evaluate(right);\n\n          case \"instanceof\":\n            return evaluate(left) instanceof evaluate(right);\n        }\n\n    }\n\n    throw $NOT_CONSTANT;\n  }\n\n  ;\n  return function (expr, yes, no) {\n    try {\n      var val = evaluate(expr),\n          ast;\n\n      switch (typeof val) {\n        case \"string\":\n          ast = [\"string\", val];\n          break;\n\n        case \"number\":\n          ast = [\"num\", val];\n          break;\n\n        case \"boolean\":\n          ast = [\"name\", String(val)];\n          break;\n\n        default:\n          if (val === null) {\n            ast = [\"atom\", \"null\"];\n            break;\n          }\n\n          throw new Error(\"Can't handle constant of type: \" + typeof val);\n      }\n\n      return yes.call(expr, ast, val);\n    } catch (ex) {\n      if (ex === $NOT_CONSTANT) {\n        if (expr[0] == \"binary\" && (expr[1] == \"===\" || expr[1] == \"!==\") && (is_string(expr[2]) && is_string(expr[3]) || boolean_expr(expr[2]) && boolean_expr(expr[3]))) {\n          expr[1] = expr[1].substr(0, 2);\n        } else if (no && expr[0] == \"binary\" && (expr[1] == \"||\" || expr[1] == \"&&\")) {\n          // the whole expression is not constant but the lval may be...\n          try {\n            var lval = evaluate(expr[2]);\n            expr = expr[1] == \"&&\" && (lval ? expr[3] : lval) || expr[1] == \"||\" && (lval ? lval : expr[3]) || expr;\n          } catch (ex2) {// IGNORE... lval is not constant\n          }\n        }\n\n        return no ? no.call(expr, expr) : null;\n      } else throw ex;\n    }\n  };\n}();\n\nfunction warn_unreachable(ast) {\n  if (!empty(ast)) warn(\"Dropping unreachable code: \" + gen_code(ast, true));\n}\n\n;\n\nfunction prepare_ifs(ast) {\n  var w = ast_walker(),\n      walk = w.walk; // In this first pass, we rewrite ifs which abort with no else with an\n  // if-else.  For example:\n  //\n  // if (x) {\n  //     blah();\n  //     return y;\n  // }\n  // foobar();\n  //\n  // is rewritten into:\n  //\n  // if (x) {\n  //     blah();\n  //     return y;\n  // } else {\n  //     foobar();\n  // }\n\n  function redo_if(statements) {\n    statements = MAP(statements, walk);\n\n    for (var i = 0; i < statements.length; ++i) {\n      var fi = statements[i];\n      if (fi[0] != \"if\") continue;\n      if (fi[3] && walk(fi[3])) continue;\n      var t = walk(fi[2]);\n      if (!aborts(t)) continue;\n      var conditional = walk(fi[1]);\n      var e_body = redo_if(statements.slice(i + 1));\n      var e = e_body.length == 1 ? e_body[0] : [\"block\", e_body];\n      return statements.slice(0, i).concat([[fi[0], // \"if\"\n      conditional, // conditional\n      t, // then\n      e // else\n      ]]);\n    }\n\n    return statements;\n  }\n\n  ;\n\n  function redo_if_lambda(name, args, body) {\n    body = redo_if(body);\n    return [this[0], name, args, body];\n  }\n\n  ;\n\n  function redo_if_block(statements) {\n    return [this[0], statements != null ? redo_if(statements) : null];\n  }\n\n  ;\n  return w.with_walkers({\n    \"defun\": redo_if_lambda,\n    \"function\": redo_if_lambda,\n    \"block\": redo_if_block,\n    \"splice\": redo_if_block,\n    \"toplevel\": function (statements) {\n      return [this[0], redo_if(statements)];\n    },\n    \"try\": function (t, c, f) {\n      return [this[0], redo_if(t), c != null ? [c[0], redo_if(c[1])] : null, f != null ? redo_if(f) : null];\n    }\n  }, function () {\n    return walk(ast);\n  });\n}\n\n;\n\nfunction for_side_effects(ast, handler) {\n  var w = ast_walker(),\n      walk = w.walk;\n  var $stop = {},\n      $restart = {};\n\n  function stop() {\n    throw $stop;\n  }\n\n  ;\n\n  function restart() {\n    throw $restart;\n  }\n\n  ;\n\n  function found() {\n    return handler.call(this, this, w, stop, restart);\n  }\n\n  ;\n\n  function unary(op) {\n    if (op == \"++\" || op == \"--\") return found.apply(this, arguments);\n  }\n\n  ;\n  return w.with_walkers({\n    \"try\": found,\n    \"throw\": found,\n    \"return\": found,\n    \"new\": found,\n    \"switch\": found,\n    \"break\": found,\n    \"continue\": found,\n    \"assign\": found,\n    \"call\": found,\n    \"if\": found,\n    \"for\": found,\n    \"for-in\": found,\n    \"while\": found,\n    \"do\": found,\n    \"return\": found,\n    \"unary-prefix\": unary,\n    \"unary-postfix\": unary,\n    \"defun\": found\n  }, function () {\n    while (true) try {\n      walk(ast);\n      break;\n    } catch (ex) {\n      if (ex === $stop) break;\n      if (ex === $restart) continue;\n      throw ex;\n    }\n  });\n}\n\n;\n\nfunction ast_lift_variables(ast) {\n  var w = ast_walker(),\n      walk = w.walk,\n      scope;\n\n  function do_body(body, env) {\n    var _scope = scope;\n    scope = env;\n    body = MAP(body, walk);\n    var hash = {},\n        names = MAP(env.names, function (type, name) {\n      if (type != \"var\") return MAP.skip;\n      if (!env.references(name)) return MAP.skip;\n      hash[name] = true;\n      return [name];\n    });\n\n    if (names.length > 0) {\n      // looking for assignments to any of these variables.\n      // we can save considerable space by moving the definitions\n      // in the var declaration.\n      for_side_effects([\"block\", body], function (ast, walker, stop, restart) {\n        if (ast[0] == \"assign\" && ast[1] === true && ast[2][0] == \"name\" && HOP(hash, ast[2][1])) {\n          // insert the definition into the var declaration\n          for (var i = names.length; --i >= 0;) {\n            if (names[i][0] == ast[2][1]) {\n              if (names[i][1]) // this name already defined, we must stop\n                stop();\n              names[i][1] = ast[3]; // definition\n\n              names.push(names.splice(i, 1)[0]);\n              break;\n            }\n          } // remove this assignment from the AST.\n\n\n          var p = walker.parent();\n\n          if (p[0] == \"seq\") {\n            var a = p[2];\n            a.unshift(0, p.length);\n            p.splice.apply(p, a);\n          } else if (p[0] == \"stat\") {\n            p.splice(0, p.length, \"block\"); // empty statement\n          } else {\n            stop();\n          }\n\n          restart();\n        }\n\n        stop();\n      });\n      body.unshift([\"var\", names]);\n    }\n\n    scope = _scope;\n    return body;\n  }\n\n  ;\n\n  function _vardefs(defs) {\n    var ret = null;\n\n    for (var i = defs.length; --i >= 0;) {\n      var d = defs[i];\n      if (!d[1]) continue;\n      d = [\"assign\", true, [\"name\", d[0]], d[1]];\n      if (ret == null) ret = d;else ret = [\"seq\", d, ret];\n    }\n\n    if (ret == null) {\n      if (w.parent()[0] == \"for-in\") return [\"name\", defs[0][0]];\n      return MAP.skip;\n    }\n\n    return [\"stat\", ret];\n  }\n\n  ;\n\n  function _toplevel(body) {\n    return [this[0], do_body(body, this.scope)];\n  }\n\n  ;\n  return w.with_walkers({\n    \"function\": function (name, args, body) {\n      for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);) args.pop();\n\n      if (!body.scope.references(name)) name = null;\n      return [this[0], name, args, do_body(body, body.scope)];\n    },\n    \"defun\": function (name, args, body) {\n      if (!scope.references(name)) return MAP.skip;\n\n      for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);) args.pop();\n\n      return [this[0], name, args, do_body(body, body.scope)];\n    },\n    \"var\": _vardefs,\n    \"toplevel\": _toplevel\n  }, function () {\n    return walk(ast_add_scope(ast));\n  });\n}\n\n;\n\nfunction ast_squeeze(ast, options) {\n  options = defaults(options, {\n    make_seqs: true,\n    dead_code: true,\n    no_warnings: false,\n    keep_comps: true\n  });\n  var w = ast_walker(),\n      walk = w.walk;\n\n  function negate(c) {\n    var not_c = [\"unary-prefix\", \"!\", c];\n\n    switch (c[0]) {\n      case \"unary-prefix\":\n        return c[1] == \"!\" && boolean_expr(c[2]) ? c[2] : not_c;\n\n      case \"seq\":\n        c = slice(c);\n        c[c.length - 1] = negate(c[c.length - 1]);\n        return c;\n\n      case \"conditional\":\n        return best_of(not_c, [\"conditional\", c[1], negate(c[2]), negate(c[3])]);\n\n      case \"binary\":\n        var op = c[1],\n            left = c[2],\n            right = c[3];\n        if (!options.keep_comps) switch (op) {\n          case \"<=\":\n            return [\"binary\", \">\", left, right];\n\n          case \"<\":\n            return [\"binary\", \">=\", left, right];\n\n          case \">=\":\n            return [\"binary\", \"<\", left, right];\n\n          case \">\":\n            return [\"binary\", \"<=\", left, right];\n        }\n\n        switch (op) {\n          case \"==\":\n            return [\"binary\", \"!=\", left, right];\n\n          case \"!=\":\n            return [\"binary\", \"==\", left, right];\n\n          case \"===\":\n            return [\"binary\", \"!==\", left, right];\n\n          case \"!==\":\n            return [\"binary\", \"===\", left, right];\n\n          case \"&&\":\n            return best_of(not_c, [\"binary\", \"||\", negate(left), negate(right)]);\n\n          case \"||\":\n            return best_of(not_c, [\"binary\", \"&&\", negate(left), negate(right)]);\n        }\n\n        break;\n    }\n\n    return not_c;\n  }\n\n  ;\n\n  function make_conditional(c, t, e) {\n    var make_real_conditional = function () {\n      if (c[0] == \"unary-prefix\" && c[1] == \"!\") {\n        return e ? [\"conditional\", c[2], e, t] : [\"binary\", \"||\", c[2], t];\n      } else {\n        return e ? best_of([\"conditional\", c, t, e], [\"conditional\", negate(c), e, t]) : [\"binary\", \"&&\", c, t];\n      }\n    }; // shortcut the conditional if the expression has a constant value\n\n\n    return when_constant(c, function (ast, val) {\n      warn_unreachable(val ? e : t);\n      return val ? t : e;\n    }, make_real_conditional);\n  }\n\n  ;\n\n  function rmblock(block) {\n    if (block != null && block[0] == \"block\" && block[1]) {\n      if (block[1].length == 1) block = block[1][0];else if (block[1].length == 0) block = [\"block\"];\n    }\n\n    return block;\n  }\n\n  ;\n\n  function _lambda(name, args, body) {\n    return [this[0], name, args, tighten(body, \"lambda\")];\n  }\n\n  ; // this function does a few things:\n  // 1. discard useless blocks\n  // 2. join consecutive var declarations\n  // 3. remove obviously dead code\n  // 4. transform consecutive statements using the comma operator\n  // 5. if block_type == \"lambda\" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }\n\n  function tighten(statements, block_type) {\n    statements = MAP(statements, walk);\n    statements = statements.reduce(function (a, stat) {\n      if (stat[0] == \"block\") {\n        if (stat[1]) {\n          a.push.apply(a, stat[1]);\n        }\n      } else {\n        a.push(stat);\n      }\n\n      return a;\n    }, []);\n\n    statements = function (a, prev) {\n      statements.forEach(function (cur) {\n        if (prev && (cur[0] == \"var\" && prev[0] == \"var\" || cur[0] == \"const\" && prev[0] == \"const\")) {\n          prev[1] = prev[1].concat(cur[1]);\n        } else {\n          a.push(cur);\n          prev = cur;\n        }\n      });\n      return a;\n    }([]);\n\n    if (options.dead_code) statements = function (a, has_quit) {\n      statements.forEach(function (st) {\n        if (has_quit) {\n          if (st[0] == \"function\" || st[0] == \"defun\") {\n            a.push(st);\n          } else if (st[0] == \"var\" || st[0] == \"const\") {\n            if (!options.no_warnings) warn(\"Variables declared in unreachable code\");\n            st[1] = MAP(st[1], function (def) {\n              if (def[1] && !options.no_warnings) warn_unreachable([\"assign\", true, [\"name\", def[0]], def[1]]);\n              return [def[0]];\n            });\n            a.push(st);\n          } else if (!options.no_warnings) warn_unreachable(st);\n        } else {\n          a.push(st);\n          if (member(st[0], [\"return\", \"throw\", \"break\", \"continue\"])) has_quit = true;\n        }\n      });\n      return a;\n    }([]);\n    if (options.make_seqs) statements = function (a, prev) {\n      statements.forEach(function (cur) {\n        if (prev && prev[0] == \"stat\" && cur[0] == \"stat\") {\n          prev[1] = [\"seq\", prev[1], cur[1]];\n        } else {\n          a.push(cur);\n          prev = cur;\n        }\n      });\n\n      if (a.length >= 2 && a[a.length - 2][0] == \"stat\" && (a[a.length - 1][0] == \"return\" || a[a.length - 1][0] == \"throw\") && a[a.length - 1][1]) {\n        a.splice(a.length - 2, 2, [a[a.length - 1][0], [\"seq\", a[a.length - 2][1], a[a.length - 1][1]]]);\n      }\n\n      return a;\n    }([]); // this increases jQuery by 1K.  Probably not such a good idea after all..\n    // part of this is done in prepare_ifs anyway.\n    // if (block_type == \"lambda\") statements = (function(i, a, stat){\n    //         while (i < statements.length) {\n    //                 stat = statements[i++];\n    //                 if (stat[0] == \"if\" && !stat[3]) {\n    //                         if (stat[2][0] == \"return\" && stat[2][1] == null) {\n    //                                 a.push(make_if(negate(stat[1]), [ \"block\", statements.slice(i) ]));\n    //                                 break;\n    //                         }\n    //                         var last = last_stat(stat[2]);\n    //                         if (last[0] == \"return\" && last[1] == null) {\n    //                                 a.push(make_if(stat[1], [ \"block\", stat[2][1].slice(0, -1) ], [ \"block\", statements.slice(i) ]));\n    //                                 break;\n    //                         }\n    //                 }\n    //                 a.push(stat);\n    //         }\n    //         return a;\n    // })(0, []);\n\n    return statements;\n  }\n\n  ;\n\n  function make_if(c, t, e) {\n    return when_constant(c, function (ast, val) {\n      if (val) {\n        t = walk(t);\n        warn_unreachable(e);\n        return t || [\"block\"];\n      } else {\n        e = walk(e);\n        warn_unreachable(t);\n        return e || [\"block\"];\n      }\n    }, function () {\n      return make_real_if(c, t, e);\n    });\n  }\n\n  ;\n\n  function abort_else(c, t, e) {\n    var ret = [[\"if\", negate(c), e]];\n\n    if (t[0] == \"block\") {\n      if (t[1]) ret = ret.concat(t[1]);\n    } else {\n      ret.push(t);\n    }\n\n    return walk([\"block\", ret]);\n  }\n\n  ;\n\n  function make_real_if(c, t, e) {\n    c = walk(c);\n    t = walk(t);\n    e = walk(e);\n\n    if (empty(t)) {\n      c = negate(c);\n      t = e;\n      e = null;\n    } else if (empty(e)) {\n      e = null;\n    } else {\n      // if we have both else and then, maybe it makes sense to switch them?\n      (function () {\n        var a = gen_code(c);\n        var n = negate(c);\n        var b = gen_code(n);\n\n        if (b.length < a.length) {\n          var tmp = t;\n          t = e;\n          e = tmp;\n          c = n;\n        }\n      })();\n    }\n\n    if (empty(e) && empty(t)) return [\"stat\", c];\n    var ret = [\"if\", c, t, e];\n\n    if (t[0] == \"if\" && empty(t[3]) && empty(e)) {\n      ret = best_of(ret, walk([\"if\", [\"binary\", \"&&\", c, t[1]], t[2]]));\n    } else if (t[0] == \"stat\") {\n      if (e) {\n        if (e[0] == \"stat\") ret = best_of(ret, [\"stat\", make_conditional(c, t[1], e[1])]);else if (aborts(e)) ret = abort_else(c, t, e);\n      } else {\n        ret = best_of(ret, [\"stat\", make_conditional(c, t[1])]);\n      }\n    } else if (e && t[0] == e[0] && (t[0] == \"return\" || t[0] == \"throw\") && t[1] && e[1]) {\n      ret = best_of(ret, [t[0], make_conditional(c, t[1], e[1])]);\n    } else if (e && aborts(t)) {\n      ret = [[\"if\", c, t]];\n\n      if (e[0] == \"block\") {\n        if (e[1]) ret = ret.concat(e[1]);\n      } else {\n        ret.push(e);\n      }\n\n      ret = walk([\"block\", ret]);\n    } else if (t && aborts(e)) {\n      ret = abort_else(c, t, e);\n    }\n\n    return ret;\n  }\n\n  ;\n\n  function _do_while(cond, body) {\n    return when_constant(cond, function (cond, val) {\n      if (!val) {\n        warn_unreachable(body);\n        return [\"block\"];\n      } else {\n        return [\"for\", null, null, null, walk(body)];\n      }\n    });\n  }\n\n  ;\n  return w.with_walkers({\n    \"sub\": function (expr, subscript) {\n      if (subscript[0] == \"string\") {\n        var name = subscript[1];\n        if (is_identifier(name)) return [\"dot\", walk(expr), name];else if (/^[1-9][0-9]*$/.test(name) || name === \"0\") return [\"sub\", walk(expr), [\"num\", parseInt(name, 10)]];\n      }\n    },\n    \"if\": make_if,\n    \"toplevel\": function (body) {\n      return [\"toplevel\", tighten(body)];\n    },\n    \"switch\": function (expr, body) {\n      var last = body.length - 1;\n      return [\"switch\", walk(expr), MAP(body, function (branch, i) {\n        var block = tighten(branch[1]);\n\n        if (i == last && block.length > 0) {\n          var node = block[block.length - 1];\n          if (node[0] == \"break\" && !node[1]) block.pop();\n        }\n\n        return [branch[0] ? walk(branch[0]) : null, block];\n      })];\n    },\n    \"function\": _lambda,\n    \"defun\": _lambda,\n    \"block\": function (body) {\n      if (body) return rmblock([\"block\", tighten(body)]);\n    },\n    \"binary\": function (op, left, right) {\n      return when_constant([\"binary\", op, walk(left), walk(right)], function yes(c) {\n        return best_of(walk(c), this);\n      }, function no() {\n        return function () {\n          if (op != \"==\" && op != \"!=\") return;\n          var l = walk(left),\n              r = walk(right);\n          if (l && l[0] == \"unary-prefix\" && l[1] == \"!\" && l[2][0] == \"num\") left = ['num', +!l[2][1]];else if (r && r[0] == \"unary-prefix\" && r[1] == \"!\" && r[2][0] == \"num\") right = ['num', +!r[2][1]];\n          return [\"binary\", op, left, right];\n        }() || this;\n      });\n    },\n    \"conditional\": function (c, t, e) {\n      return make_conditional(walk(c), walk(t), walk(e));\n    },\n    \"try\": function (t, c, f) {\n      return [\"try\", tighten(t), c != null ? [c[0], tighten(c[1])] : null, f != null ? tighten(f) : null];\n    },\n    \"unary-prefix\": function (op, expr) {\n      expr = walk(expr);\n      var ret = [\"unary-prefix\", op, expr];\n      if (op == \"!\") ret = best_of(ret, negate(expr));\n      return when_constant(ret, function (ast, val) {\n        return walk(ast); // it's either true or false, so minifies to !0 or !1\n      }, function () {\n        return ret;\n      });\n    },\n    \"name\": function (name) {\n      switch (name) {\n        case \"true\":\n          return [\"unary-prefix\", \"!\", [\"num\", 0]];\n\n        case \"false\":\n          return [\"unary-prefix\", \"!\", [\"num\", 1]];\n      }\n    },\n    \"while\": _do_while,\n    \"assign\": function (op, lvalue, rvalue) {\n      lvalue = walk(lvalue);\n      rvalue = walk(rvalue);\n      var okOps = ['+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&'];\n\n      if (op === true && lvalue[0] === \"name\" && rvalue[0] === \"binary\" && ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === \"name\" && rvalue[2][1] === lvalue[1]) {\n        return [this[0], rvalue[1], lvalue, rvalue[3]];\n      }\n\n      return [this[0], op, lvalue, rvalue];\n    }\n  }, function () {\n    for (var i = 0; i < 2; ++i) {\n      ast = prepare_ifs(ast);\n      ast = walk(ast);\n    }\n\n    return ast;\n  });\n}\n\n;\n/* -----[ re-generate code from the AST ]----- */\n\nvar DOT_CALL_NO_PARENS = jsp.array_to_hash([\"name\", \"array\", \"object\", \"string\", \"dot\", \"sub\", \"call\", \"regexp\", \"defun\"]);\n\nfunction make_string(str, ascii_only) {\n  var dq = 0,\n      sq = 0;\n  str = str.replace(/[\\\\\\b\\f\\n\\r\\t\\x22\\x27\\u2028\\u2029\\0]/g, function (s) {\n    switch (s) {\n      case \"\\\\\":\n        return \"\\\\\\\\\";\n\n      case \"\\b\":\n        return \"\\\\b\";\n\n      case \"\\f\":\n        return \"\\\\f\";\n\n      case \"\\n\":\n        return \"\\\\n\";\n\n      case \"\\r\":\n        return \"\\\\r\";\n\n      case \"\\t\":\n        return \"\\\\t\";\n\n      case \"\\u2028\":\n        return \"\\\\u2028\";\n\n      case \"\\u2029\":\n        return \"\\\\u2029\";\n\n      case '\"':\n        ++dq;\n        return '\"';\n\n      case \"'\":\n        ++sq;\n        return \"'\";\n\n      case \"\\0\":\n        return \"\\\\0\";\n    }\n\n    return s;\n  });\n  if (ascii_only) str = to_ascii(str);\n  if (dq > sq) return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";else return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n}\n\n;\n\nfunction to_ascii(str) {\n  return str.replace(/[\\u0080-\\uffff]/g, function (ch) {\n    var code = ch.charCodeAt(0).toString(16);\n\n    while (code.length < 4) code = \"0\" + code;\n\n    return \"\\\\u\" + code;\n  });\n}\n\n;\nvar SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([\"if\", \"while\", \"do\", \"for\", \"for-in\", \"with\"]);\n\nfunction gen_code(ast, options) {\n  options = defaults(options, {\n    indent_start: 0,\n    indent_level: 4,\n    quote_keys: false,\n    space_colon: false,\n    beautify: false,\n    ascii_only: false,\n    inline_script: false\n  });\n  var beautify = !!options.beautify;\n  var indentation = 0,\n      newline = beautify ? \"\\n\" : \"\",\n      space = beautify ? \" \" : \"\";\n\n  function encode_string(str) {\n    var ret = make_string(str, options.ascii_only);\n    if (options.inline_script) ret = ret.replace(/<\\x2fscript([>\\/\\t\\n\\f\\r ])/gi, \"<\\\\/script$1\");\n    return ret;\n  }\n\n  ;\n\n  function make_name(name) {\n    name = name.toString();\n    if (options.ascii_only) name = to_ascii(name);\n    return name;\n  }\n\n  ;\n\n  function indent(line) {\n    if (line == null) line = \"\";\n    if (beautify) line = repeat_string(\" \", options.indent_start + indentation * options.indent_level) + line;\n    return line;\n  }\n\n  ;\n\n  function with_indent(cont, incr) {\n    if (incr == null) incr = 1;\n    indentation += incr;\n\n    try {\n      return cont.apply(null, slice(arguments, 1));\n    } finally {\n      indentation -= incr;\n    }\n  }\n\n  ;\n\n  function add_spaces(a) {\n    if (beautify) return a.join(\" \");\n    var b = [];\n\n    for (var i = 0; i < a.length; ++i) {\n      var next = a[i + 1];\n      b.push(a[i]);\n\n      if (next && (/[a-z0-9_\\x24]$/i.test(a[i].toString()) && /^[a-z0-9_\\x24]/i.test(next.toString()) || /[\\+\\-]$/.test(a[i].toString()) && /^[\\+\\-]/.test(next.toString()))) {\n        b.push(\" \");\n      }\n    }\n\n    return b.join(\"\");\n  }\n\n  ;\n\n  function add_commas(a) {\n    return a.join(\",\" + space);\n  }\n\n  ;\n\n  function parenthesize(expr) {\n    var gen = make(expr);\n\n    for (var i = 1; i < arguments.length; ++i) {\n      var el = arguments[i];\n      if (el instanceof Function && el(expr) || expr[0] == el) return \"(\" + gen + \")\";\n    }\n\n    return gen;\n  }\n\n  ;\n\n  function best_of(a) {\n    if (a.length == 1) {\n      return a[0];\n    }\n\n    if (a.length == 2) {\n      var b = a[1];\n      a = a[0];\n      return a.length <= b.length ? a : b;\n    }\n\n    return best_of([a[0], best_of(a.slice(1))]);\n  }\n\n  ;\n\n  function needs_parens(expr) {\n    if (expr[0] == \"function\" || expr[0] == \"object\") {\n      // dot/call on a literal function requires the\n      // function literal itself to be parenthesized\n      // only if it's the first \"thing\" in a\n      // statement.  This means that the parent is\n      // \"stat\", but it could also be a \"seq\" and\n      // we're the first in this \"seq\" and the\n      // parent is \"stat\", and so on.  Messy stuff,\n      // but it worths the trouble.\n      var a = slice(w.stack()),\n          self = a.pop(),\n          p = a.pop();\n\n      while (p) {\n        if (p[0] == \"stat\") return true;\n\n        if ((p[0] == \"seq\" || p[0] == \"call\" || p[0] == \"dot\" || p[0] == \"sub\" || p[0] == \"conditional\") && p[1] === self || (p[0] == \"binary\" || p[0] == \"assign\" || p[0] == \"unary-postfix\") && p[2] === self) {\n          self = p;\n          p = a.pop();\n        } else {\n          return false;\n        }\n      }\n    }\n\n    return !HOP(DOT_CALL_NO_PARENS, expr[0]);\n  }\n\n  ;\n\n  function make_num(num) {\n    var str = num.toString(10),\n        a = [str.replace(/^0\\./, \".\")],\n        m;\n\n    if (Math.floor(num) === num) {\n      if (num >= 0) {\n        a.push(\"0x\" + num.toString(16).toLowerCase(), // probably pointless\n        \"0\" + num.toString(8)); // same.\n      } else {\n        a.push(\"-0x\" + (-num).toString(16).toLowerCase(), // probably pointless\n        \"-0\" + (-num).toString(8)); // same.\n      }\n\n      if (m = /^(.*?)(0+)$/.exec(num)) {\n        a.push(m[1] + \"e\" + m[2].length);\n      }\n    } else if (m = /^0?\\.(0+)(.*)$/.exec(num)) {\n      a.push(m[2] + \"e-\" + (m[1].length + m[2].length), str.substr(str.indexOf(\".\")));\n    }\n\n    return best_of(a);\n  }\n\n  ;\n  var w = ast_walker();\n  var make = w.walk;\n  return w.with_walkers({\n    \"string\": encode_string,\n    \"num\": make_num,\n    \"name\": make_name,\n    \"debugger\": function () {\n      return \"debugger\";\n    },\n    \"toplevel\": function (statements) {\n      return make_block_statements(statements).join(newline + newline);\n    },\n    \"splice\": function (statements) {\n      var parent = w.parent();\n\n      if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {\n        // we need block brackets in this case\n        return make_block.apply(this, arguments);\n      } else {\n        return MAP(make_block_statements(statements, true), function (line, i) {\n          // the first line is already indented\n          return i > 0 ? indent(line) : line;\n        }).join(newline);\n      }\n    },\n    \"block\": make_block,\n    \"var\": function (defs) {\n      return \"var \" + add_commas(MAP(defs, make_1vardef)) + \";\";\n    },\n    \"const\": function (defs) {\n      return \"const \" + add_commas(MAP(defs, make_1vardef)) + \";\";\n    },\n    \"try\": function (tr, ca, fi) {\n      var out = [\"try\", make_block(tr)];\n      if (ca) out.push(\"catch\", \"(\" + ca[0] + \")\", make_block(ca[1]));\n      if (fi) out.push(\"finally\", make_block(fi));\n      return add_spaces(out);\n    },\n    \"throw\": function (expr) {\n      return add_spaces([\"throw\", make(expr)]) + \";\";\n    },\n    \"new\": function (ctor, args) {\n      args = args.length > 0 ? \"(\" + add_commas(MAP(args, function (expr) {\n        return parenthesize(expr, \"seq\");\n      })) + \")\" : \"\";\n      return add_spaces([\"new\", parenthesize(ctor, \"seq\", \"binary\", \"conditional\", \"assign\", function (expr) {\n        var w = ast_walker(),\n            has_call = {};\n\n        try {\n          w.with_walkers({\n            \"call\": function () {\n              throw has_call;\n            },\n            \"function\": function () {\n              return this;\n            }\n          }, function () {\n            w.walk(expr);\n          });\n        } catch (ex) {\n          if (ex === has_call) return true;\n          throw ex;\n        }\n      }) + args]);\n    },\n    \"switch\": function (expr, body) {\n      return add_spaces([\"switch\", \"(\" + make(expr) + \")\", make_switch_block(body)]);\n    },\n    \"break\": function (label) {\n      var out = \"break\";\n      if (label != null) out += \" \" + make_name(label);\n      return out + \";\";\n    },\n    \"continue\": function (label) {\n      var out = \"continue\";\n      if (label != null) out += \" \" + make_name(label);\n      return out + \";\";\n    },\n    \"conditional\": function (co, th, el) {\n      return add_spaces([parenthesize(co, \"assign\", \"seq\", \"conditional\"), \"?\", parenthesize(th, \"seq\"), \":\", parenthesize(el, \"seq\")]);\n    },\n    \"assign\": function (op, lvalue, rvalue) {\n      if (op && op !== true) op += \"=\";else op = \"=\";\n      return add_spaces([make(lvalue), op, parenthesize(rvalue, \"seq\")]);\n    },\n    \"dot\": function (expr) {\n      var out = make(expr),\n          i = 1;\n\n      if (expr[0] == \"num\") {\n        if (!/\\./.test(expr[1])) out += \".\";\n      } else if (needs_parens(expr)) out = \"(\" + out + \")\";\n\n      while (i < arguments.length) out += \".\" + make_name(arguments[i++]);\n\n      return out;\n    },\n    \"call\": function (func, args) {\n      var f = make(func);\n      if (f.charAt(0) != \"(\" && needs_parens(func)) f = \"(\" + f + \")\";\n      return f + \"(\" + add_commas(MAP(args, function (expr) {\n        return parenthesize(expr, \"seq\");\n      })) + \")\";\n    },\n    \"function\": make_function,\n    \"defun\": make_function,\n    \"if\": function (co, th, el) {\n      var out = [\"if\", \"(\" + make(co) + \")\", el ? make_then(th) : make(th)];\n\n      if (el) {\n        out.push(\"else\", make(el));\n      }\n\n      return add_spaces(out);\n    },\n    \"for\": function (init, cond, step, block) {\n      var out = [\"for\"];\n      init = (init != null ? make(init) : \"\").replace(/;*\\s*$/, \";\" + space);\n      cond = (cond != null ? make(cond) : \"\").replace(/;*\\s*$/, \";\" + space);\n      step = (step != null ? make(step) : \"\").replace(/;*\\s*$/, \"\");\n      var args = init + cond + step;\n      if (args == \"; ; \") args = \";;\";\n      out.push(\"(\" + args + \")\", make(block));\n      return add_spaces(out);\n    },\n    \"for-in\": function (vvar, key, hash, block) {\n      return add_spaces([\"for\", \"(\" + (vvar ? make(vvar).replace(/;+$/, \"\") : make(key)), \"in\", make(hash) + \")\", make(block)]);\n    },\n    \"while\": function (condition, block) {\n      return add_spaces([\"while\", \"(\" + make(condition) + \")\", make(block)]);\n    },\n    \"do\": function (condition, block) {\n      return add_spaces([\"do\", make(block), \"while\", \"(\" + make(condition) + \")\"]) + \";\";\n    },\n    \"return\": function (expr) {\n      var out = [\"return\"];\n      if (expr != null) out.push(make(expr));\n      return add_spaces(out) + \";\";\n    },\n    \"binary\": function (operator, lvalue, rvalue) {\n      var left = make(lvalue),\n          right = make(rvalue); // XXX: I'm pretty sure other cases will bite here.\n      //      we need to be smarter.\n      //      adding parens all the time is the safest bet.\n\n      if (member(lvalue[0], [\"assign\", \"conditional\", \"seq\"]) || lvalue[0] == \"binary\" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] || lvalue[0] == \"function\" && needs_parens(this)) {\n        left = \"(\" + left + \")\";\n      }\n\n      if (member(rvalue[0], [\"assign\", \"conditional\", \"seq\"]) || rvalue[0] == \"binary\" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] && !(rvalue[1] == operator && member(operator, [\"&&\", \"||\", \"*\"]))) {\n        right = \"(\" + right + \")\";\n      } else if (!beautify && options.inline_script && (operator == \"<\" || operator == \"<<\") && rvalue[0] == \"regexp\" && /^script/i.test(rvalue[1])) {\n        right = \" \" + right;\n      }\n\n      return add_spaces([left, operator, right]);\n    },\n    \"unary-prefix\": function (operator, expr) {\n      var val = make(expr);\n      if (!(expr[0] == \"num\" || expr[0] == \"unary-prefix\" && !HOP(OPERATORS, operator + expr[1]) || !needs_parens(expr))) val = \"(\" + val + \")\";\n      return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? \" \" : \"\") + val;\n    },\n    \"unary-postfix\": function (operator, expr) {\n      var val = make(expr);\n      if (!(expr[0] == \"num\" || expr[0] == \"unary-postfix\" && !HOP(OPERATORS, operator + expr[1]) || !needs_parens(expr))) val = \"(\" + val + \")\";\n      return val + operator;\n    },\n    \"sub\": function (expr, subscript) {\n      var hash = make(expr);\n      if (needs_parens(expr)) hash = \"(\" + hash + \")\";\n      return hash + \"[\" + make(subscript) + \"]\";\n    },\n    \"object\": function (props) {\n      var obj_needs_parens = needs_parens(this);\n      if (props.length == 0) return obj_needs_parens ? \"({})\" : \"{}\";\n      var out = \"{\" + newline + with_indent(function () {\n        return MAP(props, function (p) {\n          if (p.length == 3) {\n            // getter/setter.  The name is in p[0], the arg.list in p[1][2], the\n            // body in p[1][3] and type (\"get\" / \"set\") in p[2].\n            return indent(make_function(p[0], p[1][2], p[1][3], p[2]));\n          }\n\n          var key = p[0],\n              val = parenthesize(p[1], \"seq\");\n\n          if (options.quote_keys) {\n            key = encode_string(key);\n          } else if ((typeof key == \"number\" || !beautify && +key + \"\" == key) && parseFloat(key) >= 0) {\n            key = make_num(+key);\n          } else if (!is_identifier(key)) {\n            key = encode_string(key);\n          }\n\n          return indent(add_spaces(beautify && options.space_colon ? [key, \":\", val] : [key + \":\", val]));\n        }).join(\",\" + newline);\n      }) + newline + indent(\"}\");\n      return obj_needs_parens ? \"(\" + out + \")\" : out;\n    },\n    \"regexp\": function (rx, mods) {\n      return \"/\" + rx + \"/\" + mods;\n    },\n    \"array\": function (elements) {\n      if (elements.length == 0) return \"[]\";\n      return add_spaces([\"[\", add_commas(MAP(elements, function (el, i) {\n        if (!beautify && el[0] == \"atom\" && el[1] == \"undefined\") return i === elements.length - 1 ? \",\" : \"\";\n        return parenthesize(el, \"seq\");\n      })), \"]\"]);\n    },\n    \"stat\": function (stmt) {\n      return make(stmt).replace(/;*\\s*$/, \";\");\n    },\n    \"seq\": function () {\n      return add_commas(MAP(slice(arguments), make));\n    },\n    \"label\": function (name, block) {\n      return add_spaces([make_name(name), \":\", make(block)]);\n    },\n    \"with\": function (expr, block) {\n      return add_spaces([\"with\", \"(\" + make(expr) + \")\", make(block)]);\n    },\n    \"atom\": function (name) {\n      return make_name(name);\n    }\n  }, function () {\n    return make(ast);\n  }); // The squeezer replaces \"block\"-s that contain only a single\n  // statement with the statement itself; technically, the AST\n  // is correct, but this can create problems when we output an\n  // IF having an ELSE clause where the THEN clause ends in an\n  // IF *without* an ELSE block (then the outer ELSE would refer\n  // to the inner IF).  This function checks for this case and\n  // adds the block brackets if needed.\n\n  function make_then(th) {\n    if (th == null) return \";\";\n\n    if (th[0] == \"do\") {\n      // https://github.com/mishoo/UglifyJS/issues/#issue/57\n      // IE croaks with \"syntax error\" on code like this:\n      //     if (foo) do ... while(cond); else ...\n      // we need block brackets around do/while\n      return make_block([th]);\n    }\n\n    var b = th;\n\n    while (true) {\n      var type = b[0];\n\n      if (type == \"if\") {\n        if (!b[3]) // no else, we must add the block\n          return make([\"block\", [th]]);\n        b = b[3];\n      } else if (type == \"while\" || type == \"do\") b = b[2];else if (type == \"for\" || type == \"for-in\") b = b[4];else break;\n    }\n\n    return make(th);\n  }\n\n  ;\n\n  function make_function(name, args, body, keyword) {\n    var out = keyword || \"function\";\n\n    if (name) {\n      out += \" \" + make_name(name);\n    }\n\n    out += \"(\" + add_commas(MAP(args, make_name)) + \")\";\n    out = add_spaces([out, make_block(body)]);\n    return needs_parens(this) ? \"(\" + out + \")\" : out;\n  }\n\n  ;\n\n  function must_has_semicolon(node) {\n    switch (node[0]) {\n      case \"with\":\n      case \"while\":\n        return empty(node[2]);\n      // `with' or `while' with empty body?\n\n      case \"for\":\n      case \"for-in\":\n        return empty(node[4]);\n      // `for' with empty body?\n\n      case \"if\":\n        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'\n\n        if (node[3]) {\n          if (empty(node[3])) return true; // `else' present but empty\n\n          return must_has_semicolon(node[3]); // dive into the `else' branch\n        }\n\n        return must_has_semicolon(node[2]);\n      // dive into the `then' branch\n    }\n  }\n\n  ;\n\n  function make_block_statements(statements, noindent) {\n    for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {\n      var stat = statements[i];\n      var code = make(stat);\n\n      if (code != \";\") {\n        if (!beautify && i == last && !must_has_semicolon(stat)) {\n          code = code.replace(/;+\\s*$/, \"\");\n        }\n\n        a.push(code);\n      }\n    }\n\n    return noindent ? a : MAP(a, indent);\n  }\n\n  ;\n\n  function make_switch_block(body) {\n    var n = body.length;\n    if (n == 0) return \"{}\";\n    return \"{\" + newline + MAP(body, function (branch, i) {\n      var has_body = branch[1].length > 0,\n          code = with_indent(function () {\n        return indent(branch[0] ? add_spaces([\"case\", make(branch[0]) + \":\"]) : \"default:\");\n      }, 0.5) + (has_body ? newline + with_indent(function () {\n        return make_block_statements(branch[1]).join(newline);\n      }) : \"\");\n      if (!beautify && has_body && i < n - 1) code += \";\";\n      return code;\n    }).join(newline) + newline + indent(\"}\");\n  }\n\n  ;\n\n  function make_block(statements) {\n    if (!statements) return \";\";\n    if (statements.length == 0) return \"{}\";\n    return \"{\" + newline + with_indent(function () {\n      return make_block_statements(statements).join(newline);\n    }) + newline + indent(\"}\");\n  }\n\n  ;\n\n  function make_1vardef(def) {\n    var name = def[0],\n        val = def[1];\n    if (val != null) name = add_spaces([make_name(name), \"=\", parenthesize(val, \"seq\")]);\n    return name;\n  }\n\n  ;\n}\n\n;\n\nfunction split_lines(code, max_line_length) {\n  var splits = [0];\n  jsp.parse(function () {\n    var next_token = jsp.tokenizer(code);\n    var last_split = 0;\n    var prev_token;\n\n    function current_length(tok) {\n      return tok.pos - last_split;\n    }\n\n    ;\n\n    function split_here(tok) {\n      last_split = tok.pos;\n      splits.push(last_split);\n    }\n\n    ;\n\n    function custom() {\n      var tok = next_token.apply(this, arguments);\n\n      out: {\n        if (prev_token) {\n          if (prev_token.type == \"keyword\") break out;\n        }\n\n        if (current_length(tok) > max_line_length) {\n          switch (tok.type) {\n            case \"keyword\":\n            case \"atom\":\n            case \"name\":\n            case \"punc\":\n              split_here(tok);\n              break out;\n          }\n        }\n      }\n\n      prev_token = tok;\n      return tok;\n    }\n\n    ;\n\n    custom.context = function () {\n      return next_token.context.apply(this, arguments);\n    };\n\n    return custom;\n  }());\n  return splits.map(function (pos, i) {\n    return code.substring(pos, splits[i + 1] || code.length);\n  }).join(\"\\n\");\n}\n\n;\n/* -----[ Utilities ]----- */\n\nfunction repeat_string(str, i) {\n  if (i <= 0) return \"\";\n  if (i == 1) return str;\n  var d = repeat_string(str, i >> 1);\n  d += d;\n  if (i & 1) d += str;\n  return d;\n}\n\n;\n\nfunction defaults(args, defs) {\n  var ret = {};\n  if (args === true) args = {};\n\n  for (var i in defs) if (HOP(defs, i)) {\n    ret[i] = args && HOP(args, i) ? args[i] : defs[i];\n  }\n\n  return ret;\n}\n\n;\n\nfunction is_identifier(name) {\n  return /^[a-z_$][a-z0-9_$]*$/i.test(name) && name != \"this\" && !HOP(jsp.KEYWORDS_ATOM, name) && !HOP(jsp.RESERVED_WORDS, name) && !HOP(jsp.KEYWORDS, name);\n}\n\n;\n\nfunction HOP(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n; // some utilities\n\nvar MAP;\n\n(function () {\n  MAP = function (a, f, o) {\n    var ret = [],\n        top = [],\n        i;\n\n    function doit() {\n      var val = f.call(o, a[i], i);\n\n      if (val instanceof AtTop) {\n        val = val.v;\n\n        if (val instanceof Splice) {\n          top.push.apply(top, val.v);\n        } else {\n          top.push(val);\n        }\n      } else if (val != skip) {\n        if (val instanceof Splice) {\n          ret.push.apply(ret, val.v);\n        } else {\n          ret.push(val);\n        }\n      }\n    }\n\n    ;\n    if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();else for (i in a) if (HOP(a, i)) doit();\n    return top.concat(ret);\n  };\n\n  MAP.at_top = function (val) {\n    return new AtTop(val);\n  };\n\n  MAP.splice = function (val) {\n    return new Splice(val);\n  };\n\n  var skip = MAP.skip = {};\n\n  function AtTop(val) {\n    this.v = val;\n  }\n\n  ;\n\n  function Splice(val) {\n    this.v = val;\n  }\n\n  ;\n})();\n/* -----[ Exports ]----- */\n\n\nexports.ast_walker = ast_walker;\nexports.ast_mangle = ast_mangle;\nexports.ast_squeeze = ast_squeeze;\nexports.ast_lift_variables = ast_lift_variables;\nexports.gen_code = gen_code;\nexports.ast_add_scope = ast_add_scope;\n\nexports.set_logger = function (logger) {\n  warn = logger;\n};\n\nexports.make_string = make_string;\nexports.split_lines = split_lines;\nexports.MAP = MAP; // keep this last!\n\nexports.ast_squeeze_more = require(\"./squeeze-more\").ast_squeeze_more;","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/uglify-js/lib/process.js"],"names":["jsp","require","slice","member","PRECEDENCE","OPERATORS","ast_walker","_vardefs","defs","MAP","def","a","length","walk","_block","statements","out","push","walkers","str","num","name","t","c","f","expr","ctor","args","body","branch","label","cond","e","op","lvalue","rvalue","concat","arguments","conditional","init","step","block","vvar","key","hash","left","right","subscript","props","p","rx","mods","elements","stat","user","stack","ast","type","gen","ret","apply","pop","dive","with_walkers","cont","save","i","HOP","parent","Scope","names","mangled","rev_mangled","cname","refs","uses_with","uses_eval","children","level","base54","DIGITS","charAt","Math","floor","prototype","has","s","has_mangled","mname","toJSON","next_mangled","m","prior","is_identifier","set_mangle","get_mangled","newMangle","references","define","ast_add_scope","current_scope","w","having_eval","with_new_scope","labels","scope","reference","_lambda","is_defun","d","_breacont","fixrefs","origin","ast_mangle","options","toplevel","except","get_define","defines","no_functions","extra","with_scope","_scope","at_top","self","warn","best_of","ast1","ast2","gen_code","last_stat","b","aborts","boolean_expr","empty","is_string","node","when_constant","$NOT_CONSTANT","evaluate","yes","no","val","String","Error","call","ex","substr","lval","ex2","warn_unreachable","prepare_ifs","redo_if","fi","e_body","redo_if_lambda","redo_if_block","for_side_effects","handler","$stop","$restart","stop","restart","found","unary","ast_lift_variables","do_body","env","skip","walker","splice","unshift","_toplevel","ast_squeeze","defaults","make_seqs","dead_code","no_warnings","keep_comps","negate","not_c","make_conditional","make_real_conditional","rmblock","tighten","block_type","reduce","prev","forEach","cur","has_quit","st","make_if","make_real_if","abort_else","n","tmp","_do_while","test","parseInt","last","l","r","okOps","indexOf","DOT_CALL_NO_PARENS","array_to_hash","make_string","ascii_only","dq","sq","replace","to_ascii","ch","code","charCodeAt","toString","SPLICE_NEEDS_BRACKETS","indent_start","indent_level","quote_keys","space_colon","beautify","inline_script","indentation","newline","space","encode_string","make_name","indent","line","repeat_string","with_indent","incr","add_spaces","join","next","add_commas","parenthesize","make","el","Function","needs_parens","make_num","toLowerCase","exec","make_block_statements","make_block","make_1vardef","tr","ca","has_call","make_switch_block","co","th","func","make_function","make_then","condition","operator","is_alphanumeric_char","obj_needs_parens","parseFloat","stmt","keyword","must_has_semicolon","noindent","has_body","split_lines","max_line_length","splits","parse","next_token","tokenizer","last_split","prev_token","current_length","tok","pos","split_here","custom","context","map","substring","KEYWORDS_ATOM","RESERVED_WORDS","KEYWORDS","obj","prop","Object","hasOwnProperty","o","top","doit","AtTop","v","Splice","Array","exports","set_logger","logger","ast_squeeze_more"],"mappings":"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","sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n\n  This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n\n  This file implements some AST processors.  They work on data built\n  by parse-js.\n\n  Exported functions:\n\n    - ast_mangle(ast, options) -- mangles the variable/function names\n      in the AST.  Returns an AST.\n\n    - ast_squeeze(ast) -- employs various optimizations to make the\n      final generated code even smaller.  Returns an AST.\n\n    - gen_code(ast, options) -- generates JS code from the AST.  Pass\n      true (or an object, see the code for some options) as second\n      argument to get \"pretty\" (indented) code.\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nvar jsp = require(\"./parse-js\"),\n    slice = jsp.slice,\n    member = jsp.member,\n    PRECEDENCE = jsp.PRECEDENCE,\n    OPERATORS = jsp.OPERATORS;\n\n/* -----[ helper for AST traversal ]----- */\n\nfunction ast_walker() {\n        function _vardefs(defs) {\n                return [ this[0], MAP(defs, function(def){\n                        var a = [ def[0] ];\n                        if (def.length > 1)\n                                a[1] = walk(def[1]);\n                        return a;\n                }) ];\n        };\n        function _block(statements) {\n                var out = [ this[0] ];\n                if (statements != null)\n                        out.push(MAP(statements, walk));\n                return out;\n        };\n        var walkers = {\n                \"string\": function(str) {\n                        return [ this[0], str ];\n                },\n                \"num\": function(num) {\n                        return [ this[0], num ];\n                },\n                \"name\": function(name) {\n                        return [ this[0], name ];\n                },\n                \"toplevel\": function(statements) {\n                        return [ this[0], MAP(statements, walk) ];\n                },\n                \"block\": _block,\n                \"splice\": _block,\n                \"var\": _vardefs,\n                \"const\": _vardefs,\n                \"try\": function(t, c, f) {\n                        return [\n                                this[0],\n                                MAP(t, walk),\n                                c != null ? [ c[0], MAP(c[1], walk) ] : null,\n                                f != null ? MAP(f, walk) : null\n                        ];\n                },\n                \"throw\": function(expr) {\n                        return [ this[0], walk(expr) ];\n                },\n                \"new\": function(ctor, args) {\n                        return [ this[0], walk(ctor), MAP(args, walk) ];\n                },\n                \"switch\": function(expr, body) {\n                        return [ this[0], walk(expr), MAP(body, function(branch){\n                                return [ branch[0] ? walk(branch[0]) : null,\n                                         MAP(branch[1], walk) ];\n                        }) ];\n                },\n                \"break\": function(label) {\n                        return [ this[0], label ];\n                },\n                \"continue\": function(label) {\n                        return [ this[0], label ];\n                },\n                \"conditional\": function(cond, t, e) {\n                        return [ this[0], walk(cond), walk(t), walk(e) ];\n                },\n                \"assign\": function(op, lvalue, rvalue) {\n                        return [ this[0], op, walk(lvalue), walk(rvalue) ];\n                },\n                \"dot\": function(expr) {\n                        return [ this[0], walk(expr) ].concat(slice(arguments, 1));\n                },\n                \"call\": function(expr, args) {\n                        return [ this[0], walk(expr), MAP(args, walk) ];\n                },\n                \"function\": function(name, args, body) {\n                        return [ this[0], name, args.slice(), MAP(body, walk) ];\n                },\n                \"debugger\": function() {\n                        return [ this[0] ];\n                },\n                \"defun\": function(name, args, body) {\n                        return [ this[0], name, args.slice(), MAP(body, walk) ];\n                },\n                \"if\": function(conditional, t, e) {\n                        return [ this[0], walk(conditional), walk(t), walk(e) ];\n                },\n                \"for\": function(init, cond, step, block) {\n                        return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];\n                },\n                \"for-in\": function(vvar, key, hash, block) {\n                        return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];\n                },\n                \"while\": function(cond, block) {\n                        return [ this[0], walk(cond), walk(block) ];\n                },\n                \"do\": function(cond, block) {\n                        return [ this[0], walk(cond), walk(block) ];\n                },\n                \"return\": function(expr) {\n                        return [ this[0], walk(expr) ];\n                },\n                \"binary\": function(op, left, right) {\n                        return [ this[0], op, walk(left), walk(right) ];\n                },\n                \"unary-prefix\": function(op, expr) {\n                        return [ this[0], op, walk(expr) ];\n                },\n                \"unary-postfix\": function(op, expr) {\n                        return [ this[0], op, walk(expr) ];\n                },\n                \"sub\": function(expr, subscript) {\n                        return [ this[0], walk(expr), walk(subscript) ];\n                },\n                \"object\": function(props) {\n                        return [ this[0], MAP(props, function(p){\n                                return p.length == 2\n                                        ? [ p[0], walk(p[1]) ]\n                                        : [ p[0], walk(p[1]), p[2] ]; // get/set-ter\n                        }) ];\n                },\n                \"regexp\": function(rx, mods) {\n                        return [ this[0], rx, mods ];\n                },\n                \"array\": function(elements) {\n                        return [ this[0], MAP(elements, walk) ];\n                },\n                \"stat\": function(stat) {\n                        return [ this[0], walk(stat) ];\n                },\n                \"seq\": function() {\n                        return [ this[0] ].concat(MAP(slice(arguments), walk));\n                },\n                \"label\": function(name, block) {\n                        return [ this[0], name, walk(block) ];\n                },\n                \"with\": function(expr, block) {\n                        return [ this[0], walk(expr), walk(block) ];\n                },\n                \"atom\": function(name) {\n                        return [ this[0], name ];\n                }\n        };\n\n        var user = {};\n        var stack = [];\n        function walk(ast) {\n                if (ast == null)\n                        return null;\n                try {\n                        stack.push(ast);\n                        var type = ast[0];\n                        var gen = user[type];\n                        if (gen) {\n                                var ret = gen.apply(ast, ast.slice(1));\n                                if (ret != null)\n                                        return ret;\n                        }\n                        gen = walkers[type];\n                        return gen.apply(ast, ast.slice(1));\n                } finally {\n                        stack.pop();\n                }\n        };\n\n        function dive(ast) {\n                if (ast == null)\n                        return null;\n                try {\n                        stack.push(ast);\n                        return walkers[ast[0]].apply(ast, ast.slice(1));\n                } finally {\n                        stack.pop();\n                }\n        };\n\n        function with_walkers(walkers, cont){\n                var save = {}, i;\n                for (i in walkers) if (HOP(walkers, i)) {\n                        save[i] = user[i];\n                        user[i] = walkers[i];\n                }\n                var ret = cont();\n                for (i in save) if (HOP(save, i)) {\n                        if (!save[i]) delete user[i];\n                        else user[i] = save[i];\n                }\n                return ret;\n        };\n\n        return {\n                walk: walk,\n                dive: dive,\n                with_walkers: with_walkers,\n                parent: function() {\n                        return stack[stack.length - 2]; // last one is current node\n                },\n                stack: function() {\n                        return stack;\n                }\n        };\n};\n\n/* -----[ Scope and mangling ]----- */\n\nfunction Scope(parent) {\n        this.names = {};        // names defined in this scope\n        this.mangled = {};      // mangled names (orig.name => mangled)\n        this.rev_mangled = {};  // reverse lookup (mangled => orig.name)\n        this.cname = -1;        // current mangled name\n        this.refs = {};         // names referenced from this scope\n        this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes\n        this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes\n        this.parent = parent;   // parent scope\n        this.children = [];     // sub-scopes\n        if (parent) {\n                this.level = parent.level + 1;\n                parent.children.push(this);\n        } else {\n                this.level = 0;\n        }\n};\n\nvar base54 = (function(){\n        var DIGITS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\";\n        return function(num) {\n                var ret = \"\";\n                do {\n                        ret = DIGITS.charAt(num % 54) + ret;\n                        num = Math.floor(num / 54);\n                } while (num > 0);\n                return ret;\n        };\n})();\n\nScope.prototype = {\n        has: function(name) {\n                for (var s = this; s; s = s.parent)\n                        if (HOP(s.names, name))\n                                return s;\n        },\n        has_mangled: function(mname) {\n                for (var s = this; s; s = s.parent)\n                        if (HOP(s.rev_mangled, mname))\n                                return s;\n        },\n        toJSON: function() {\n                return {\n                        names: this.names,\n                        uses_eval: this.uses_eval,\n                        uses_with: this.uses_with\n                };\n        },\n\n        next_mangled: function() {\n                // we must be careful that the new mangled name:\n                //\n                // 1. doesn't shadow a mangled name from a parent\n                //    scope, unless we don't reference the original\n                //    name from this scope OR from any sub-scopes!\n                //    This will get slow.\n                //\n                // 2. doesn't shadow an original name from a parent\n                //    scope, in the event that the name is not mangled\n                //    in the parent scope and we reference that name\n                //    here OR IN ANY SUBSCOPES!\n                //\n                // 3. doesn't shadow a name that is referenced but not\n                //    defined (possibly global defined elsewhere).\n                for (;;) {\n                        var m = base54(++this.cname), prior;\n\n                        // case 1.\n                        prior = this.has_mangled(m);\n                        if (prior && this.refs[prior.rev_mangled[m]] === prior)\n                                continue;\n\n                        // case 2.\n                        prior = this.has(m);\n                        if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))\n                                continue;\n\n                        // case 3.\n                        if (HOP(this.refs, m) && this.refs[m] == null)\n                                continue;\n\n                        // I got \"do\" once. :-/\n                        if (!is_identifier(m))\n                                continue;\n\n                        return m;\n                }\n        },\n        set_mangle: function(name, m) {\n                this.rev_mangled[m] = name;\n                return this.mangled[name] = m;\n        },\n        get_mangled: function(name, newMangle) {\n                if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use\n                var s = this.has(name);\n                if (!s) return name; // not in visible scope, no mangle\n                if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope\n                if (!newMangle) return name;                      // not found and no mangling requested\n                return s.set_mangle(name, s.next_mangled());\n        },\n        references: function(name) {\n                return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];\n        },\n        define: function(name, type) {\n                if (name != null) {\n                        if (type == \"var\" || !HOP(this.names, name))\n                                this.names[name] = type || \"var\";\n                        return name;\n                }\n        }\n};\n\nfunction ast_add_scope(ast) {\n\n        var current_scope = null;\n        var w = ast_walker(), walk = w.walk;\n        var having_eval = [];\n\n        function with_new_scope(cont) {\n                current_scope = new Scope(current_scope);\n                current_scope.labels = new Scope();\n                var ret = current_scope.body = cont();\n                ret.scope = current_scope;\n                current_scope = current_scope.parent;\n                return ret;\n        };\n\n        function define(name, type) {\n                return current_scope.define(name, type);\n        };\n\n        function reference(name) {\n                current_scope.refs[name] = true;\n        };\n\n        function _lambda(name, args, body) {\n                var is_defun = this[0] == \"defun\";\n                return [ this[0], is_defun ? define(name, \"defun\") : name, args, with_new_scope(function(){\n                        if (!is_defun) define(name, \"lambda\");\n                        MAP(args, function(name){ define(name, \"arg\") });\n                        return MAP(body, walk);\n                })];\n        };\n\n        function _vardefs(type) {\n                return function(defs) {\n                        MAP(defs, function(d){\n                                define(d[0], type);\n                                if (d[1]) reference(d[0]);\n                        });\n                };\n        };\n\n        function _breacont(label) {\n                if (label)\n                        current_scope.labels.refs[label] = true;\n        };\n\n        return with_new_scope(function(){\n                // process AST\n                var ret = w.with_walkers({\n                        \"function\": _lambda,\n                        \"defun\": _lambda,\n                        \"label\": function(name, stat) { current_scope.labels.define(name) },\n                        \"break\": _breacont,\n                        \"continue\": _breacont,\n                        \"with\": function(expr, block) {\n                                for (var s = current_scope; s; s = s.parent)\n                                        s.uses_with = true;\n                        },\n                        \"var\": _vardefs(\"var\"),\n                        \"const\": _vardefs(\"const\"),\n                        \"try\": function(t, c, f) {\n                                if (c != null) return [\n                                        this[0],\n                                        MAP(t, walk),\n                                        [ define(c[0], \"catch\"), MAP(c[1], walk) ],\n                                        f != null ? MAP(f, walk) : null\n                                ];\n                        },\n                        \"name\": function(name) {\n                                if (name == \"eval\")\n                                        having_eval.push(current_scope);\n                                reference(name);\n                        }\n                }, function(){\n                        return walk(ast);\n                });\n\n                // the reason why we need an additional pass here is\n                // that names can be used prior to their definition.\n\n                // scopes where eval was detected and their parents\n                // are marked with uses_eval, unless they define the\n                // \"eval\" name.\n                MAP(having_eval, function(scope){\n                        if (!scope.has(\"eval\")) while (scope) {\n                                scope.uses_eval = true;\n                                scope = scope.parent;\n                        }\n                });\n\n                // for referenced names it might be useful to know\n                // their origin scope.  current_scope here is the\n                // toplevel one.\n                function fixrefs(scope, i) {\n                        // do children first; order shouldn't matter\n                        for (i = scope.children.length; --i >= 0;)\n                                fixrefs(scope.children[i]);\n                        for (i in scope.refs) if (HOP(scope.refs, i)) {\n                                // find origin scope and propagate the reference to origin\n                                for (var origin = scope.has(i), s = scope; s; s = s.parent) {\n                                        s.refs[i] = origin;\n                                        if (s === origin) break;\n                                }\n                        }\n                };\n                fixrefs(current_scope);\n\n                return ret;\n        });\n\n};\n\n/* -----[ mangle names ]----- */\n\nfunction ast_mangle(ast, options) {\n        var w = ast_walker(), walk = w.walk, scope;\n        options = options || {};\n\n        function get_mangled(name, newMangle) {\n                if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel\n                if (options.except && member(name, options.except))\n                        return name;\n                return scope.get_mangled(name, newMangle);\n        };\n\n        function get_define(name) {\n                if (options.defines) {\n                        // we always lookup a defined symbol for the current scope FIRST, so declared\n                        // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value\n                        if (!scope.has(name)) {\n                                if (HOP(options.defines, name)) {\n                                        return options.defines[name];\n                                }\n                        }\n                        return null;\n                }\n        };\n\n        function _lambda(name, args, body) {\n                if (!options.no_functions) {\n                        var is_defun = this[0] == \"defun\", extra;\n                        if (name) {\n                                if (is_defun) name = get_mangled(name);\n                                else if (body.scope.references(name)) {\n                                        extra = {};\n                                        if (!(scope.uses_eval || scope.uses_with))\n                                                name = extra[name] = scope.next_mangled();\n                                        else\n                                                extra[name] = name;\n                                }\n                                else name = null;\n                        }\n                }\n                body = with_scope(body.scope, function(){\n                        args = MAP(args, function(name){ return get_mangled(name) });\n                        return MAP(body, walk);\n                }, extra);\n                return [ this[0], name, args, body ];\n        };\n\n        function with_scope(s, cont, extra) {\n                var _scope = scope;\n                scope = s;\n                if (extra) for (var i in extra) if (HOP(extra, i)) {\n                        s.set_mangle(i, extra[i]);\n                }\n                for (var i in s.names) if (HOP(s.names, i)) {\n                        get_mangled(i, true);\n                }\n                var ret = cont();\n                ret.scope = s;\n                scope = _scope;\n                return ret;\n        };\n\n        function _vardefs(defs) {\n                return [ this[0], MAP(defs, function(d){\n                        return [ get_mangled(d[0]), walk(d[1]) ];\n                }) ];\n        };\n\n        function _breacont(label) {\n                if (label) return [ this[0], scope.labels.get_mangled(label) ];\n        };\n\n        return w.with_walkers({\n                \"function\": _lambda,\n                \"defun\": function() {\n                        // move function declarations to the top when\n                        // they are not in some block.\n                        var ast = _lambda.apply(this, arguments);\n                        switch (w.parent()[0]) {\n                            case \"toplevel\":\n                            case \"function\":\n                            case \"defun\":\n                                return MAP.at_top(ast);\n                        }\n                        return ast;\n                },\n                \"label\": function(label, stat) {\n                        if (scope.labels.refs[label]) return [\n                                this[0],\n                                scope.labels.get_mangled(label, true),\n                                walk(stat)\n                        ];\n                        return walk(stat);\n                },\n                \"break\": _breacont,\n                \"continue\": _breacont,\n                \"var\": _vardefs,\n                \"const\": _vardefs,\n                \"name\": function(name) {\n                        return get_define(name) || [ this[0], get_mangled(name) ];\n                },\n                \"try\": function(t, c, f) {\n                        return [ this[0],\n                                 MAP(t, walk),\n                                 c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,\n                                 f != null ? MAP(f, walk) : null ];\n                },\n                \"toplevel\": function(body) {\n                        var self = this;\n                        return with_scope(self.scope, function(){\n                                return [ self[0], MAP(body, walk) ];\n                        });\n                }\n        }, function() {\n                return walk(ast_add_scope(ast));\n        });\n};\n\n/* -----[\n   - compress foo[\"bar\"] into foo.bar,\n   - remove block brackets {} where possible\n   - join consecutive var declarations\n   - various optimizations for IFs:\n     - if (cond) foo(); else bar();  ==>  cond?foo():bar();\n     - if (cond) foo();  ==>  cond&&foo();\n     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw\n     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}\n   ]----- */\n\nvar warn = function(){};\n\nfunction best_of(ast1, ast2) {\n        return gen_code(ast1).length > gen_code(ast2[0] == \"stat\" ? ast2[1] : ast2).length ? ast2 : ast1;\n};\n\nfunction last_stat(b) {\n        if (b[0] == \"block\" && b[1] && b[1].length > 0)\n                return b[1][b[1].length - 1];\n        return b;\n}\n\nfunction aborts(t) {\n        if (t) switch (last_stat(t)[0]) {\n            case \"return\":\n            case \"break\":\n            case \"continue\":\n            case \"throw\":\n                return true;\n        }\n};\n\nfunction boolean_expr(expr) {\n        return ( (expr[0] == \"unary-prefix\"\n                  && member(expr[1], [ \"!\", \"delete\" ])) ||\n\n                 (expr[0] == \"binary\"\n                  && member(expr[1], [ \"in\", \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"<\", \"<=\", \">=\", \">\" ])) ||\n\n                 (expr[0] == \"binary\"\n                  && member(expr[1], [ \"&&\", \"||\" ])\n                  && boolean_expr(expr[2])\n                  && boolean_expr(expr[3])) ||\n\n                 (expr[0] == \"conditional\"\n                  && boolean_expr(expr[2])\n                  && boolean_expr(expr[3])) ||\n\n                 (expr[0] == \"assign\"\n                  && expr[1] === true\n                  && boolean_expr(expr[3])) ||\n\n                 (expr[0] == \"seq\"\n                  && boolean_expr(expr[expr.length - 1]))\n               );\n};\n\nfunction empty(b) {\n        return !b || (b[0] == \"block\" && (!b[1] || b[1].length == 0));\n};\n\nfunction is_string(node) {\n        return (node[0] == \"string\" ||\n                node[0] == \"unary-prefix\" && node[1] == \"typeof\" ||\n                node[0] == \"binary\" && node[1] == \"+\" &&\n                (is_string(node[2]) || is_string(node[3])));\n};\n\nvar when_constant = (function(){\n\n        var $NOT_CONSTANT = {};\n\n        // this can only evaluate constant expressions.  If it finds anything\n        // not constant, it throws $NOT_CONSTANT.\n        function evaluate(expr) {\n                switch (expr[0]) {\n                    case \"string\":\n                    case \"num\":\n                        return expr[1];\n                    case \"name\":\n                    case \"atom\":\n                        switch (expr[1]) {\n                            case \"true\": return true;\n                            case \"false\": return false;\n                            case \"null\": return null;\n                        }\n                        break;\n                    case \"unary-prefix\":\n                        switch (expr[1]) {\n                            case \"!\": return !evaluate(expr[2]);\n                            case \"typeof\": return typeof evaluate(expr[2]);\n                            case \"~\": return ~evaluate(expr[2]);\n                            case \"-\": return -evaluate(expr[2]);\n                            case \"+\": return +evaluate(expr[2]);\n                        }\n                        break;\n                    case \"binary\":\n                        var left = expr[2], right = expr[3];\n                        switch (expr[1]) {\n                            case \"&&\"         : return evaluate(left) &&         evaluate(right);\n                            case \"||\"         : return evaluate(left) ||         evaluate(right);\n                            case \"|\"          : return evaluate(left) |          evaluate(right);\n                            case \"&\"          : return evaluate(left) &          evaluate(right);\n                            case \"^\"          : return evaluate(left) ^          evaluate(right);\n                            case \"+\"          : return evaluate(left) +          evaluate(right);\n                            case \"*\"          : return evaluate(left) *          evaluate(right);\n                            case \"/\"          : return evaluate(left) /          evaluate(right);\n                            case \"%\"          : return evaluate(left) %          evaluate(right);\n                            case \"-\"          : return evaluate(left) -          evaluate(right);\n                            case \"<<\"         : return evaluate(left) <<         evaluate(right);\n                            case \">>\"         : return evaluate(left) >>         evaluate(right);\n                            case \">>>\"        : return evaluate(left) >>>        evaluate(right);\n                            case \"==\"         : return evaluate(left) ==         evaluate(right);\n                            case \"===\"        : return evaluate(left) ===        evaluate(right);\n                            case \"!=\"         : return evaluate(left) !=         evaluate(right);\n                            case \"!==\"        : return evaluate(left) !==        evaluate(right);\n                            case \"<\"          : return evaluate(left) <          evaluate(right);\n                            case \"<=\"         : return evaluate(left) <=         evaluate(right);\n                            case \">\"          : return evaluate(left) >          evaluate(right);\n                            case \">=\"         : return evaluate(left) >=         evaluate(right);\n                            case \"in\"         : return evaluate(left) in         evaluate(right);\n                            case \"instanceof\" : return evaluate(left) instanceof evaluate(right);\n                        }\n                }\n                throw $NOT_CONSTANT;\n        };\n\n        return function(expr, yes, no) {\n                try {\n                        var val = evaluate(expr), ast;\n                        switch (typeof val) {\n                            case \"string\": ast =  [ \"string\", val ]; break;\n                            case \"number\": ast =  [ \"num\", val ]; break;\n                            case \"boolean\": ast =  [ \"name\", String(val) ]; break;\n                            default:\n                                if (val === null) { ast = [ \"atom\", \"null\" ]; break; }\n                                throw new Error(\"Can't handle constant of type: \" + (typeof val));\n                        }\n                        return yes.call(expr, ast, val);\n                } catch(ex) {\n                        if (ex === $NOT_CONSTANT) {\n                                if (expr[0] == \"binary\"\n                                    && (expr[1] == \"===\" || expr[1] == \"!==\")\n                                    && ((is_string(expr[2]) && is_string(expr[3]))\n                                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {\n                                        expr[1] = expr[1].substr(0, 2);\n                                }\n                                else if (no && expr[0] == \"binary\"\n                                         && (expr[1] == \"||\" || expr[1] == \"&&\")) {\n                                    // the whole expression is not constant but the lval may be...\n                                    try {\n                                        var lval = evaluate(expr[2]);\n                                        expr = ((expr[1] == \"&&\" && (lval ? expr[3] : lval))    ||\n                                                (expr[1] == \"||\" && (lval ? lval    : expr[3])) ||\n                                                expr);\n                                    } catch(ex2) {\n                                        // IGNORE... lval is not constant\n                                    }\n                                }\n                                return no ? no.call(expr, expr) : null;\n                        }\n                        else throw ex;\n                }\n        };\n\n})();\n\nfunction warn_unreachable(ast) {\n        if (!empty(ast))\n                warn(\"Dropping unreachable code: \" + gen_code(ast, true));\n};\n\nfunction prepare_ifs(ast) {\n        var w = ast_walker(), walk = w.walk;\n        // In this first pass, we rewrite ifs which abort with no else with an\n        // if-else.  For example:\n        //\n        // if (x) {\n        //     blah();\n        //     return y;\n        // }\n        // foobar();\n        //\n        // is rewritten into:\n        //\n        // if (x) {\n        //     blah();\n        //     return y;\n        // } else {\n        //     foobar();\n        // }\n        function redo_if(statements) {\n                statements = MAP(statements, walk);\n\n                for (var i = 0; i < statements.length; ++i) {\n                        var fi = statements[i];\n                        if (fi[0] != \"if\") continue;\n\n                        if (fi[3] && walk(fi[3])) continue;\n\n                        var t = walk(fi[2]);\n                        if (!aborts(t)) continue;\n\n                        var conditional = walk(fi[1]);\n\n                        var e_body = redo_if(statements.slice(i + 1));\n                        var e = e_body.length == 1 ? e_body[0] : [ \"block\", e_body ];\n\n                        return statements.slice(0, i).concat([ [\n                                fi[0],          // \"if\"\n                                conditional,    // conditional\n                                t,              // then\n                                e               // else\n                        ] ]);\n                }\n\n                return statements;\n        };\n\n        function redo_if_lambda(name, args, body) {\n                body = redo_if(body);\n                return [ this[0], name, args, body ];\n        };\n\n        function redo_if_block(statements) {\n                return [ this[0], statements != null ? redo_if(statements) : null ];\n        };\n\n        return w.with_walkers({\n                \"defun\": redo_if_lambda,\n                \"function\": redo_if_lambda,\n                \"block\": redo_if_block,\n                \"splice\": redo_if_block,\n                \"toplevel\": function(statements) {\n                        return [ this[0], redo_if(statements) ];\n                },\n                \"try\": function(t, c, f) {\n                        return [\n                                this[0],\n                                redo_if(t),\n                                c != null ? [ c[0], redo_if(c[1]) ] : null,\n                                f != null ? redo_if(f) : null\n                        ];\n                }\n        }, function() {\n                return walk(ast);\n        });\n};\n\nfunction for_side_effects(ast, handler) {\n        var w = ast_walker(), walk = w.walk;\n        var $stop = {}, $restart = {};\n        function stop() { throw $stop };\n        function restart() { throw $restart };\n        function found(){ return handler.call(this, this, w, stop, restart) };\n        function unary(op) {\n                if (op == \"++\" || op == \"--\")\n                        return found.apply(this, arguments);\n        };\n        return w.with_walkers({\n                \"try\": found,\n                \"throw\": found,\n                \"return\": found,\n                \"new\": found,\n                \"switch\": found,\n                \"break\": found,\n                \"continue\": found,\n                \"assign\": found,\n                \"call\": found,\n                \"if\": found,\n                \"for\": found,\n                \"for-in\": found,\n                \"while\": found,\n                \"do\": found,\n                \"return\": found,\n                \"unary-prefix\": unary,\n                \"unary-postfix\": unary,\n                \"defun\": found\n        }, function(){\n                while (true) try {\n                        walk(ast);\n                        break;\n                } catch(ex) {\n                        if (ex === $stop) break;\n                        if (ex === $restart) continue;\n                        throw ex;\n                }\n        });\n};\n\nfunction ast_lift_variables(ast) {\n        var w = ast_walker(), walk = w.walk, scope;\n        function do_body(body, env) {\n                var _scope = scope;\n                scope = env;\n                body = MAP(body, walk);\n                var hash = {}, names = MAP(env.names, function(type, name){\n                        if (type != \"var\") return MAP.skip;\n                        if (!env.references(name)) return MAP.skip;\n                        hash[name] = true;\n                        return [ name ];\n                });\n                if (names.length > 0) {\n                        // looking for assignments to any of these variables.\n                        // we can save considerable space by moving the definitions\n                        // in the var declaration.\n                        for_side_effects([ \"block\", body ], function(ast, walker, stop, restart) {\n                                if (ast[0] == \"assign\"\n                                    && ast[1] === true\n                                    && ast[2][0] == \"name\"\n                                    && HOP(hash, ast[2][1])) {\n                                        // insert the definition into the var declaration\n                                        for (var i = names.length; --i >= 0;) {\n                                                if (names[i][0] == ast[2][1]) {\n                                                        if (names[i][1]) // this name already defined, we must stop\n                                                                stop();\n                                                        names[i][1] = ast[3]; // definition\n                                                        names.push(names.splice(i, 1)[0]);\n                                                        break;\n                                                }\n                                        }\n                                        // remove this assignment from the AST.\n                                        var p = walker.parent();\n                                        if (p[0] == \"seq\") {\n                                                var a = p[2];\n                                                a.unshift(0, p.length);\n                                                p.splice.apply(p, a);\n                                        }\n                                        else if (p[0] == \"stat\") {\n                                                p.splice(0, p.length, \"block\"); // empty statement\n                                        }\n                                        else {\n                                                stop();\n                                        }\n                                        restart();\n                                }\n                                stop();\n                        });\n                        body.unshift([ \"var\", names ]);\n                }\n                scope = _scope;\n                return body;\n        };\n        function _vardefs(defs) {\n                var ret = null;\n                for (var i = defs.length; --i >= 0;) {\n                        var d = defs[i];\n                        if (!d[1]) continue;\n                        d = [ \"assign\", true, [ \"name\", d[0] ], d[1] ];\n                        if (ret == null) ret = d;\n                        else ret = [ \"seq\", d, ret ];\n                }\n                if (ret == null) {\n                        if (w.parent()[0] == \"for-in\")\n                                return [ \"name\", defs[0][0] ];\n                        return MAP.skip;\n                }\n                return [ \"stat\", ret ];\n        };\n        function _toplevel(body) {\n                return [ this[0], do_body(body, this.scope) ];\n        };\n        return w.with_walkers({\n                \"function\": function(name, args, body){\n                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)\n                                args.pop();\n                        if (!body.scope.references(name)) name = null;\n                        return [ this[0], name, args, do_body(body, body.scope) ];\n                },\n                \"defun\": function(name, args, body){\n                        if (!scope.references(name)) return MAP.skip;\n                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)\n                                args.pop();\n                        return [ this[0], name, args, do_body(body, body.scope) ];\n                },\n                \"var\": _vardefs,\n                \"toplevel\": _toplevel\n        }, function(){\n                return walk(ast_add_scope(ast));\n        });\n};\n\nfunction ast_squeeze(ast, options) {\n        options = defaults(options, {\n                make_seqs   : true,\n                dead_code   : true,\n                no_warnings : false,\n                keep_comps  : true\n        });\n\n        var w = ast_walker(), walk = w.walk;\n\n        function negate(c) {\n                var not_c = [ \"unary-prefix\", \"!\", c ];\n                switch (c[0]) {\n                    case \"unary-prefix\":\n                        return c[1] == \"!\" && boolean_expr(c[2]) ? c[2] : not_c;\n                    case \"seq\":\n                        c = slice(c);\n                        c[c.length - 1] = negate(c[c.length - 1]);\n                        return c;\n                    case \"conditional\":\n                        return best_of(not_c, [ \"conditional\", c[1], negate(c[2]), negate(c[3]) ]);\n                    case \"binary\":\n                        var op = c[1], left = c[2], right = c[3];\n                        if (!options.keep_comps) switch (op) {\n                            case \"<=\"  : return [ \"binary\", \">\", left, right ];\n                            case \"<\"   : return [ \"binary\", \">=\", left, right ];\n                            case \">=\"  : return [ \"binary\", \"<\", left, right ];\n                            case \">\"   : return [ \"binary\", \"<=\", left, right ];\n                        }\n                        switch (op) {\n                            case \"==\"  : return [ \"binary\", \"!=\", left, right ];\n                            case \"!=\"  : return [ \"binary\", \"==\", left, right ];\n                            case \"===\" : return [ \"binary\", \"!==\", left, right ];\n                            case \"!==\" : return [ \"binary\", \"===\", left, right ];\n                            case \"&&\"  : return best_of(not_c, [ \"binary\", \"||\", negate(left), negate(right) ]);\n                            case \"||\"  : return best_of(not_c, [ \"binary\", \"&&\", negate(left), negate(right) ]);\n                        }\n                        break;\n                }\n                return not_c;\n        };\n\n        function make_conditional(c, t, e) {\n                var make_real_conditional = function() {\n                        if (c[0] == \"unary-prefix\" && c[1] == \"!\") {\n                                return e ? [ \"conditional\", c[2], e, t ] : [ \"binary\", \"||\", c[2], t ];\n                        } else {\n                                return e ? best_of(\n                                        [ \"conditional\", c, t, e ],\n                                        [ \"conditional\", negate(c), e, t ]\n                                ) : [ \"binary\", \"&&\", c, t ];\n                        }\n                };\n                // shortcut the conditional if the expression has a constant value\n                return when_constant(c, function(ast, val){\n                        warn_unreachable(val ? e : t);\n                        return          (val ? t : e);\n                }, make_real_conditional);\n        };\n\n        function rmblock(block) {\n                if (block != null && block[0] == \"block\" && block[1]) {\n                        if (block[1].length == 1)\n                                block = block[1][0];\n                        else if (block[1].length == 0)\n                                block = [ \"block\" ];\n                }\n                return block;\n        };\n\n        function _lambda(name, args, body) {\n                return [ this[0], name, args, tighten(body, \"lambda\") ];\n        };\n\n        // this function does a few things:\n        // 1. discard useless blocks\n        // 2. join consecutive var declarations\n        // 3. remove obviously dead code\n        // 4. transform consecutive statements using the comma operator\n        // 5. if block_type == \"lambda\" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }\n        function tighten(statements, block_type) {\n                statements = MAP(statements, walk);\n\n                statements = statements.reduce(function(a, stat){\n                        if (stat[0] == \"block\") {\n                                if (stat[1]) {\n                                        a.push.apply(a, stat[1]);\n                                }\n                        } else {\n                                a.push(stat);\n                        }\n                        return a;\n                }, []);\n\n                statements = (function(a, prev){\n                        statements.forEach(function(cur){\n                                if (prev && ((cur[0] == \"var\" && prev[0] == \"var\") ||\n                                             (cur[0] == \"const\" && prev[0] == \"const\"))) {\n                                        prev[1] = prev[1].concat(cur[1]);\n                                } else {\n                                        a.push(cur);\n                                        prev = cur;\n                                }\n                        });\n                        return a;\n                })([]);\n\n                if (options.dead_code) statements = (function(a, has_quit){\n                        statements.forEach(function(st){\n                                if (has_quit) {\n                                        if (st[0] == \"function\" || st[0] == \"defun\") {\n                                                a.push(st);\n                                        }\n                                        else if (st[0] == \"var\" || st[0] == \"const\") {\n                                                if (!options.no_warnings)\n                                                        warn(\"Variables declared in unreachable code\");\n                                                st[1] = MAP(st[1], function(def){\n                                                        if (def[1] && !options.no_warnings)\n                                                                warn_unreachable([ \"assign\", true, [ \"name\", def[0] ], def[1] ]);\n                                                        return [ def[0] ];\n                                                });\n                                                a.push(st);\n                                        }\n                                        else if (!options.no_warnings)\n                                                warn_unreachable(st);\n                                }\n                                else {\n                                        a.push(st);\n                                        if (member(st[0], [ \"return\", \"throw\", \"break\", \"continue\" ]))\n                                                has_quit = true;\n                                }\n                        });\n                        return a;\n                })([]);\n\n                if (options.make_seqs) statements = (function(a, prev) {\n                        statements.forEach(function(cur){\n                                if (prev && prev[0] == \"stat\" && cur[0] == \"stat\") {\n                                        prev[1] = [ \"seq\", prev[1], cur[1] ];\n                                } else {\n                                        a.push(cur);\n                                        prev = cur;\n                                }\n                        });\n                        if (a.length >= 2\n                            && a[a.length-2][0] == \"stat\"\n                            && (a[a.length-1][0] == \"return\" || a[a.length-1][0] == \"throw\")\n                            && a[a.length-1][1])\n                        {\n                                a.splice(a.length - 2, 2,\n                                         [ a[a.length-1][0],\n                                           [ \"seq\", a[a.length-2][1], a[a.length-1][1] ]]);\n                        }\n                        return a;\n                })([]);\n\n                // this increases jQuery by 1K.  Probably not such a good idea after all..\n                // part of this is done in prepare_ifs anyway.\n                // if (block_type == \"lambda\") statements = (function(i, a, stat){\n                //         while (i < statements.length) {\n                //                 stat = statements[i++];\n                //                 if (stat[0] == \"if\" && !stat[3]) {\n                //                         if (stat[2][0] == \"return\" && stat[2][1] == null) {\n                //                                 a.push(make_if(negate(stat[1]), [ \"block\", statements.slice(i) ]));\n                //                                 break;\n                //                         }\n                //                         var last = last_stat(stat[2]);\n                //                         if (last[0] == \"return\" && last[1] == null) {\n                //                                 a.push(make_if(stat[1], [ \"block\", stat[2][1].slice(0, -1) ], [ \"block\", statements.slice(i) ]));\n                //                                 break;\n                //                         }\n                //                 }\n                //                 a.push(stat);\n                //         }\n                //         return a;\n                // })(0, []);\n\n                return statements;\n        };\n\n        function make_if(c, t, e) {\n                return when_constant(c, function(ast, val){\n                        if (val) {\n                                t = walk(t);\n                                warn_unreachable(e);\n                                return t || [ \"block\" ];\n                        } else {\n                                e = walk(e);\n                                warn_unreachable(t);\n                                return e || [ \"block\" ];\n                        }\n                }, function() {\n                        return make_real_if(c, t, e);\n                });\n        };\n\n        function abort_else(c, t, e) {\n                var ret = [ [ \"if\", negate(c), e ] ];\n                if (t[0] == \"block\") {\n                        if (t[1]) ret = ret.concat(t[1]);\n                } else {\n                        ret.push(t);\n                }\n                return walk([ \"block\", ret ]);\n        };\n\n        function make_real_if(c, t, e) {\n                c = walk(c);\n                t = walk(t);\n                e = walk(e);\n\n                if (empty(t)) {\n                        c = negate(c);\n                        t = e;\n                        e = null;\n                } else if (empty(e)) {\n                        e = null;\n                } else {\n                        // if we have both else and then, maybe it makes sense to switch them?\n                        (function(){\n                                var a = gen_code(c);\n                                var n = negate(c);\n                                var b = gen_code(n);\n                                if (b.length < a.length) {\n                                        var tmp = t;\n                                        t = e;\n                                        e = tmp;\n                                        c = n;\n                                }\n                        })();\n                }\n                if (empty(e) && empty(t))\n                        return [ \"stat\", c ];\n                var ret = [ \"if\", c, t, e ];\n                if (t[0] == \"if\" && empty(t[3]) && empty(e)) {\n                        ret = best_of(ret, walk([ \"if\", [ \"binary\", \"&&\", c, t[1] ], t[2] ]));\n                }\n                else if (t[0] == \"stat\") {\n                        if (e) {\n                                if (e[0] == \"stat\")\n                                        ret = best_of(ret, [ \"stat\", make_conditional(c, t[1], e[1]) ]);\n                                else if (aborts(e))\n                                        ret = abort_else(c, t, e);\n                        }\n                        else {\n                                ret = best_of(ret, [ \"stat\", make_conditional(c, t[1]) ]);\n                        }\n                }\n                else if (e && t[0] == e[0] && (t[0] == \"return\" || t[0] == \"throw\") && t[1] && e[1]) {\n                        ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);\n                }\n                else if (e && aborts(t)) {\n                        ret = [ [ \"if\", c, t ] ];\n                        if (e[0] == \"block\") {\n                                if (e[1]) ret = ret.concat(e[1]);\n                        }\n                        else {\n                                ret.push(e);\n                        }\n                        ret = walk([ \"block\", ret ]);\n                }\n                else if (t && aborts(e)) {\n                        ret = abort_else(c, t, e);\n                }\n                return ret;\n        };\n\n        function _do_while(cond, body) {\n                return when_constant(cond, function(cond, val){\n                        if (!val) {\n                                warn_unreachable(body);\n                                return [ \"block\" ];\n                        } else {\n                                return [ \"for\", null, null, null, walk(body) ];\n                        }\n                });\n        };\n\n        return w.with_walkers({\n                \"sub\": function(expr, subscript) {\n                        if (subscript[0] == \"string\") {\n                                var name = subscript[1];\n                                if (is_identifier(name))\n                                        return [ \"dot\", walk(expr), name ];\n                                else if (/^[1-9][0-9]*$/.test(name) || name === \"0\")\n                                        return [ \"sub\", walk(expr), [ \"num\", parseInt(name, 10) ] ];\n                        }\n                },\n                \"if\": make_if,\n                \"toplevel\": function(body) {\n                        return [ \"toplevel\", tighten(body) ];\n                },\n                \"switch\": function(expr, body) {\n                        var last = body.length - 1;\n                        return [ \"switch\", walk(expr), MAP(body, function(branch, i){\n                                var block = tighten(branch[1]);\n                                if (i == last && block.length > 0) {\n                                        var node = block[block.length - 1];\n                                        if (node[0] == \"break\" && !node[1])\n                                                block.pop();\n                                }\n                                return [ branch[0] ? walk(branch[0]) : null, block ];\n                        }) ];\n                },\n                \"function\": _lambda,\n                \"defun\": _lambda,\n                \"block\": function(body) {\n                        if (body) return rmblock([ \"block\", tighten(body) ]);\n                },\n                \"binary\": function(op, left, right) {\n                        return when_constant([ \"binary\", op, walk(left), walk(right) ], function yes(c){\n                                return best_of(walk(c), this);\n                        }, function no() {\n                                return function(){\n                                        if(op != \"==\" && op != \"!=\") return;\n                                        var l = walk(left), r = walk(right);\n                                        if(l && l[0] == \"unary-prefix\" && l[1] == \"!\" && l[2][0] == \"num\")\n                                                left = ['num', +!l[2][1]];\n                                        else if (r && r[0] == \"unary-prefix\" && r[1] == \"!\" && r[2][0] == \"num\")\n                                                right = ['num', +!r[2][1]];\n                                        return [\"binary\", op, left, right];\n                                }() || this;\n                        });\n                },\n                \"conditional\": function(c, t, e) {\n                        return make_conditional(walk(c), walk(t), walk(e));\n                },\n                \"try\": function(t, c, f) {\n                        return [\n                                \"try\",\n                                tighten(t),\n                                c != null ? [ c[0], tighten(c[1]) ] : null,\n                                f != null ? tighten(f) : null\n                        ];\n                },\n                \"unary-prefix\": function(op, expr) {\n                        expr = walk(expr);\n                        var ret = [ \"unary-prefix\", op, expr ];\n                        if (op == \"!\")\n                                ret = best_of(ret, negate(expr));\n                        return when_constant(ret, function(ast, val){\n                                return walk(ast); // it's either true or false, so minifies to !0 or !1\n                        }, function() { return ret });\n                },\n                \"name\": function(name) {\n                        switch (name) {\n                            case \"true\": return [ \"unary-prefix\", \"!\", [ \"num\", 0 ]];\n                            case \"false\": return [ \"unary-prefix\", \"!\", [ \"num\", 1 ]];\n                        }\n                },\n                \"while\": _do_while,\n                \"assign\": function(op, lvalue, rvalue) {\n                        lvalue = walk(lvalue);\n                        rvalue = walk(rvalue);\n                        var okOps = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];\n                        if (op === true && lvalue[0] === \"name\" && rvalue[0] === \"binary\" &&\n                            ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === \"name\" &&\n                            rvalue[2][1] === lvalue[1]) {\n                                return [ this[0], rvalue[1], lvalue, rvalue[3] ]\n                        }\n                        return [ this[0], op, lvalue, rvalue ];\n                }\n        }, function() {\n                for (var i = 0; i < 2; ++i) {\n                        ast = prepare_ifs(ast);\n                        ast = walk(ast);\n                }\n                return ast;\n        });\n};\n\n/* -----[ re-generate code from the AST ]----- */\n\nvar DOT_CALL_NO_PARENS = jsp.array_to_hash([\n        \"name\",\n        \"array\",\n        \"object\",\n        \"string\",\n        \"dot\",\n        \"sub\",\n        \"call\",\n        \"regexp\",\n        \"defun\"\n]);\n\nfunction make_string(str, ascii_only) {\n        var dq = 0, sq = 0;\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\t\\x22\\x27\\u2028\\u2029\\0]/g, function(s){\n                switch (s) {\n                    case \"\\\\\": return \"\\\\\\\\\";\n                    case \"\\b\": return \"\\\\b\";\n                    case \"\\f\": return \"\\\\f\";\n                    case \"\\n\": return \"\\\\n\";\n                    case \"\\r\": return \"\\\\r\";\n                    case \"\\t\": return \"\\\\t\";\n                    case \"\\u2028\": return \"\\\\u2028\";\n                    case \"\\u2029\": return \"\\\\u2029\";\n                    case '\"': ++dq; return '\"';\n                    case \"'\": ++sq; return \"'\";\n                    case \"\\0\": return \"\\\\0\";\n                }\n                return s;\n        });\n        if (ascii_only) str = to_ascii(str);\n        if (dq > sq) return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n        else return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n};\n\nfunction to_ascii(str) {\n        return str.replace(/[\\u0080-\\uffff]/g, function(ch) {\n                var code = ch.charCodeAt(0).toString(16);\n                while (code.length < 4) code = \"0\" + code;\n                return \"\\\\u\" + code;\n        });\n};\n\nvar SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([ \"if\", \"while\", \"do\", \"for\", \"for-in\", \"with\" ]);\n\nfunction gen_code(ast, options) {\n        options = defaults(options, {\n                indent_start : 0,\n                indent_level : 4,\n                quote_keys   : false,\n                space_colon  : false,\n                beautify     : false,\n                ascii_only   : false,\n                inline_script: false\n        });\n        var beautify = !!options.beautify;\n        var indentation = 0,\n            newline = beautify ? \"\\n\" : \"\",\n            space = beautify ? \" \" : \"\";\n\n        function encode_string(str) {\n                var ret = make_string(str, options.ascii_only);\n                if (options.inline_script)\n                        ret = ret.replace(/<\\x2fscript([>\\/\\t\\n\\f\\r ])/gi, \"<\\\\/script$1\");\n                return ret;\n        };\n\n        function make_name(name) {\n                name = name.toString();\n                if (options.ascii_only)\n                        name = to_ascii(name);\n                return name;\n        };\n\n        function indent(line) {\n                if (line == null)\n                        line = \"\";\n                if (beautify)\n                        line = repeat_string(\" \", options.indent_start + indentation * options.indent_level) + line;\n                return line;\n        };\n\n        function with_indent(cont, incr) {\n                if (incr == null) incr = 1;\n                indentation += incr;\n                try { return cont.apply(null, slice(arguments, 1)); }\n                finally { indentation -= incr; }\n        };\n\n        function add_spaces(a) {\n                if (beautify)\n                        return a.join(\" \");\n                var b = [];\n                for (var i = 0; i < a.length; ++i) {\n                        var next = a[i + 1];\n                        b.push(a[i]);\n                        if (next &&\n                            ((/[a-z0-9_\\x24]$/i.test(a[i].toString()) && /^[a-z0-9_\\x24]/i.test(next.toString())) ||\n                             (/[\\+\\-]$/.test(a[i].toString()) && /^[\\+\\-]/.test(next.toString())))) {\n                                b.push(\" \");\n                        }\n                }\n                return b.join(\"\");\n        };\n\n        function add_commas(a) {\n                return a.join(\",\" + space);\n        };\n\n        function parenthesize(expr) {\n                var gen = make(expr);\n                for (var i = 1; i < arguments.length; ++i) {\n                        var el = arguments[i];\n                        if ((el instanceof Function && el(expr)) || expr[0] == el)\n                                return \"(\" + gen + \")\";\n                }\n                return gen;\n        };\n\n        function best_of(a) {\n                if (a.length == 1) {\n                        return a[0];\n                }\n                if (a.length == 2) {\n                        var b = a[1];\n                        a = a[0];\n                        return a.length <= b.length ? a : b;\n                }\n                return best_of([ a[0], best_of(a.slice(1)) ]);\n        };\n\n        function needs_parens(expr) {\n                if (expr[0] == \"function\" || expr[0] == \"object\") {\n                        // dot/call on a literal function requires the\n                        // function literal itself to be parenthesized\n                        // only if it's the first \"thing\" in a\n                        // statement.  This means that the parent is\n                        // \"stat\", but it could also be a \"seq\" and\n                        // we're the first in this \"seq\" and the\n                        // parent is \"stat\", and so on.  Messy stuff,\n                        // but it worths the trouble.\n                        var a = slice(w.stack()), self = a.pop(), p = a.pop();\n                        while (p) {\n                                if (p[0] == \"stat\") return true;\n                                if (((p[0] == \"seq\" || p[0] == \"call\" || p[0] == \"dot\" || p[0] == \"sub\" || p[0] == \"conditional\") && p[1] === self) ||\n                                    ((p[0] == \"binary\" || p[0] == \"assign\" || p[0] == \"unary-postfix\") && p[2] === self)) {\n                                        self = p;\n                                        p = a.pop();\n                                } else {\n                                        return false;\n                                }\n                        }\n                }\n                return !HOP(DOT_CALL_NO_PARENS, expr[0]);\n        };\n\n        function make_num(num) {\n                var str = num.toString(10), a = [ str.replace(/^0\\./, \".\") ], m;\n                if (Math.floor(num) === num) {\n                        if (num >= 0) {\n                                a.push(\"0x\" + num.toString(16).toLowerCase(), // probably pointless\n                                       \"0\" + num.toString(8)); // same.\n                        } else {\n                                a.push(\"-0x\" + (-num).toString(16).toLowerCase(), // probably pointless\n                                       \"-0\" + (-num).toString(8)); // same.\n                        }\n                        if ((m = /^(.*?)(0+)$/.exec(num))) {\n                                a.push(m[1] + \"e\" + m[2].length);\n                        }\n                } else if ((m = /^0?\\.(0+)(.*)$/.exec(num))) {\n                        a.push(m[2] + \"e-\" + (m[1].length + m[2].length),\n                               str.substr(str.indexOf(\".\")));\n                }\n                return best_of(a);\n        };\n\n        var w = ast_walker();\n        var make = w.walk;\n        return w.with_walkers({\n                \"string\": encode_string,\n                \"num\": make_num,\n                \"name\": make_name,\n                \"debugger\": function(){ return \"debugger\" },\n                \"toplevel\": function(statements) {\n                        return make_block_statements(statements)\n                                .join(newline + newline);\n                },\n                \"splice\": function(statements) {\n                        var parent = w.parent();\n                        if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {\n                                // we need block brackets in this case\n                                return make_block.apply(this, arguments);\n                        } else {\n                                return MAP(make_block_statements(statements, true),\n                                           function(line, i) {\n                                                   // the first line is already indented\n                                                   return i > 0 ? indent(line) : line;\n                                           }).join(newline);\n                        }\n                },\n                \"block\": make_block,\n                \"var\": function(defs) {\n                        return \"var \" + add_commas(MAP(defs, make_1vardef)) + \";\";\n                },\n                \"const\": function(defs) {\n                        return \"const \" + add_commas(MAP(defs, make_1vardef)) + \";\";\n                },\n                \"try\": function(tr, ca, fi) {\n                        var out = [ \"try\", make_block(tr) ];\n                        if (ca) out.push(\"catch\", \"(\" + ca[0] + \")\", make_block(ca[1]));\n                        if (fi) out.push(\"finally\", make_block(fi));\n                        return add_spaces(out);\n                },\n                \"throw\": function(expr) {\n                        return add_spaces([ \"throw\", make(expr) ]) + \";\";\n                },\n                \"new\": function(ctor, args) {\n                        args = args.length > 0 ? \"(\" + add_commas(MAP(args, function(expr){\n                                return parenthesize(expr, \"seq\");\n                        })) + \")\" : \"\";\n                        return add_spaces([ \"new\", parenthesize(ctor, \"seq\", \"binary\", \"conditional\", \"assign\", function(expr){\n                                var w = ast_walker(), has_call = {};\n                                try {\n                                        w.with_walkers({\n                                                \"call\": function() { throw has_call },\n                                                \"function\": function() { return this }\n                                        }, function(){\n                                                w.walk(expr);\n                                        });\n                                } catch(ex) {\n                                        if (ex === has_call)\n                                                return true;\n                                        throw ex;\n                                }\n                        }) + args ]);\n                },\n                \"switch\": function(expr, body) {\n                        return add_spaces([ \"switch\", \"(\" + make(expr) + \")\", make_switch_block(body) ]);\n                },\n                \"break\": function(label) {\n                        var out = \"break\";\n                        if (label != null)\n                                out += \" \" + make_name(label);\n                        return out + \";\";\n                },\n                \"continue\": function(label) {\n                        var out = \"continue\";\n                        if (label != null)\n                                out += \" \" + make_name(label);\n                        return out + \";\";\n                },\n                \"conditional\": function(co, th, el) {\n                        return add_spaces([ parenthesize(co, \"assign\", \"seq\", \"conditional\"), \"?\",\n                                            parenthesize(th, \"seq\"), \":\",\n                                            parenthesize(el, \"seq\") ]);\n                },\n                \"assign\": function(op, lvalue, rvalue) {\n                        if (op && op !== true) op += \"=\";\n                        else op = \"=\";\n                        return add_spaces([ make(lvalue), op, parenthesize(rvalue, \"seq\") ]);\n                },\n                \"dot\": function(expr) {\n                        var out = make(expr), i = 1;\n                        if (expr[0] == \"num\") {\n                                if (!/\\./.test(expr[1]))\n                                        out += \".\";\n                        } else if (needs_parens(expr))\n                                out = \"(\" + out + \")\";\n                        while (i < arguments.length)\n                                out += \".\" + make_name(arguments[i++]);\n                        return out;\n                },\n                \"call\": function(func, args) {\n                        var f = make(func);\n                        if (f.charAt(0) != \"(\" && needs_parens(func))\n                                f = \"(\" + f + \")\";\n                        return f + \"(\" + add_commas(MAP(args, function(expr){\n                                return parenthesize(expr, \"seq\");\n                        })) + \")\";\n                },\n                \"function\": make_function,\n                \"defun\": make_function,\n                \"if\": function(co, th, el) {\n                        var out = [ \"if\", \"(\" + make(co) + \")\", el ? make_then(th) : make(th) ];\n                        if (el) {\n                                out.push(\"else\", make(el));\n                        }\n                        return add_spaces(out);\n                },\n                \"for\": function(init, cond, step, block) {\n                        var out = [ \"for\" ];\n                        init = (init != null ? make(init) : \"\").replace(/;*\\s*$/, \";\" + space);\n                        cond = (cond != null ? make(cond) : \"\").replace(/;*\\s*$/, \";\" + space);\n                        step = (step != null ? make(step) : \"\").replace(/;*\\s*$/, \"\");\n                        var args = init + cond + step;\n                        if (args == \"; ; \") args = \";;\";\n                        out.push(\"(\" + args + \")\", make(block));\n                        return add_spaces(out);\n                },\n                \"for-in\": function(vvar, key, hash, block) {\n                        return add_spaces([ \"for\", \"(\" +\n                                            (vvar ? make(vvar).replace(/;+$/, \"\") : make(key)),\n                                            \"in\",\n                                            make(hash) + \")\", make(block) ]);\n                },\n                \"while\": function(condition, block) {\n                        return add_spaces([ \"while\", \"(\" + make(condition) + \")\", make(block) ]);\n                },\n                \"do\": function(condition, block) {\n                        return add_spaces([ \"do\", make(block), \"while\", \"(\" + make(condition) + \")\" ]) + \";\";\n                },\n                \"return\": function(expr) {\n                        var out = [ \"return\" ];\n                        if (expr != null) out.push(make(expr));\n                        return add_spaces(out) + \";\";\n                },\n                \"binary\": function(operator, lvalue, rvalue) {\n                        var left = make(lvalue), right = make(rvalue);\n                        // XXX: I'm pretty sure other cases will bite here.\n                        //      we need to be smarter.\n                        //      adding parens all the time is the safest bet.\n                        if (member(lvalue[0], [ \"assign\", \"conditional\", \"seq\" ]) ||\n                            lvalue[0] == \"binary\" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] ||\n                            lvalue[0] == \"function\" && needs_parens(this)) {\n                                left = \"(\" + left + \")\";\n                        }\n                        if (member(rvalue[0], [ \"assign\", \"conditional\", \"seq\" ]) ||\n                            rvalue[0] == \"binary\" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&\n                            !(rvalue[1] == operator && member(operator, [ \"&&\", \"||\", \"*\" ]))) {\n                                right = \"(\" + right + \")\";\n                        }\n                        else if (!beautify && options.inline_script && (operator == \"<\" || operator == \"<<\")\n                                 && rvalue[0] == \"regexp\" && /^script/i.test(rvalue[1])) {\n                                right = \" \" + right;\n                        }\n                        return add_spaces([ left, operator, right ]);\n                },\n                \"unary-prefix\": function(operator, expr) {\n                        var val = make(expr);\n                        if (!(expr[0] == \"num\" || (expr[0] == \"unary-prefix\" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))\n                                val = \"(\" + val + \")\";\n                        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? \" \" : \"\") + val;\n                },\n                \"unary-postfix\": function(operator, expr) {\n                        var val = make(expr);\n                        if (!(expr[0] == \"num\" || (expr[0] == \"unary-postfix\" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))\n                                val = \"(\" + val + \")\";\n                        return val + operator;\n                },\n                \"sub\": function(expr, subscript) {\n                        var hash = make(expr);\n                        if (needs_parens(expr))\n                                hash = \"(\" + hash + \")\";\n                        return hash + \"[\" + make(subscript) + \"]\";\n                },\n                \"object\": function(props) {\n                        var obj_needs_parens = needs_parens(this);\n                        if (props.length == 0)\n                                return obj_needs_parens ? \"({})\" : \"{}\";\n                        var out = \"{\" + newline + with_indent(function(){\n                                return MAP(props, function(p){\n                                        if (p.length == 3) {\n                                                // getter/setter.  The name is in p[0], the arg.list in p[1][2], the\n                                                // body in p[1][3] and type (\"get\" / \"set\") in p[2].\n                                                return indent(make_function(p[0], p[1][2], p[1][3], p[2]));\n                                        }\n                                        var key = p[0], val = parenthesize(p[1], \"seq\");\n                                        if (options.quote_keys) {\n                                                key = encode_string(key);\n                                        } else if ((typeof key == \"number\" || !beautify && +key + \"\" == key)\n                                                   && parseFloat(key) >= 0) {\n                                                key = make_num(+key);\n                                        } else if (!is_identifier(key)) {\n                                                key = encode_string(key);\n                                        }\n                                        return indent(add_spaces(beautify && options.space_colon\n                                                                 ? [ key, \":\", val ]\n                                                                 : [ key + \":\", val ]));\n                                }).join(\",\" + newline);\n                        }) + newline + indent(\"}\");\n                        return obj_needs_parens ? \"(\" + out + \")\" : out;\n                },\n                \"regexp\": function(rx, mods) {\n                        return \"/\" + rx + \"/\" + mods;\n                },\n                \"array\": function(elements) {\n                        if (elements.length == 0) return \"[]\";\n                        return add_spaces([ \"[\", add_commas(MAP(elements, function(el, i){\n                                if (!beautify && el[0] == \"atom\" && el[1] == \"undefined\") return i === elements.length - 1 ? \",\" : \"\";\n                                return parenthesize(el, \"seq\");\n                        })), \"]\" ]);\n                },\n                \"stat\": function(stmt) {\n                        return make(stmt).replace(/;*\\s*$/, \";\");\n                },\n                \"seq\": function() {\n                        return add_commas(MAP(slice(arguments), make));\n                },\n                \"label\": function(name, block) {\n                        return add_spaces([ make_name(name), \":\", make(block) ]);\n                },\n                \"with\": function(expr, block) {\n                        return add_spaces([ \"with\", \"(\" + make(expr) + \")\", make(block) ]);\n                },\n                \"atom\": function(name) {\n                        return make_name(name);\n                }\n        }, function(){ return make(ast) });\n\n        // The squeezer replaces \"block\"-s that contain only a single\n        // statement with the statement itself; technically, the AST\n        // is correct, but this can create problems when we output an\n        // IF having an ELSE clause where the THEN clause ends in an\n        // IF *without* an ELSE block (then the outer ELSE would refer\n        // to the inner IF).  This function checks for this case and\n        // adds the block brackets if needed.\n        function make_then(th) {\n                if (th == null) return \";\";\n                if (th[0] == \"do\") {\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/57\n                        // IE croaks with \"syntax error\" on code like this:\n                        //     if (foo) do ... while(cond); else ...\n                        // we need block brackets around do/while\n                        return make_block([ th ]);\n                }\n                var b = th;\n                while (true) {\n                        var type = b[0];\n                        if (type == \"if\") {\n                                if (!b[3])\n                                        // no else, we must add the block\n                                        return make([ \"block\", [ th ]]);\n                                b = b[3];\n                        }\n                        else if (type == \"while\" || type == \"do\") b = b[2];\n                        else if (type == \"for\" || type == \"for-in\") b = b[4];\n                        else break;\n                }\n                return make(th);\n        };\n\n        function make_function(name, args, body, keyword) {\n                var out = keyword || \"function\";\n                if (name) {\n                        out += \" \" + make_name(name);\n                }\n                out += \"(\" + add_commas(MAP(args, make_name)) + \")\";\n                out = add_spaces([ out, make_block(body) ]);\n                return needs_parens(this) ? \"(\" + out + \")\" : out;\n        };\n\n        function must_has_semicolon(node) {\n                switch (node[0]) {\n                    case \"with\":\n                    case \"while\":\n                        return empty(node[2]); // `with' or `while' with empty body?\n                    case \"for\":\n                    case \"for-in\":\n                        return empty(node[4]); // `for' with empty body?\n                    case \"if\":\n                        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'\n                        if (node[3]) {\n                                if (empty(node[3])) return true; // `else' present but empty\n                                return must_has_semicolon(node[3]); // dive into the `else' branch\n                        }\n                        return must_has_semicolon(node[2]); // dive into the `then' branch\n                }\n        };\n\n        function make_block_statements(statements, noindent) {\n                for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {\n                        var stat = statements[i];\n                        var code = make(stat);\n                        if (code != \";\") {\n                                if (!beautify && i == last && !must_has_semicolon(stat)) {\n                                        code = code.replace(/;+\\s*$/, \"\");\n                                }\n                                a.push(code);\n                        }\n                }\n                return noindent ? a : MAP(a, indent);\n        };\n\n        function make_switch_block(body) {\n                var n = body.length;\n                if (n == 0) return \"{}\";\n                return \"{\" + newline + MAP(body, function(branch, i){\n                        var has_body = branch[1].length > 0, code = with_indent(function(){\n                                return indent(branch[0]\n                                              ? add_spaces([ \"case\", make(branch[0]) + \":\" ])\n                                              : \"default:\");\n                        }, 0.5) + (has_body ? newline + with_indent(function(){\n                                return make_block_statements(branch[1]).join(newline);\n                        }) : \"\");\n                        if (!beautify && has_body && i < n - 1)\n                                code += \";\";\n                        return code;\n                }).join(newline) + newline + indent(\"}\");\n        };\n\n        function make_block(statements) {\n                if (!statements) return \";\";\n                if (statements.length == 0) return \"{}\";\n                return \"{\" + newline + with_indent(function(){\n                        return make_block_statements(statements).join(newline);\n                }) + newline + indent(\"}\");\n        };\n\n        function make_1vardef(def) {\n                var name = def[0], val = def[1];\n                if (val != null)\n                        name = add_spaces([ make_name(name), \"=\", parenthesize(val, \"seq\") ]);\n                return name;\n        };\n\n};\n\nfunction split_lines(code, max_line_length) {\n        var splits = [ 0 ];\n        jsp.parse(function(){\n                var next_token = jsp.tokenizer(code);\n                var last_split = 0;\n                var prev_token;\n                function current_length(tok) {\n                        return tok.pos - last_split;\n                };\n                function split_here(tok) {\n                        last_split = tok.pos;\n                        splits.push(last_split);\n                };\n                function custom(){\n                        var tok = next_token.apply(this, arguments);\n                        out: {\n                                if (prev_token) {\n                                        if (prev_token.type == \"keyword\") break out;\n                                }\n                                if (current_length(tok) > max_line_length) {\n                                        switch (tok.type) {\n                                            case \"keyword\":\n                                            case \"atom\":\n                                            case \"name\":\n                                            case \"punc\":\n                                                split_here(tok);\n                                                break out;\n                                        }\n                                }\n                        }\n                        prev_token = tok;\n                        return tok;\n                };\n                custom.context = function() {\n                        return next_token.context.apply(this, arguments);\n                };\n                return custom;\n        }());\n        return splits.map(function(pos, i){\n                return code.substring(pos, splits[i + 1] || code.length);\n        }).join(\"\\n\");\n};\n\n/* -----[ Utilities ]----- */\n\nfunction repeat_string(str, i) {\n        if (i <= 0) return \"\";\n        if (i == 1) return str;\n        var d = repeat_string(str, i >> 1);\n        d += d;\n        if (i & 1) d += str;\n        return d;\n};\n\nfunction defaults(args, defs) {\n        var ret = {};\n        if (args === true)\n                args = {};\n        for (var i in defs) if (HOP(defs, i)) {\n                ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];\n        }\n        return ret;\n};\n\nfunction is_identifier(name) {\n        return /^[a-z_$][a-z0-9_$]*$/i.test(name)\n                && name != \"this\"\n                && !HOP(jsp.KEYWORDS_ATOM, name)\n                && !HOP(jsp.RESERVED_WORDS, name)\n                && !HOP(jsp.KEYWORDS, name);\n};\n\nfunction HOP(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\n// some utilities\n\nvar MAP;\n\n(function(){\n        MAP = function(a, f, o) {\n                var ret = [], top = [], i;\n                function doit() {\n                        var val = f.call(o, a[i], i);\n                        if (val instanceof AtTop) {\n                                val = val.v;\n                                if (val instanceof Splice) {\n                                        top.push.apply(top, val.v);\n                                } else {\n                                        top.push(val);\n                                }\n                        }\n                        else if (val != skip) {\n                                if (val instanceof Splice) {\n                                        ret.push.apply(ret, val.v);\n                                } else {\n                                        ret.push(val);\n                                }\n                        }\n                };\n                if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();\n                else for (i in a) if (HOP(a, i)) doit();\n                return top.concat(ret);\n        };\n        MAP.at_top = function(val) { return new AtTop(val) };\n        MAP.splice = function(val) { return new Splice(val) };\n        var skip = MAP.skip = {};\n        function AtTop(val) { this.v = val };\n        function Splice(val) { this.v = val };\n})();\n\n/* -----[ Exports ]----- */\n\nexports.ast_walker = ast_walker;\nexports.ast_mangle = ast_mangle;\nexports.ast_squeeze = ast_squeeze;\nexports.ast_lift_variables = ast_lift_variables;\nexports.gen_code = gen_code;\nexports.ast_add_scope = ast_add_scope;\nexports.set_logger = function(logger) { warn = logger };\nexports.make_string = make_string;\nexports.split_lines = split_lines;\nexports.MAP = MAP;\n\n// keep this last!\nexports.ast_squeeze_more = require(\"./squeeze-more\").ast_squeeze_more;\n"]},"metadata":{},"sourceType":"script"}