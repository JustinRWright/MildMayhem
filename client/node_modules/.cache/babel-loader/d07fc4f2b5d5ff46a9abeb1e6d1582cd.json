{"ast":null,"code":"import Phaser from 'phaser';\nexport default class lightningHB extends Phaser.Physics.Arcade.Sprite {\n  constructor(scene, x, y, texture, {\n    owner,\n    animationSprite,\n    Olength\n  } = {}) {\n    super(scene, x, y, texture); //Adds sprite to screen\n\n    scene.add.existing(this); //Adds physics to sprite\n\n    scene.physics.add.existing(this);\n    this.setCircle(16); //The sprite is an invisible hitbox\n\n    this.setVisible(false);\n    this.texture = texture; //Track which animation sprite this lightning hitbox belongs to. This is needed for collisions.\n\n    this.animationSprite = animationSprite;\n    this.owner = owner; //Center \n\n    this.x = x + owner.width - 8;\n    this.y = y + owner.height - 8;\n    this.oscillationLength = Olength;\n    this.startingOlength = Olength;\n    this.orientationx = owner.getOrientationVector().x;\n    this.orientationy = owner.getOrientationVector().y; //Creates a recursive, growing oscillation distance that accelerates with the lightning \n    //bolt. \n    //This allows for an illision of a diagonal, rotating hitbox that arcade physics cannot create,\n    //I'd rather not have to use matter just for diagonal hitboxes,\n    //or resort to custom hitboxes and collision detection in the update loop\n\n    this.scene.tweens.add({\n      targets: this,\n      x: this.x + this.oscillationLength * this.orientationx,\n      y: this.y + this.oscillationLength * this.orientationy,\n      duration: 100,\n      yoyo: true,\n      onComplete: onCompleteHandler,\n      onCompleteParams: [this.scene]\n    }); //Recursive callback function that allows for a growing oscillation length to our circular hitbox, simulating a non AABB hitbox effectively\n\n    function onCompleteHandler(tween, targets, scene) {\n      let self = targets[0];\n\n      if (self) {\n        //Each iteration, this multiplies the distance,\n        //an exponential growth occurs\n        self.oscillationLength *= 3; //This runs while the hitboxes don't move at max length\n\n        if (self.oscillationLength <= 1000 * self.startingOlength / 100) {\n          self.scene.tweens.add({\n            targets: self,\n            x: self.x + self.oscillationLength * self.orientationx,\n            y: self.y + self.oscillationLength * self.orientationy,\n            duration: 100,\n            yoyo: true,\n            onComplete: onCompleteHandler\n          });\n        } //This runs once the hitboxes have reached the maximum range of movement\n        else {\n            if (self) {\n              self.scene.tweens.add({\n                targets: self,\n                //1000 is maximum blast length, then a ratio of that length is calculated in x and y distances\n                x: self.x + 1000 * self.orientationx * self.startingOlength / 100,\n                y: self.y + 1000 * self.orientationy * self.startingOlength / 100,\n                duration: 100,\n                onComplete: countRuns,\n                repeat: 10,\n                yoyo: true\n              });\n            }\n          }\n      }\n    }\n\n    ; //This function destroys the object\n\n    function countRuns(tween, targets, scene) {\n      let self = targets[0];\n      self.destroy();\n    }\n  }\n\n  destroyAnimationSprite() {\n    this.animationSprite.destroy();\n  }\n\n  getOwner() {\n    return this.owner;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/src/phaser/sprites/lightningBoltHitbox.js"],"names":["Phaser","lightningHB","Physics","Arcade","Sprite","constructor","scene","x","y","texture","owner","animationSprite","Olength","add","existing","physics","setCircle","setVisible","width","height","oscillationLength","startingOlength","orientationx","getOrientationVector","orientationy","tweens","targets","duration","yoyo","onComplete","onCompleteHandler","onCompleteParams","tween","self","countRuns","repeat","destroy","destroyAnimationSprite","getOwner"],"mappings":"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","sourcesContent":["import Phaser from 'phaser';\r\nexport default class lightningHB extends Phaser.Physics.Arcade.Sprite\r\n    {\r\n\r\n        constructor (scene,x,y,texture,{owner, animationSprite, Olength}={})\r\n        {\r\n            super(scene,x,y,texture);\r\n            //Adds sprite to screen\r\n            scene.add.existing(this);\r\n\r\n            //Adds physics to sprite\r\n            scene.physics.add.existing(this);\r\n            this.setCircle(16);\r\n            //The sprite is an invisible hitbox\r\n            this.setVisible(false);\r\n\r\n            this.texture = texture;\r\n\r\n            //Track which animation sprite this lightning hitbox belongs to. This is needed for collisions.\r\n            this.animationSprite = animationSprite;\r\n\r\n            this.owner = owner;\r\n            \r\n            //Center \r\n            this.x = x+owner.width-8;\r\n            this.y = y+owner.height-8;\r\n            this.oscillationLength = Olength;\r\n            this.startingOlength = Olength;\r\n            this.orientationx = owner.getOrientationVector().x;\r\n            this.orientationy = owner.getOrientationVector().y;\r\n            \r\n            //Creates a recursive, growing oscillation distance that accelerates with the lightning \r\n            //bolt. \r\n            //This allows for an illision of a diagonal, rotating hitbox that arcade physics cannot create,\r\n            //I'd rather not have to use matter just for diagonal hitboxes,\r\n            //or resort to custom hitboxes and collision detection in the update loop\r\n            this.scene.tweens.add({\r\n                targets: this,\r\n                x: this.x + this.oscillationLength*this.orientationx,\r\n                y: this.y + this.oscillationLength*this.orientationy,\r\n                duration: 100,\r\n                yoyo: true,\r\n                onComplete: onCompleteHandler,\r\n                onCompleteParams: [this.scene]\r\n            });\r\n           //Recursive callback function that allows for a growing oscillation length to our circular hitbox, simulating a non AABB hitbox effectively\r\n           function onCompleteHandler(tween, targets, scene){\r\n                let self = targets[0];\r\n                if(self){\r\n                        //Each iteration, this multiplies the distance,\r\n                        //an exponential growth occurs\r\n                        self.oscillationLength *= 3;\r\n                    //This runs while the hitboxes don't move at max length\r\n                    if (self.oscillationLength <= 1000*self.startingOlength/100){\r\n                            self.scene.tweens.add({\r\n                            targets: self,\r\n                            x: self.x + self.oscillationLength*self.orientationx,\r\n                            y: self.y + self.oscillationLength*self.orientationy,\r\n                            duration: 100,\r\n                            yoyo: true,\r\n                            onComplete: onCompleteHandler,\r\n                        \r\n                        });\r\n                    }\r\n                    //This runs once the hitboxes have reached the maximum range of movement\r\n                    else {\r\n                        if (self){\r\n                            self.scene.tweens.add({\r\n                            targets: self,\r\n                            //1000 is maximum blast length, then a ratio of that length is calculated in x and y distances\r\n                            x: self.x + 1000*self.orientationx*self.startingOlength/100,\r\n                            y: self.y + 1000*self.orientationy*self.startingOlength/100,\r\n                            duration: 100,\r\n                            onComplete: countRuns,\r\n                            repeat: 10,\r\n                            yoyo: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n               \r\n            };\r\n            //This function destroys the object\r\n            function countRuns(tween, targets, scene){\r\n                let self = targets[0];\r\n                self.destroy();\r\n            }\r\n            \r\n        }\r\n        destroyAnimationSprite(){\r\n            this.animationSprite.destroy();\r\n        }\r\n        getOwner(){\r\n          return this.owner;\r\n        }\r\n        \r\n        \r\n      \r\n    }"]},"metadata":{},"sourceType":"module"}