{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require(\"events\");\n\nvar debug = require(\"debug\")(\"engine:socket\");\n\nvar Socket = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(Socket, _EventEmitter);\n\n  var _super = _createSuper(Socket);\n\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  function Socket(id, server, transport, req) {\n    var _this;\n\n    _classCallCheck(this, Socket);\n\n    _this = _super.call(this);\n    _this.id = id;\n    _this.server = server;\n    _this.upgrading = false;\n    _this.upgraded = false;\n    _this.readyState = \"opening\";\n    _this.writeBuffer = [];\n    _this.packetsFn = [];\n    _this.sentCallbackFn = [];\n    _this.cleanupFn = [];\n    _this.request = req; // Cache IP since it might not be in the req later\n\n    if (req.websocket && req.websocket._socket) {\n      _this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      _this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    _this.checkIntervalTimer = null;\n    _this.upgradeTimeoutTimer = null;\n    _this.pingTimeoutTimer = null;\n    _this.pingIntervalTimer = null;\n\n    _this.setTransport(transport);\n\n    _this.onOpen();\n\n    return _this;\n  }\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n\n\n  _createClass(Socket, [{\n    key: \"onOpen\",\n    value: function onOpen() {\n      this.readyState = \"open\"; // sends an `open` packet\n\n      this.transport.sid = this.id;\n      this.sendPacket(\"open\", JSON.stringify({\n        sid: this.id,\n        upgrades: this.getAvailableUpgrades(),\n        pingInterval: this.server.opts.pingInterval,\n        pingTimeout: this.server.opts.pingTimeout\n      }));\n\n      if (this.server.opts.initialPacket) {\n        this.sendPacket(\"message\", this.server.opts.initialPacket);\n      }\n\n      this.emit(\"open\");\n      this.schedulePing();\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n\n  }, {\n    key: \"onPacket\",\n    value: function onPacket(packet) {\n      if (\"open\" === this.readyState) {\n        // export packet event\n        debug(\"packet\");\n        this.emit(\"packet\", packet); // Reset ping timeout on any packet, incoming data is a good sign of\n        // other side's liveness\n\n        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n\n        switch (packet.type) {\n          case \"pong\":\n            debug(\"got pong\");\n            this.schedulePing();\n            this.emit(\"heartbeat\");\n            break;\n\n          case \"error\":\n            this.onClose(\"parse error\");\n            break;\n\n          case \"message\":\n            this.emit(\"data\", packet.data);\n            this.emit(\"message\", packet.data);\n            break;\n        }\n      } else {\n        debug(\"packet received with closed socket\");\n      }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} error object\n     * @api private\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(err) {\n      debug(\"transport error\");\n      this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"schedulePing\",\n    value: function schedulePing() {\n      var _this2 = this;\n\n      clearTimeout(this.pingIntervalTimer);\n      this.pingIntervalTimer = setTimeout(function () {\n        debug(\"writing ping packet - expecting pong within %sms\", _this2.server.opts.pingTimeout);\n\n        _this2.sendPacket(\"ping\");\n\n        _this2.resetPingTimeout(_this2.server.opts.pingTimeout);\n      }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"resetPingTimeout\",\n    value: function resetPingTimeout(timeout) {\n      var _this3 = this;\n\n      clearTimeout(this.pingTimeoutTimer);\n      this.pingTimeoutTimer = setTimeout(function () {\n        if (_this3.readyState === \"closed\") return;\n\n        _this3.onClose(\"ping timeout\");\n      }, timeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n\n  }, {\n    key: \"setTransport\",\n    value: function setTransport(transport) {\n      var onError = this.onError.bind(this);\n      var onPacket = this.onPacket.bind(this);\n      var flush = this.flush.bind(this);\n      var onClose = this.onClose.bind(this, \"transport close\");\n      this.transport = transport;\n      this.transport.once(\"error\", onError);\n      this.transport.on(\"packet\", onPacket);\n      this.transport.on(\"drain\", flush);\n      this.transport.once(\"close\", onClose); // this function will manage packet events (also message callbacks)\n\n      this.setupSendCallback();\n      this.cleanupFn.push(function () {\n        transport.removeListener(\"error\", onError);\n        transport.removeListener(\"packet\", onPacket);\n        transport.removeListener(\"drain\", flush);\n        transport.removeListener(\"close\", onClose);\n      });\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n\n  }, {\n    key: \"maybeUpgrade\",\n    value: function maybeUpgrade(transport) {\n      debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n      this.upgrading = true;\n      var self = this; // set transport upgrade timer\n\n      self.upgradeTimeoutTimer = setTimeout(function () {\n        debug(\"client did not complete upgrade - closing transport\");\n        cleanup();\n\n        if (\"open\" === transport.readyState) {\n          transport.close();\n        }\n      }, this.server.opts.upgradeTimeout);\n\n      function onPacket(packet) {\n        if (\"ping\" === packet.type && \"probe\" === packet.data) {\n          transport.send([{\n            type: \"pong\",\n            data: \"probe\"\n          }]);\n          self.emit(\"upgrading\", transport);\n          clearInterval(self.checkIntervalTimer);\n          self.checkIntervalTimer = setInterval(check, 100);\n        } else if (\"upgrade\" === packet.type && self.readyState !== \"closed\") {\n          debug(\"got upgrade packet - upgrading\");\n          cleanup();\n          self.transport.discard();\n          self.upgraded = true;\n          self.clearTransport();\n          self.setTransport(transport);\n          self.emit(\"upgrade\", transport);\n          self.schedulePing();\n          self.flush();\n\n          if (self.readyState === \"closing\") {\n            transport.close(function () {\n              self.onClose(\"forced close\");\n            });\n          }\n        } else {\n          cleanup();\n          transport.close();\n        }\n      } // we force a polling cycle to ensure a fast upgrade\n\n\n      function check() {\n        if (\"polling\" === self.transport.name && self.transport.writable) {\n          debug(\"writing a noop packet to polling for fast upgrade\");\n          self.transport.send([{\n            type: \"noop\"\n          }]);\n        }\n      }\n\n      function cleanup() {\n        self.upgrading = false;\n        clearInterval(self.checkIntervalTimer);\n        self.checkIntervalTimer = null;\n        clearTimeout(self.upgradeTimeoutTimer);\n        self.upgradeTimeoutTimer = null;\n        transport.removeListener(\"packet\", onPacket);\n        transport.removeListener(\"close\", onTransportClose);\n        transport.removeListener(\"error\", onError);\n        self.removeListener(\"close\", onClose);\n      }\n\n      function onError(err) {\n        debug(\"client did not complete upgrade - %s\", err);\n        cleanup();\n        transport.close();\n        transport = null;\n      }\n\n      function onTransportClose() {\n        onError(\"transport closed\");\n      }\n\n      function onClose() {\n        onError(\"socket closed\");\n      }\n\n      transport.on(\"packet\", onPacket);\n      transport.once(\"close\", onTransportClose);\n      transport.once(\"error\", onError);\n      self.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"clearTransport\",\n    value: function clearTransport() {\n      var cleanup;\n      var toCleanUp = this.cleanupFn.length;\n\n      for (var i = 0; i < toCleanUp; i++) {\n        cleanup = this.cleanupFn.shift();\n        cleanup();\n      } // silence further transport errors and prevent uncaught exceptions\n\n\n      this.transport.on(\"error\", function () {\n        debug(\"error triggered by discarded transport\");\n      }); // ensure transport won't stay open\n\n      this.transport.close();\n      clearTimeout(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(reason, description) {\n      if (\"closed\" !== this.readyState) {\n        this.readyState = \"closed\"; // clear timers\n\n        clearTimeout(this.pingIntervalTimer);\n        clearTimeout(this.pingTimeoutTimer);\n        clearInterval(this.checkIntervalTimer);\n        this.checkIntervalTimer = null;\n        clearTimeout(this.upgradeTimeoutTimer);\n        var self = this; // clean writeBuffer in next tick, so developers can still\n        // grab the writeBuffer on 'close' event\n\n        process.nextTick(function () {\n          self.writeBuffer = [];\n        });\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.clearTransport();\n        this.emit(\"close\", reason, description);\n      }\n    }\n    /**\n     * Setup and manage send callback\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"setupSendCallback\",\n    value: function setupSendCallback() {\n      var self = this;\n      this.transport.on(\"drain\", onDrain);\n      this.cleanupFn.push(function () {\n        self.transport.removeListener(\"drain\", onDrain);\n      }); // the message was sent successfully, execute the callback\n\n      function onDrain() {\n        if (self.sentCallbackFn.length > 0) {\n          var seqFn = self.sentCallbackFn.splice(0, 1)[0];\n\n          if (\"function\" === typeof seqFn) {\n            debug(\"executing send callback\");\n            seqFn(self.transport);\n          } else if (Array.isArray(seqFn)) {\n            debug(\"executing batch send callback\");\n            var l = seqFn.length;\n            var i = 0;\n\n            for (; i < l; i++) {\n              if (\"function\" === typeof seqFn[i]) {\n                seqFn[i](self.transport);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {String} message\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     * @api public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data, options, callback) {\n      this.sendPacket(\"message\", data, options, callback);\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(data, options, callback) {\n      this.sendPacket(\"message\", data, options, callback);\n      return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} packet type\n     * @param {String} optional, data\n     * @param {Object} options\n     * @api private\n     */\n\n  }, {\n    key: \"sendPacket\",\n    value: function sendPacket(type, data, options, callback) {\n      if (\"function\" === typeof options) {\n        callback = options;\n        options = null;\n      }\n\n      options = options || {};\n      options.compress = false !== options.compress;\n\n      if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n        debug('sending packet \"%s\" (%s)', type, data);\n        var packet = {\n          type: type,\n          options: options\n        };\n        if (data) packet.data = data; // exports packetCreate event\n\n        this.emit(\"packetCreate\", packet);\n        this.writeBuffer.push(packet); // add send callback to object, if defined\n\n        if (callback) this.packetsFn.push(callback);\n        this.flush();\n      }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n        debug(\"flushing buffer to transport\");\n        this.emit(\"flush\", this.writeBuffer);\n        this.server.emit(\"flush\", this, this.writeBuffer);\n        var wbuf = this.writeBuffer;\n        this.writeBuffer = [];\n\n        if (!this.transport.supportsFraming) {\n          this.sentCallbackFn.push(this.packetsFn);\n        } else {\n          this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n        }\n\n        this.packetsFn = [];\n        this.transport.send(wbuf);\n        this.emit(\"drain\");\n        this.server.emit(\"drain\", this);\n      }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"getAvailableUpgrades\",\n    value: function getAvailableUpgrades() {\n      var availableUpgrades = [];\n      var allUpgrades = this.server.upgrades(this.transport.name);\n      var i = 0;\n      var l = allUpgrades.length;\n\n      for (; i < l; ++i) {\n        var upg = allUpgrades[i];\n\n        if (this.server.opts.transports.indexOf(upg) !== -1) {\n          availableUpgrades.push(upg);\n        }\n      }\n\n      return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} optional, discard\n     * @return {Socket} for chaining\n     * @api public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(discard) {\n      if (\"open\" !== this.readyState) return;\n      this.readyState = \"closing\";\n\n      if (this.writeBuffer.length) {\n        this.once(\"drain\", this.closeTransport.bind(this, discard));\n        return;\n      }\n\n      this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @api private\n     */\n\n  }, {\n    key: \"closeTransport\",\n    value: function closeTransport(discard) {\n      if (discard) this.transport.discard();\n      this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n  }]);\n\n  return Socket;\n}(EventEmitter);\n\nmodule.exports = Socket;","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/engine.io/lib/socket.js"],"names":["EventEmitter","require","debug","Socket","id","server","transport","req","upgrading","upgraded","readyState","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","websocket","_socket","remoteAddress","connection","checkIntervalTimer","upgradeTimeoutTimer","pingTimeoutTimer","pingIntervalTimer","setTransport","onOpen","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","opts","pingTimeout","initialPacket","emit","schedulePing","packet","resetPingTimeout","type","onClose","data","err","clearTimeout","setTimeout","timeout","onError","bind","onPacket","flush","once","on","setupSendCallback","push","removeListener","name","self","cleanup","close","upgradeTimeout","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","options","callback","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require(\"events\");\nconst debug = require(\"debug\")(\"engine:socket\");\n\nclass Socket extends EventEmitter {\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  constructor(id, server, transport, req) {\n    super();\n    this.id = id;\n    this.server = server;\n    this.upgrading = false;\n    this.upgraded = false;\n    this.readyState = \"opening\";\n    this.writeBuffer = [];\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.cleanupFn = [];\n    this.request = req;\n\n    // Cache IP since it might not be in the req later\n    if (req.websocket && req.websocket._socket) {\n      this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    this.checkIntervalTimer = null;\n    this.upgradeTimeoutTimer = null;\n    this.pingTimeoutTimer = null;\n    this.pingIntervalTimer = null;\n\n    this.setTransport(transport);\n    this.onOpen();\n  }\n\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n  onOpen() {\n    this.readyState = \"open\";\n\n    // sends an `open` packet\n    this.transport.sid = this.id;\n    this.sendPacket(\n      \"open\",\n      JSON.stringify({\n        sid: this.id,\n        upgrades: this.getAvailableUpgrades(),\n        pingInterval: this.server.opts.pingInterval,\n        pingTimeout: this.server.opts.pingTimeout\n      })\n    );\n\n    if (this.server.opts.initialPacket) {\n      this.sendPacket(\"message\", this.server.opts.initialPacket);\n    }\n\n    this.emit(\"open\");\n    this.schedulePing();\n  }\n\n  /**\n   * Called upon transport packet.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n  onPacket(packet) {\n    if (\"open\" === this.readyState) {\n      // export packet event\n      debug(\"packet\");\n      this.emit(\"packet\", packet);\n\n      // Reset ping timeout on any packet, incoming data is a good sign of\n      // other side's liveness\n      this.resetPingTimeout(\n        this.server.opts.pingInterval + this.server.opts.pingTimeout\n      );\n\n      switch (packet.type) {\n        case \"pong\":\n          debug(\"got pong\");\n          this.schedulePing();\n          this.emit(\"heartbeat\");\n          break;\n\n        case \"error\":\n          this.onClose(\"parse error\");\n          break;\n\n        case \"message\":\n          this.emit(\"data\", packet.data);\n          this.emit(\"message\", packet.data);\n          break;\n      }\n    } else {\n      debug(\"packet received with closed socket\");\n    }\n  }\n\n  /**\n   * Called upon transport error.\n   *\n   * @param {Error} error object\n   * @api private\n   */\n  onError(err) {\n    debug(\"transport error\");\n    this.onClose(\"transport error\", err);\n  }\n\n  /**\n   * Pings client every `this.pingInterval` and expects response\n   * within `this.pingTimeout` or closes connection.\n   *\n   * @api private\n   */\n  schedulePing() {\n    clearTimeout(this.pingIntervalTimer);\n    this.pingIntervalTimer = setTimeout(() => {\n      debug(\n        \"writing ping packet - expecting pong within %sms\",\n        this.server.opts.pingTimeout\n      );\n      this.sendPacket(\"ping\");\n      this.resetPingTimeout(this.server.opts.pingTimeout);\n    }, this.server.opts.pingInterval);\n  }\n\n  /**\n   * Resets ping timeout.\n   *\n   * @api private\n   */\n  resetPingTimeout(timeout) {\n    clearTimeout(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = setTimeout(() => {\n      if (this.readyState === \"closed\") return;\n      this.onClose(\"ping timeout\");\n    }, timeout);\n  }\n\n  /**\n   * Attaches handlers for the given transport.\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n  setTransport(transport) {\n    const onError = this.onError.bind(this);\n    const onPacket = this.onPacket.bind(this);\n    const flush = this.flush.bind(this);\n    const onClose = this.onClose.bind(this, \"transport close\");\n\n    this.transport = transport;\n    this.transport.once(\"error\", onError);\n    this.transport.on(\"packet\", onPacket);\n    this.transport.on(\"drain\", flush);\n    this.transport.once(\"close\", onClose);\n    // this function will manage packet events (also message callbacks)\n    this.setupSendCallback();\n\n    this.cleanupFn.push(function() {\n      transport.removeListener(\"error\", onError);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"drain\", flush);\n      transport.removeListener(\"close\", onClose);\n    });\n  }\n\n  /**\n   * Upgrades socket to the given transport\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n  maybeUpgrade(transport) {\n    debug(\n      'might upgrade socket transport from \"%s\" to \"%s\"',\n      this.transport.name,\n      transport.name\n    );\n\n    this.upgrading = true;\n\n    const self = this;\n\n    // set transport upgrade timer\n    self.upgradeTimeoutTimer = setTimeout(function() {\n      debug(\"client did not complete upgrade - closing transport\");\n      cleanup();\n      if (\"open\" === transport.readyState) {\n        transport.close();\n      }\n    }, this.server.opts.upgradeTimeout);\n\n    function onPacket(packet) {\n      if (\"ping\" === packet.type && \"probe\" === packet.data) {\n        transport.send([{ type: \"pong\", data: \"probe\" }]);\n        self.emit(\"upgrading\", transport);\n        clearInterval(self.checkIntervalTimer);\n        self.checkIntervalTimer = setInterval(check, 100);\n      } else if (\"upgrade\" === packet.type && self.readyState !== \"closed\") {\n        debug(\"got upgrade packet - upgrading\");\n        cleanup();\n        self.transport.discard();\n        self.upgraded = true;\n        self.clearTransport();\n        self.setTransport(transport);\n        self.emit(\"upgrade\", transport);\n        self.schedulePing();\n        self.flush();\n        if (self.readyState === \"closing\") {\n          transport.close(function() {\n            self.onClose(\"forced close\");\n          });\n        }\n      } else {\n        cleanup();\n        transport.close();\n      }\n    }\n\n    // we force a polling cycle to ensure a fast upgrade\n    function check() {\n      if (\"polling\" === self.transport.name && self.transport.writable) {\n        debug(\"writing a noop packet to polling for fast upgrade\");\n        self.transport.send([{ type: \"noop\" }]);\n      }\n    }\n\n    function cleanup() {\n      self.upgrading = false;\n\n      clearInterval(self.checkIntervalTimer);\n      self.checkIntervalTimer = null;\n\n      clearTimeout(self.upgradeTimeoutTimer);\n      self.upgradeTimeoutTimer = null;\n\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"close\", onTransportClose);\n      transport.removeListener(\"error\", onError);\n      self.removeListener(\"close\", onClose);\n    }\n\n    function onError(err) {\n      debug(\"client did not complete upgrade - %s\", err);\n      cleanup();\n      transport.close();\n      transport = null;\n    }\n\n    function onTransportClose() {\n      onError(\"transport closed\");\n    }\n\n    function onClose() {\n      onError(\"socket closed\");\n    }\n\n    transport.on(\"packet\", onPacket);\n    transport.once(\"close\", onTransportClose);\n    transport.once(\"error\", onError);\n\n    self.once(\"close\", onClose);\n  }\n\n  /**\n   * Clears listeners and timers associated with current transport.\n   *\n   * @api private\n   */\n  clearTransport() {\n    let cleanup;\n\n    const toCleanUp = this.cleanupFn.length;\n\n    for (let i = 0; i < toCleanUp; i++) {\n      cleanup = this.cleanupFn.shift();\n      cleanup();\n    }\n\n    // silence further transport errors and prevent uncaught exceptions\n    this.transport.on(\"error\", function() {\n      debug(\"error triggered by discarded transport\");\n    });\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    clearTimeout(this.pingTimeoutTimer);\n  }\n\n  /**\n   * Called upon transport considered closed.\n   * Possible reasons: `ping timeout`, `client error`, `parse error`,\n   * `transport error`, `server close`, `transport close`\n   */\n  onClose(reason, description) {\n    if (\"closed\" !== this.readyState) {\n      this.readyState = \"closed\";\n\n      // clear timers\n      clearTimeout(this.pingIntervalTimer);\n      clearTimeout(this.pingTimeoutTimer);\n\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      clearTimeout(this.upgradeTimeoutTimer);\n      const self = this;\n      // clean writeBuffer in next tick, so developers can still\n      // grab the writeBuffer on 'close' event\n      process.nextTick(function() {\n        self.writeBuffer = [];\n      });\n      this.packetsFn = [];\n      this.sentCallbackFn = [];\n      this.clearTransport();\n      this.emit(\"close\", reason, description);\n    }\n  }\n\n  /**\n   * Setup and manage send callback\n   *\n   * @api private\n   */\n  setupSendCallback() {\n    const self = this;\n    this.transport.on(\"drain\", onDrain);\n\n    this.cleanupFn.push(function() {\n      self.transport.removeListener(\"drain\", onDrain);\n    });\n\n    // the message was sent successfully, execute the callback\n    function onDrain() {\n      if (self.sentCallbackFn.length > 0) {\n        const seqFn = self.sentCallbackFn.splice(0, 1)[0];\n        if (\"function\" === typeof seqFn) {\n          debug(\"executing send callback\");\n          seqFn(self.transport);\n        } else if (Array.isArray(seqFn)) {\n          debug(\"executing batch send callback\");\n          const l = seqFn.length;\n          let i = 0;\n          for (; i < l; i++) {\n            if (\"function\" === typeof seqFn[i]) {\n              seqFn[i](self.transport);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Sends a message packet.\n   *\n   * @param {String} message\n   * @param {Object} options\n   * @param {Function} callback\n   * @return {Socket} for chaining\n   * @api public\n   */\n  send(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  write(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  /**\n   * Sends a packet.\n   *\n   * @param {String} packet type\n   * @param {String} optional, data\n   * @param {Object} options\n   * @api private\n   */\n  sendPacket(type, data, options, callback) {\n    if (\"function\" === typeof options) {\n      callback = options;\n      options = null;\n    }\n\n    options = options || {};\n    options.compress = false !== options.compress;\n\n    if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n      debug('sending packet \"%s\" (%s)', type, data);\n\n      const packet = {\n        type: type,\n        options: options\n      };\n      if (data) packet.data = data;\n\n      // exports packetCreate event\n      this.emit(\"packetCreate\", packet);\n\n      this.writeBuffer.push(packet);\n\n      // add send callback to object, if defined\n      if (callback) this.packetsFn.push(callback);\n\n      this.flush();\n    }\n  }\n\n  /**\n   * Attempts to flush the packets buffer.\n   *\n   * @api private\n   */\n  flush() {\n    if (\n      \"closed\" !== this.readyState &&\n      this.transport.writable &&\n      this.writeBuffer.length\n    ) {\n      debug(\"flushing buffer to transport\");\n      this.emit(\"flush\", this.writeBuffer);\n      this.server.emit(\"flush\", this, this.writeBuffer);\n      const wbuf = this.writeBuffer;\n      this.writeBuffer = [];\n      if (!this.transport.supportsFraming) {\n        this.sentCallbackFn.push(this.packetsFn);\n      } else {\n        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n      }\n      this.packetsFn = [];\n      this.transport.send(wbuf);\n      this.emit(\"drain\");\n      this.server.emit(\"drain\", this);\n    }\n  }\n\n  /**\n   * Get available upgrades for this socket.\n   *\n   * @api private\n   */\n  getAvailableUpgrades() {\n    const availableUpgrades = [];\n    const allUpgrades = this.server.upgrades(this.transport.name);\n    let i = 0;\n    const l = allUpgrades.length;\n    for (; i < l; ++i) {\n      const upg = allUpgrades[i];\n      if (this.server.opts.transports.indexOf(upg) !== -1) {\n        availableUpgrades.push(upg);\n      }\n    }\n    return availableUpgrades;\n  }\n\n  /**\n   * Closes the socket and underlying transport.\n   *\n   * @param {Boolean} optional, discard\n   * @return {Socket} for chaining\n   * @api public\n   */\n  close(discard) {\n    if (\"open\" !== this.readyState) return;\n\n    this.readyState = \"closing\";\n\n    if (this.writeBuffer.length) {\n      this.once(\"drain\", this.closeTransport.bind(this, discard));\n      return;\n    }\n\n    this.closeTransport(discard);\n  }\n\n  /**\n   * Closes the underlying transport.\n   *\n   * @param {Boolean} discard\n   * @api private\n   */\n  closeTransport(discard) {\n    if (discard) this.transport.discard();\n    this.transport.close(this.onClose.bind(this, \"forced close\"));\n  }\n}\n\nmodule.exports = Socket;\n"]},"metadata":{},"sourceType":"script"}