{"ast":null,"code":"import Phaser from 'phaser';\nexport default class Player extends Phaser.Physics.Arcade.Sprite {\n  constructor(scene, x, y, texture) {\n    super(scene, x, y, texture); //Adds sprite to screen\n\n    scene.add.existing(this); //Adds physics to sprite\n\n    scene.physics.add.existing(this);\n    this.body.setSize(30, 61);\n    this.createAnimations(scene); //Tracks changes in player orientation\n    //Player starts out looking forwards so x: 0, y: -1 makes sense as initial value\n\n    this.orientationVector = {\n      x: 0,\n      y: -1\n    }; //\n\n    this.alive = true;\n    this.x = x;\n    this.y = y;\n    this.dodging = false;\n    this.scene = scene;\n    this.stunned = false; //This can be passed into contructor later\n    //Should I use getters and setters like this?\n\n    this.setPlayerSpeed(400);\n  } //Starts stun for player\n\n\n  playStun() {\n    this.toggleStun(); //calls a timer which removes player stun after 1 second\n\n    let timedEvent = this.scene.time.delayedCall(1000, this.onEvent, [], this);\n  }\n\n  knockBack(gameObj) {\n    //This code finds the angle between the player and the object that damaged the player,\n    //then it sends the player flying in the exact opposite direction\n    let gameObjCenter = gameObj.getCenter();\n    let playerCenter = this.getCenter();\n    let vectorAngle = Phaser.Math.Angle.Between(gameObjCenter['x'], gameObjCenter['y'], playerCenter['x'], playerCenter['y']);\n    let knockBackVel = 1200;\n    let movementX = Math.cos(vectorAngle) * knockBackVel;\n    let movementY = Math.sin(vectorAngle) * knockBackVel;\n    this.setVelocity(movementX, movementY);\n  }\n\n  onEvent() {\n    this.toggleStun();\n  }\n\n  toggleStun() {\n    //While player is stunned, changed the player opacity\n    this.stunned = !this.stunned;\n\n    if (this.stunned === false) {\n      this.setAlpha(1);\n    } else {\n      this.setAlpha(.5);\n    }\n  }\n\n  dodge() {\n    //Changes player velocity and sets dodge property \n    this.body.setVelocity(this.orientationVector.x * 1500, this.orientationVector.y * 1500);\n    this.dodging = true;\n    this.setBounce(0);\n    console.log(this.orientationVector); //This calls after the dodge cooldown completes\n\n    let timedEvent = this.scene.time.delayedCall(150, this.finishedDodging, [], this);\n  }\n\n  finishedDodging() {\n    this.setBounce(0);\n    this.dodging = false;\n    this.body.setVelocity(0, 0);\n  } //These two functions are for checking collisions in the scene code,\n  //In the event that player is hit while stunned, the player shouldn't take damage or do anything else that's strange.\n\n\n  getDodging() {\n    return this.dodging;\n  }\n\n  getStun() {\n    return this.stunned;\n  }\n\n  setPlayerSpeed(speed) {\n    this.playerSpeed = speed;\n  }\n\n  setPlayerVelocity(velocityVector) {\n    this.body.setVelocity(velocityVector.x * this.playerSpeed, velocityVector.y * this.playerSpeed); //Not Moving\n\n    if (velocityVector.x === 0 && velocityVector.y === 0) {\n      this.anims.stop();\n    } //Moving Up\n    else if (velocityVector.y > 0) {\n        this.anims.play(this.texture.key + 'down', true);\n      } //Moving Down\n      else if (velocityVector.y < 0) {\n          this.anims.play(this.texture.key + 'up', true);\n        } //Moving Right\n        else if (velocityVector.x > 0) {\n            this.anims.play(this.texture.key + 'right', true);\n          } //Moving Left\n          else if (velocityVector.x < 0) {\n              this.anims.play(this.texture.key + 'left', true);\n            }\n  }\n\n  setMovementAnim(velocityVector) {\n    if (typeof this.anims !== 'undefined') {\n      //Not Moving\n      if (velocityVector.x === 0 && velocityVector.y === 0) {\n        this.anims.stop();\n      } //Moving Up\n      else if (velocityVector.y > 0) {\n          this.anims.play(this.texture.key + 'down', true);\n        } //Moving Down\n        else if (velocityVector.y < 0) {\n            this.anims.play(this.texture.key + 'up', true);\n          } //Moving Right\n          else if (velocityVector.x > 0) {\n              this.anims.play(this.texture.key + 'right', true);\n            } //Moving Left\n            else if (velocityVector.x < 0) {\n                this.anims.play(this.texture.key + 'left', true);\n              }\n    }\n  }\n\n  setOrientationVector(velocityVector) {\n    //Check to make sure 0,0 is not passed in(that is not a direction)\n    if (Math.abs(velocityVector.x) + Math.abs(velocityVector.y) > 0) {\n      //Check to see if there is a change in orientation\n      if (this.orientationVector.x !== velocityVector.x || this.orientationVector.y !== velocityVector.y) {\n        this.orientationVector = velocityVector;\n      }\n    }\n  }\n\n  gameOver() {\n    this.alive = false;\n  }\n\n  isAlive() {\n    return this.alive;\n  }\n\n  getOrientationVector() {\n    return this.orientationVector;\n  }\n\n  setHealthBar(healthBar) {\n    this.healthBar = healthBar;\n  }\n\n  getHealthBar() {\n    return this.healthBar;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  } //Create player animations\n\n\n  createAnimations(scene) {\n    scene.anims.create({\n      key: this.texture.key + 'left',\n      frames: scene.anims.generateFrameNumbers(this.texture.key, {\n        start: 4,\n        end: 5\n      }),\n      frameRate: 10,\n      repeat: -1\n    });\n    scene.anims.create({\n      key: this.texture.key + 'up',\n      frames: scene.anims.generateFrameNumbers(this.texture.key, {\n        start: 0,\n        end: 1\n      }),\n      frameRate: 10,\n      repeat: -1\n    });\n    scene.anims.create({\n      key: this.texture.key + 'right',\n      frames: scene.anims.generateFrameNumbers(this.texture.key, {\n        start: 2,\n        end: 3\n      }),\n      frameRate: 10,\n      repeat: -1\n    });\n    scene.anims.create({\n      key: this.texture.key + 'down',\n      frames: scene.anims.generateFrameNumbers(this.texture.key, {\n        start: 6,\n        end: 7\n      }),\n      frameRate: 10,\n      repeat: -1\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/src/phaser/sprites/Player.js"],"names":["Phaser","Player","Physics","Arcade","Sprite","constructor","scene","x","y","texture","add","existing","physics","body","setSize","createAnimations","orientationVector","alive","dodging","stunned","setPlayerSpeed","playStun","toggleStun","timedEvent","time","delayedCall","onEvent","knockBack","gameObj","gameObjCenter","getCenter","playerCenter","vectorAngle","Math","Angle","Between","knockBackVel","movementX","cos","movementY","sin","setVelocity","setAlpha","dodge","setBounce","console","log","finishedDodging","getDodging","getStun","speed","playerSpeed","setPlayerVelocity","velocityVector","anims","stop","play","key","setMovementAnim","setOrientationVector","abs","gameOver","isAlive","getOrientationVector","setHealthBar","healthBar","getHealthBar","getX","getY","create","frames","generateFrameNumbers","start","end","frameRate","repeat"],"mappings":"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","sourcesContent":["\r\nimport Phaser from 'phaser';\r\nexport default class Player extends Phaser.Physics.Arcade.Sprite\r\n    {\r\n\r\n        constructor (scene,x,y,texture)\r\n        {\r\n            super(scene,x,y,texture);\r\n            //Adds sprite to screen\r\n            scene.add.existing(this);\r\n            //Adds physics to sprite\r\n            scene.physics.add.existing(this);\r\n            this.body.setSize(30,61);\r\n            this.createAnimations(scene);\r\n            //Tracks changes in player orientation\r\n            //Player starts out looking forwards so x: 0, y: -1 makes sense as initial value\r\n            this.orientationVector = {x: 0, y: -1};\r\n            //\r\n            this.alive = true;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.dodging = false;\r\n            this.scene = scene;\r\n            this.stunned = false;\r\n            //This can be passed into contructor later\r\n            //Should I use getters and setters like this?\r\n            this.setPlayerSpeed(400);\r\n           \r\n        }\r\n        \r\n        //Starts stun for player\r\n        playStun(){\r\n            this.toggleStun();\r\n            //calls a timer which removes player stun after 1 second\r\n            let timedEvent = this.scene.time.delayedCall(1000, this.onEvent, [], this);\r\n        }\r\n        knockBack(gameObj){\r\n          //This code finds the angle between the player and the object that damaged the player,\r\n          //then it sends the player flying in the exact opposite direction\r\n          let gameObjCenter = gameObj.getCenter();\r\n          let playerCenter = this.getCenter();\r\n          let vectorAngle = Phaser.Math.Angle.Between(gameObjCenter['x'],gameObjCenter['y'],playerCenter['x'],playerCenter['y']);\r\n          \r\n          let knockBackVel = 1200;\r\n          let movementX = Math.cos(vectorAngle)*knockBackVel;\r\n          let movementY = Math.sin(vectorAngle)*knockBackVel;\r\n          this.setVelocity(movementX,movementY);\r\n        }\r\n        onEvent(){\r\n          this.toggleStun();\r\n        }\r\n        toggleStun(){\r\n          //While player is stunned, changed the player opacity\r\n          this.stunned = !this.stunned;\r\n          if (this.stunned === false){\r\n            this.setAlpha(1);\r\n          }\r\n          else {\r\n            this.setAlpha(.5);\r\n          }\r\n          \r\n        }\r\n        dodge(){\r\n          //Changes player velocity and sets dodge property \r\n          this.body.setVelocity(this.orientationVector.x*1500,this.orientationVector.y*1500);\r\n          this.dodging = true;\r\n          this.setBounce(0);\r\n          console.log(this.orientationVector);\r\n          //This calls after the dodge cooldown completes\r\n          let timedEvent = this.scene.time.delayedCall(150, this.finishedDodging, [], this);\r\n        }\r\n        finishedDodging(){\r\n          this.setBounce(0);\r\n          this.dodging = false;\r\n          this.body.setVelocity(0,0);\r\n        }\r\n        //These two functions are for checking collisions in the scene code,\r\n        //In the event that player is hit while stunned, the player shouldn't take damage or do anything else that's strange.\r\n        getDodging(){\r\n          return this.dodging;\r\n        }\r\n        getStun(){\r\n          return this.stunned;\r\n        }\r\n        setPlayerSpeed(speed)\r\n        {\r\n          this.playerSpeed = speed;\r\n        }\r\n\r\n        setPlayerVelocity(velocityVector)\r\n        {\r\n          \r\n          this.body.setVelocity(velocityVector.x*this.playerSpeed,velocityVector.y*this.playerSpeed);\r\n          //Not Moving\r\n          if(velocityVector.x === 0 && velocityVector.y === 0){\r\n            this.anims.stop();\r\n          }\r\n          //Moving Up\r\n          else if (velocityVector.y > 0){\r\n            this.anims.play(this.texture.key + 'down', true);\r\n          }\r\n          //Moving Down\r\n          else if (velocityVector.y < 0){\r\n            this.anims.play(this.texture.key + 'up', true);\r\n          }\r\n          //Moving Right\r\n          else if (velocityVector.x > 0) {\r\n            this.anims.play(this.texture.key + 'right', true);\r\n          }\r\n          //Moving Left\r\n          else if (velocityVector.x < 0) {\r\n            this.anims.play(this.texture.key + 'left', true);\r\n          }\r\n        \r\n        }\r\n        setMovementAnim(velocityVector){\r\n          if (typeof this.anims !== 'undefined'){\r\n             //Not Moving\r\n              if(velocityVector.x === 0 && velocityVector.y === 0){\r\n                this.anims.stop();\r\n              }\r\n              //Moving Up\r\n              else if (velocityVector.y > 0){\r\n                this.anims.play(this.texture.key + 'down', true);\r\n              }\r\n              //Moving Down\r\n              else if (velocityVector.y < 0){\r\n                this.anims.play(this.texture.key + 'up', true);\r\n              }\r\n              //Moving Right\r\n              else if (velocityVector.x > 0) {\r\n                this.anims.play(this.texture.key + 'right', true);\r\n              }\r\n              //Moving Left\r\n              else if (velocityVector.x < 0) {\r\n                this.anims.play(this.texture.key + 'left', true);\r\n              }\r\n          }\r\n          \r\n        }\r\n        setOrientationVector(velocityVector){\r\n          //Check to make sure 0,0 is not passed in(that is not a direction)\r\n          if(Math.abs(velocityVector.x)+Math.abs(velocityVector.y)>0){\r\n             \r\n            //Check to see if there is a change in orientation\r\n            if (this.orientationVector.x !== velocityVector.x || this.orientationVector.y !== velocityVector.y){\r\n              this.orientationVector = velocityVector;\r\n            }\r\n\r\n          }\r\n        }\r\n        gameOver(){\r\n          this.alive = false;\r\n        }\r\n        isAlive(){\r\n          return this.alive;\r\n        }\r\n        getOrientationVector(){\r\n          return this.orientationVector;\r\n        }\r\n        setHealthBar(healthBar){\r\n          this.healthBar = healthBar;\r\n        }\r\n        getHealthBar(){\r\n          return this.healthBar;\r\n        }\r\n        getX()\r\n        {\r\n          return this.x;\r\n        }\r\n        getY()\r\n        {\r\n          return this.y;\r\n        }\r\n        //Create player animations\r\n        createAnimations(scene){\r\n          scene.anims.create({\r\n            key: this.texture.key + 'left',\r\n            frames: scene.anims.generateFrameNumbers(this.texture.key, { start: 4, end: 5 }),\r\n            frameRate: 10,\r\n            repeat: -1\r\n          });\r\n          scene.anims.create({\r\n            key: this.texture.key + 'up',\r\n            frames: scene.anims.generateFrameNumbers(this.texture.key, { start: 0, end: 1 }),\r\n            frameRate: 10,\r\n            repeat: -1\r\n          });\r\n          scene.anims.create({\r\n            key: this.texture.key + 'right',\r\n            frames: scene.anims.generateFrameNumbers(this.texture.key, { start: 2, end: 3 }),\r\n            frameRate: 10,\r\n            repeat: -1\r\n          });\r\n          scene.anims.create({\r\n            key: this.texture.key + 'down',\r\n            frames: scene.anims.generateFrameNumbers(this.texture.key, { start: 6, end: 7 }),\r\n            frameRate: 10,\r\n            repeat: -1\r\n          });\r\n          \r\n        }\r\n    }\r\n"]},"metadata":{},"sourceType":"module"}