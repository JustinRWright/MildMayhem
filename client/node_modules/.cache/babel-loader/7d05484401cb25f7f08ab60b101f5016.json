{"ast":null,"code":"if (typeof exports !== 'undefined') {\n  var Tokenizer = require('./Tokenizer').Tokenizer;\n\n  exports.ZeParser = ZeParser;\n}\n/**\r\n * This is my js Parser: Ze. It's actually the post-dev pre-cleanup version. Clearly.\r\n * Some optimizations have been applied :)\r\n * (c) Peter van der Zee, qfox.nl\r\n * @param {String} inp Input\r\n * @param {Tokenizer} tok\r\n * @param {Array} stack The tokens will be put in this array. If you're looking for the AST, this would be it :)\r\n */\n\n\nfunction ZeParser(inp, tok, stack, simple) {\n  this.input = inp;\n  this.tokenizer = tok;\n  this.stack = stack;\n  this.stack.root = true;\n  this.scope = stack.scope = [{\n    value: 'this',\n    isDeclared: true,\n    isEcma: true,\n    thisIsGlobal: true\n  }]; // names of variables\n\n  this.scope.global = true;\n  this.statementLabels = [];\n  this.errorStack = [];\n  stack.scope = this.scope; // hook root\n\n  stack.labels = this.statementLabels;\n  this.regexLhsStart = ZeParser.regexLhsStart;\n  /*\r\n  \tthis.regexStartKeyword = ZeParser.regexStartKeyword;\r\n  \tthis.regexKeyword = ZeParser.regexKeyword;\r\n  \tthis.regexStartReserved = ZeParser.regexStartReserved;\r\n  \tthis.regexReserved = ZeParser.regexReserved;\r\n  */\n\n  this.regexStartKeyOrReserved = ZeParser.regexStartKeyOrReserved;\n  this.hashStartKeyOrReserved = ZeParser.hashStartKeyOrReserved;\n  this.regexIsKeywordOrReserved = ZeParser.regexIsKeywordOrReserved;\n  this.regexAssignments = ZeParser.regexAssignments;\n  this.regexNonAssignmentBinaryExpressionOperators = ZeParser.regexNonAssignmentBinaryExpressionOperators;\n  this.regexUnaryKeywords = ZeParser.regexUnaryKeywords;\n  this.hashUnaryKeywordStart = ZeParser.hashUnaryKeywordStart;\n  this.regexUnaryOperators = ZeParser.regexUnaryOperators;\n  this.regexLiteralKeywords = ZeParser.regexLiteralKeywords;\n  this.testing = {\n    'this': 1,\n    'null': 1,\n    'true': 1,\n    'false': 1\n  };\n  this.ast = !simple; ///#define FULL_AST\n}\n\n;\n/**\r\n * Returns just a stacked parse tree (regular array)\r\n * @param {string} input\r\n * @param {boolean} simple=false\r\n * @return {Array}\r\n */\n\nZeParser.parse = function (input, simple) {\n  var tok = new Tokenizer(input);\n  var stack = [];\n\n  try {\n    var parser = new ZeParser(input, tok, stack);\n    if (simple) parser.ast = false;\n    parser.parse();\n    return stack;\n  } catch (e) {\n    console.log(\"Parser has a bug for this input, please report it :)\", e);\n    return null;\n  }\n};\n/**\r\n * Returns a new parser instance with parse details for input\r\n * @param {string} input\r\n * @returns {ZeParser}\r\n */\n\n\nZeParser.createParser = function (input) {\n  var tok = new Tokenizer(input);\n  var stack = [];\n\n  try {\n    var parser = new ZeParser(input, tok, stack);\n    parser.parse();\n    return parser;\n  } catch (e) {\n    console.log(\"Parser has a bug for this input, please report it :)\", e);\n    return null;\n  }\n};\n\nZeParser.prototype = {\n  input: null,\n  tokenizer: null,\n  stack: null,\n  scope: null,\n  statementLabels: null,\n  errorStack: null,\n  ast: null,\n  parse: function (match) {\n    if (match) match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, this.stack); // meh\n    else match = this.tokenizer.storeCurrentAndFetchNextToken(false, null, this.stack, true); // initialization step, dont store the match (there isnt any!)\n\n    match = this.eatSourceElements(match, this.stack);\n    var cycled = false;\n\n    do {\n      if (match && match.name != 12\n      /*eof*/\n      ) {\n          // if not already an error, insert an error before it\n          if (match.name != 14\n          /*error*/\n          ) this.failignore('UnexpectedToken', match, this.stack); // just parse the token as is and continue.\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, this.stack);\n          cycled = true;\n        } // keep gobbling any errors...\n\n    } while (match && match.name == 14\n    /*error*/\n    ); // now try again (but only if we gobbled at least one token)...\n\n\n    if (cycled && match && match.name != 12\n    /*eof*/\n    ) match = this.parse(match); // pop the last token off the stack if it caused an error at eof\n\n    if (this.tokenizer.errorEscape) {\n      this.stack.push(this.tokenizer.errorEscape);\n      this.tokenizer.errorEscape = null;\n    }\n\n    return match;\n  },\n  eatSemiColon: function (match, stack) {\n    //this.stats.eatSemiColon = (+//this.stats.eatSemiColon||0)+1;\n    if (match.value == ';') match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);else {\n      // try asi\n      // only if:\n      // - this token was preceeded by at least one newline (match.newline) or next token is }\n      // - this is EOF\n      // - prev token was one of return,continue,break,throw (restricted production), not checked here.\n      // the exceptions to this rule are \n      // - if the next line is a regex \n      // - the semi is part of the for-header. \n      // these exceptions are automatically caught by the way the parser is built\n      // not eof and just parsed semi or no newline preceeding and next isnt }\n      if (match.name != 12\n      /*EOF*/\n      && (match.semi || !match.newline && match.value != '}') && !(match.newline && (match.value == '++' || match.value == '--'))) {\n        this.failignore('NoASI', match, stack);\n      } else {\n        // ASI\n        // (match is actually the match _after_ this asi, so the position of asi is match.start, not stop (!)\n        var asi = {\n          start: match.start,\n          stop: match.start,\n          name: 13\n          /*ASI*/\n\n        };\n        stack.push(asi); // slip it in the stream, before the current match.\n        // for the other tokens see the tokenizer near the end of the main parsing function\n\n        this.tokenizer.addTokenToStreamBefore(asi, match);\n      }\n    }\n    match.semi = true;\n    return match;\n  },\n\n  /**\r\n   * Eat one or more \"AssignmentExpression\"s. May also eat a labeled statement if\r\n   * the parameters are set that way. This is the only way to linearly distinct between\r\n   * an expression-statement and a labeled-statement without double lookahead. (ok, maybe not \"only\")\r\n   * @param {boolean} mayParseLabeledStatementInstead=false If the first token is an identifier and the second a colon, accept this match as a labeled statement instead... Only true if the match in the parameter is an (unreserved) identifier (so no need to validate that further) \r\n   * @param {Object} match\r\n   * @param {Array} stack\r\n   * @param {boolean} onlyOne=false Only parse a AssignmentExpression\r\n   * @param {boolean} forHeader=false Do not allow the `in` operator\r\n   * @param {boolean} isBreakOrContinueArg=false The argument for break or continue is always a single identifier\r\n   * @return {Object}\r\n   */\n  eatExpressions: function (mayParseLabeledStatementInstead, match, stack, onlyOne, forHeader, isBreakOrContinueArg) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var pstack = stack;\n      stack = [];\n      stack.desc = 'expressions';\n      stack.nextBlack = match.tokposb;\n      pstack.push(stack);\n      var parsedExpressions = 0;\n    } //#endif\n\n\n    var first = true;\n\n    do {\n      var parsedNonAssignmentOperator = false; // once we parse a non-assignment, this expression can no longer parse an assignment\n      // TOFIX: can probably get the regex out somehow...\n\n      if (!first) {\n        match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n        if (!(\n        /*is left hand side start?*/\n        match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('ExpectedAnotherExpressionComma', match);\n      }\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        ++parsedExpressions;\n        var astack = stack;\n        stack = [];\n        stack.desc = 'expression';\n        stack.nextBlack = match.tokposb;\n        astack.push(stack);\n      } //#endif\n      // start of expression is given: match\n      // it should indeed be a properly allowed lhs\n      // first eat all unary operators\n      // they can be added to the stack, but we need to ensure they have indeed a valid operator\n\n\n      var parseAnotherExpression = true;\n\n      while (parseAnotherExpression) {\n        // keep parsing lhs+operator as long as there is an operator after the lhs.\n        if (this.ast) {\n          //#ifdef FULL_AST\n          var estack = stack;\n          stack = [];\n          stack.desc = 'sub-expression';\n          stack.nextBlack = match.tokposb;\n          estack.push(stack);\n          var news = 0; // encountered new operators waiting for parenthesis\n        } //#endif\n        // start checking lhs\n        // if lhs is identifier (new/call expression), allow to parse an assignment operator next\n        // otherwise keep eating unary expressions and then any \"value\"\n        // after that search for a binary operator. if we only ate a new/call expression then\n        // also allow to eat assignments. repeat for the rhs.\n\n\n        var parsedUnaryOperator = false;\n        var isUnary = null;\n\n        while (!isBreakOrContinueArg && ( // no unary for break/continue\n        isUnary = match.value && this.hashUnaryKeywordStart[match.value[0]] && this.regexUnaryKeywords.test(match.value) || // (match.value == 'delete' || match.value == 'void' || match.value == 'typeof' || match.value == 'new') ||\n        match.name == 11\n        /*PUNCTUATOR*/\n        && this.regexUnaryOperators.test(match.value))) {\n          if (isUnary) match.isUnaryOp = true;\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            // find parenthesis\n            if (match.value == 'new') ++news;\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // ensure that it is in fact a valid lhs-start\n\n          if (!(\n          /*is left hand side start?*/\n          match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('ExpectedAnotherExpressionRhs', match); // not allowed to parse assignment\n\n          parsedUnaryOperator = true;\n        }\n\n        ; // if we parsed any kind of unary operator, we cannot be parsing a labeled statement\n\n        if (parsedUnaryOperator) mayParseLabeledStatementInstead = false; // so now we know match is a valid lhs-start and not a unary operator\n        // it must be a string, number, regex, identifier \n        // or the start of an object literal ({), array literal ([) or group operator (().\n\n        var acceptAssignment = false; // take care of the \"open\" cases first (group, array, object)\n\n        if (match.value == '(') {\n          if (this.ast) {\n            //#ifdef FULL_AST\n            var groupStack = stack;\n            stack = [];\n            stack.desc = 'grouped';\n            stack.nextBlack = match.tokposb;\n            groupStack.push(stack);\n            var lhp = match;\n            match.isGroupStart = true;\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n          if (!(\n          /*is left hand side start?*/\n          match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('GroupingShouldStartWithExpression', match); // keep parsing expressions as long as they are followed by a comma\n\n          match = this.eatExpressions(false, match, stack);\n          if (match.value != ')') match = this.failsafe('UnclosedGroupingOperator', match);\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            match.twin = lhp;\n            lhp.twin = match;\n            match.isGroupStop = true;\n\n            if (stack[stack.length - 1].desc == 'expressions') {\n              // create ref to this expression group to the opening paren\n              lhp.expressionArg = stack[stack.length - 1];\n            }\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            stack = groupStack;\n          } //#endif\n          // you can assign to group results. and as long as the group does not contain a comma (and valid ref), it will work too :)\n\n\n          acceptAssignment = true; // there's an extra rule for [ namely that, it must start with an expression but after that, expressions are optional\n        } else if (match.value == '[') {\n          if (this.ast) {\n            //#ifdef FULL_AST\n            stack.sub = 'array literal';\n            stack.hasArrayLiteral = true;\n            var lhsb = match;\n            match.isArrayLiteralStart = true;\n            if (!this.scope.arrays) this.scope.arrays = [];\n            match.arrayId = this.scope.arrays.length;\n            this.scope.arrays.push(match);\n            match.targetScope = this.scope;\n          } //#endif\n          // keep parsing expressions as long as they are followed by a comma\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // arrays may start with \"elided\" commas\n\n          while (match.value == ',') match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n          var foundAtLeastOneComma = true; // for entry in while\n\n          while (foundAtLeastOneComma && match.value != ']') {\n            foundAtLeastOneComma = false;\n            if (!(\n            /*is left hand side start?*/\n            match.name <= 6 || this.regexLhsStart.test(match.value)) && match.name != 14\n            /*error*/\n            ) match = this.failsafe('ArrayShouldStartWithExpression', match);\n            match = this.eatExpressions(false, match, stack, true);\n\n            while (match.value == ',') {\n              foundAtLeastOneComma = true;\n              match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n            }\n          }\n\n          if (match.value != ']') {\n            match = this.failsafe('UnclosedPropertyBracket', match);\n          }\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            match.twin = lhsb;\n            lhsb.twin = match;\n            match.isArrayLiteralStop = true;\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\n\n          while (match.value == '++' || match.value == '--') {\n            // gobble and ignore?\n            this.failignore('InvalidPostfixOperandArray', match, stack);\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n          } // object literals need seperate handling...\n\n        } else if (match.value == '{') {\n          if (this.ast) {\n            //#ifdef FULL_AST\n            stack.sub = 'object literal';\n            stack.hasObjectLiteral = true;\n            match.isObjectLiteralStart = true;\n            if (!this.scope.objects) this.scope.objects = [];\n            match.objectId = this.scope.objects.length;\n            this.scope.objects.push(match);\n            var targetObject = match;\n            match.targetScope = this.scope;\n            var lhc = match;\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n          if (match.name == 12\n          /*eof*/\n          ) {\n              match = this.failsafe('ObjectLiteralExpectsColonAfterName', match);\n            } // ObjectLiteral\n          // PropertyNameAndValueList\n\n\n          while (match.value != '}' && match.name != 14\n          /*error*/\n          ) {\n            // will stop if next token is } or throw if not and no comma is found\n            // expecting a string, number, or identifier\n            //if (match.name != 5/*STRING_SINGLE*/ && match.name != 6/*STRING_DOUBLE*/ && match.name != 3/*NUMERIC_HEX*/ && match.name != 4/*NUMERIC_DEC*/ && match.name != 2/*IDENTIFIER*/) {\n            // TOFIX: more specific errors depending on type...\n            if (!match.isNumber && !match.isString && match.name != 2\n            /*IDENTIFIER*/\n            ) {\n                match = this.failsafe('IllegalPropertyNameToken', match);\n              }\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              var objLitStack = stack;\n              stack = [];\n              stack.desc = 'objlit pair';\n              stack.isObjectLiteralPair = true;\n              stack.nextBlack = match.tokposb;\n              objLitStack.push(stack);\n              var propNameStack = stack;\n              stack = [];\n              stack.desc = 'objlit pair name';\n              stack.nextBlack = match.tokposb;\n              propNameStack.push(stack);\n              propNameStack.sub = 'data';\n              var propName = match;\n              propName.isPropertyName = true;\n            } //#endif\n\n\n            var getset = match.value;\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              stack = propNameStack;\n            } //#endif\n            // for get/set we parse a function-like definition. but only if it's immediately followed by an identifier (otherwise it'll just be the property 'get' or 'set')\n\n\n            if (getset == 'get') {\n              // \"get\" PropertyName \"(\" \")\" \"{\" FunctionBody \"}\"\n              if (match.value == ':') {\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  propName.isPropertyOf = targetObject;\n                } //#endif\n\n\n                match = this.eatObjectLiteralColonAndBody(match, stack);\n              } else {\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  match.isPropertyOf = targetObject;\n                  propNameStack.sub = 'getter';\n                  propNameStack.isAccessor = true;\n                } //#endif\n                // if (match.name != 2/*IDENTIFIER*/ && match.name != 5/*STRING_SINGLE*/ && match.name != 6/*STRING_DOUBLE*/ && match.name != 3/*NUMERIC_HEX*/ && match.name != 4/*NUMERIC_DEC*/) {\n\n\n                if (!match.isNumber && !match.isString && match.name != 2\n                /*IDENTIFIER*/\n                ) match = this.failsafe('IllegalGetterSetterNameToken', match, true);\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n                if (match.value != '(') match = this.failsafe('GetterSetterNameFollowedByOpenParen', match);\n\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  var lhp = match;\n                } //#endif\n\n\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n                if (match.value != ')') match = this.failsafe('GetterHasNoArguments', match);\n\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  match.twin = lhp;\n                  lhp.twin = match;\n                } //#endif\n\n\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n                match = this.eatFunctionBody(match, stack);\n              }\n            } else if (getset == 'set') {\n              // \"set\" PropertyName \"(\" PropertySetParameterList \")\" \"{\" FunctionBody \"}\"\n              if (match.value == ':') {\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  propName.isPropertyOf = targetObject;\n                } //#endif\n\n\n                match = this.eatObjectLiteralColonAndBody(match, stack);\n              } else {\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  match.isPropertyOf = targetObject;\n                  propNameStack.sub = 'setter';\n                  propNameStack.isAccessor = true;\n                } //#endif\n\n\n                if (!match.isNumber && !match.isString && match.name != 2\n                /*IDENTIFIER*/\n                ) match = this.failsafe('IllegalGetterSetterNameToken', match);\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n                if (match.value != '(') match = this.failsafe('GetterSetterNameFollowedByOpenParen', match);\n\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  var lhp = match;\n                } //#endif\n\n\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n                if (match.name != 2\n                /*IDENTIFIER*/\n                ) {\n                    if (match.value == ')') match = this.failsafe('SettersMustHaveArgument', match);else match = this.failsafe('IllegalSetterArgumentNameToken', match);\n                  }\n\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n                if (match.value != ')') {\n                  if (match.value == ',') match = this.failsafe('SettersOnlyGetOneArgument', match);else match = this.failsafe('SetterHeaderShouldHaveClosingParen', match);\n                }\n\n                if (this.ast) {\n                  //#ifdef FULL_AST\n                  match.twin = lhp;\n                  lhp.twin = match;\n                } //#endif\n\n\n                match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n                match = this.eatFunctionBody(match, stack);\n              }\n            } else {\n              // PropertyName \":\" AssignmentExpression\n              if (this.ast) {\n                //#ifdef FULL_AST\n                propName.isPropertyOf = targetObject;\n              } //#endif\n\n\n              match = this.eatObjectLiteralColonAndBody(match, stack);\n            }\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              stack = objLitStack;\n            } //#endif\n            // one trailing comma allowed\n\n\n            if (match.value == ',') {\n              match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n              if (match.value == ',') match = this.failsafe('IllegalDoubleCommaInObjectLiteral', match);\n            } else if (match.value != '}') match = this.failsafe('UnclosedObjectLiteral', match); // either the next token is } and the loop breaks or\n            // the next token is the start of the next PropertyAssignment...\n\n          } // closing curly\n\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            match.twin = lhc;\n            lhc.twin = match;\n            match.isObjectLiteralStop = true;\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // next may be div\n\n          while (match.value == '++' || match.value == '--') {\n            this.failignore('InvalidPostfixOperandObject', match, stack);\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n          }\n        } else if (match.value == 'function') {\n          // function expression\n          if (this.ast) {\n            //#ifdef FULL_AST\n            var oldstack = stack;\n            stack = [];\n            stack.desc = 'func expr';\n            stack.isFunction = true;\n            stack.nextBlack = match.tokposb;\n            if (!this.scope.functions) this.scope.functions = [];\n            match.functionId = this.scope.functions.length;\n            this.scope.functions.push(match);\n            oldstack.push(stack);\n            var oldscope = this.scope; // add new scope\n\n            match.scope = stack.scope = this.scope = [this.scope, {\n              value: 'this',\n              isDeclared: true,\n              isEcma: true,\n              functionStack: stack\n            }, {\n              value: 'arguments',\n              isDeclared: true,\n              isEcma: true,\n              varType: ['Object']\n            }]; // add the current scope (to build chain up-down)\n\n            this.scope.upper = oldscope; // ref to back to function that's the cause for this scope\n\n            this.scope.scopeFor = match;\n            match.targetScope = oldscope; // consistency\n\n            match.isFuncExprKeyword = true;\n            match.functionStack = stack;\n          } //#endif\n\n\n          var funcExprToken = match;\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n          if (mayParseLabeledStatementInstead && match.value == ':') match = this.failsafe('LabelsMayNotBeReserved', match);\n\n          if (match.name == 2\n          /*IDENTIFIER*/\n          ) {\n              funcExprToken.funcName = match;\n              match.meta = \"func expr name\";\n              match.varType = ['Function'];\n              match.functionStack = stack; // ref to the stack, in case we detect the var being a constructor\n\n              if (this.ast) {\n                //#ifdef FULL_AST\n                // name is only available to inner scope\n                this.scope.push({\n                  value: match.value\n                });\n              } //#endif\n\n\n              if (this.hashStartKeyOrReserved[match.value[0]]\n              /*this.regexStartKeyOrReserved.test(match.value[0])*/\n              && this.regexIsKeywordOrReserved.test(match.value)) match = this.failsafe('FunctionNameMustNotBeReserved', match);\n              match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n            }\n\n          match = this.eatFunctionParametersAndBody(match, stack, true, funcExprToken); // first token after func-expr is div\n\n          while (match.value == '++' || match.value == '--') {\n            this.failignore('InvalidPostfixOperandFunction', match, stack);\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n          }\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            // restore stack and scope\n            stack = oldstack;\n            this.scope = oldscope;\n          } //#endif\n\n        } else if (match.name <= 6) {\n          // IDENTIFIER STRING_SINGLE STRING_DOUBLE NUMERIC_HEX NUMERIC_DEC REG_EX\n          // save it in case it turns out to be a label.\n          var possibleLabel = match; // validate the identifier, if any\n\n          if (match.name == 2\n          /*IDENTIFIER*/\n          ) {\n              if ( // this, null, true, false are actually allowed here\n              !this.regexLiteralKeywords.test(match.value) && // other reserved words are not\n              this.hashStartKeyOrReserved[match.value[0]]\n              /*this.regexStartKeyOrReserved.test(match.value[0])*/\n              && this.regexIsKeywordOrReserved.test(match.value)) {\n                // if break/continue, we skipped the unary operator check so throw the proper error here\n                if (isBreakOrContinueArg) {\n                  this.failignore('BreakOrContinueArgMustBeJustIdentifier', match, stack);\n                } else if (match.value == 'else') {\n                  this.failignore('DidNotExpectElseHere', match, stack);\n                } else {\n                  //if (mayParseLabeledStatementInstead) {new ZeParser.Error('LabelsMayNotBeReserved', match);\n                  // TOFIX: lookahead to see if colon is following. throw label error instead if that's the case\n                  // any forbidden keyword at this point is likely to be a statement start.\n                  // its likely that the parser will take a while to recover from this point...\n                  this.failignore('UnexpectedToken', match, stack); // TOFIX: maybe i should just return at this point. cut my losses and hope for the best.\n                }\n              } // only accept assignments after a member expression (identifier or ending with a [] suffix)\n\n\n              acceptAssignment = true;\n            } else if (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match); // the current match is the lead value being queried. tag it that way\n\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            // dont mark labels\n            if (!isBreakOrContinueArg) {\n              match.meta = 'lead value';\n              match.leadValue = true;\n            }\n          } //#endif\n          // ok. gobble it.\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // division allowed\n          // now check for labeled statement (if mayParseLabeledStatementInstead then the first token for this expression must be an (unreserved) identifier)\n\n          if (mayParseLabeledStatementInstead && match.value == ':') {\n            if (possibleLabel.name != 2\n            /*IDENTIFIER*/\n            ) {\n                // label was not an identifier\n                // TOFIX: this colon might be a different type of error... more analysis required\n                this.failignore('LabelsMayOnlyBeIdentifiers', match, stack);\n              }\n\n            mayParseLabeledStatementInstead = true; // mark label parsed (TOFIX:speed?)\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n            possibleLabel.isLabel = true;\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              delete possibleLabel.meta; // oh oops, it's not a lead value.\n\n              possibleLabel.isLabelDeclaration = true;\n              this.statementLabels.push(possibleLabel.value);\n              stack.desc = 'labeled statement';\n            } //#endif\n\n\n            var errorIdToReplace = this.errorStack.length; // eat another statement now, its the body of the labeled statement (like if and while)\n\n            match = this.eatStatement(false, match, stack); // if no statement was found, check here now and correct error\n\n            if (match.error && match.error.msg == ZeParser.Errors.UnableToParseStatement.msg) {\n              // replace with better error...\n              match.error = new ZeParser.Error('LabelRequiresStatement'); // also replace on stack\n\n              this.errorStack[errorIdToReplace] = match.error;\n            }\n\n            match.wasLabel = true;\n            return match;\n          }\n\n          mayParseLabeledStatementInstead = false;\n        } else if (match.value == '}') {// ignore... its certainly the end of this expression, but maybe asi can be applied...\n          // it might also be an object literal expecting more, but that case has been covered else where.\n          // if it turns out the } is bad after all, .parse() will try to recover\n        } else if (match.name == 14\n        /*error*/\n        ) {\n            do {\n              if (match.tokenError) {\n                var pe = new ZeParser.Error('TokenizerError', match);\n                pe.msg += ': ' + match.error.msg;\n                this.errorStack.push(pe);\n                this.failSpecial({\n                  start: match.start,\n                  stop: match.start,\n                  name: 14\n                  /*error*/\n                  ,\n                  error: pe\n                }, match, stack);\n              }\n\n              match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n            } while (match.name == 14\n            /*error*/\n            );\n          } else if (match.name == 12\n        /*eof*/\n        ) {\n            // cant parse any further. you're probably just typing...\n            return match;\n          } else {\n          //if (!this.errorStack.length && match.name != 12/*eof*/) console.log([\"unknown token\", match, stack, Gui.escape(this.input)]);\n          this.failignore('UnknownToken', match, stack); // we cant really ignore this. eat the token and try again. possibly you're just typing?\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n        } // search for \"value\" suffix. property access and call parens.\n\n\n        while (match.value == '.' || match.value == '[' || match.value == '(') {\n          if (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\n\n          if (match.value == '.') {\n            // property access. read in an IdentifierName (no keyword checks). allow assignments\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n            if (match.name != 2\n            /*IDENTIFIER*/\n            ) this.failignore('PropertyNamesMayOnlyBeIdentifiers', match, stack);\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              match.isPropertyName = true;\n            } //#endif\n\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // may parse div\n\n            acceptAssignment = true;\n          } else if (match.value == '[') {\n            if (this.ast) {\n              //#ifdef FULL_AST\n              var lhsb = match;\n              match.propertyAccessStart = true;\n            } //#endif\n            // property access, read expression list. allow assignments\n\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n            if (!(\n            /*is left hand side start?*/\n            match.name <= 6 || this.regexLhsStart.test(match.value))) {\n              if (match.value == ']') match = this.failsafe('SquareBracketsMayNotBeEmpty', match);else match = this.failsafe('SquareBracketExpectsExpression', match);\n            }\n\n            match = this.eatExpressions(false, match, stack);\n            if (match.value != ']') match = this.failsafe('UnclosedSquareBrackets', match);\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              match.twin = lhsb;\n              match.propertyAccessStop = true;\n              lhsb.twin = match;\n\n              if (stack[stack.length - 1].desc == 'expressions') {\n                // create ref to this expression group to the opening bracket\n                lhsb.expressionArg = stack[stack.length - 1];\n              }\n            } //#endif\n\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\n\n            acceptAssignment = true;\n          } else if (match.value == '(') {\n            if (this.ast) {\n              //#ifdef FULL_AST\n              var lhp = match;\n              match.isCallExpressionStart = true;\n\n              if (news) {\n                match.parensBelongToNew = true;\n                --news;\n              }\n            } //#endif\n            // call expression, eat optional expression list, disallow assignments\n\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n            if (\n            /*is left hand side start?*/\n            match.name <= 6 || this.regexLhsStart.test(match.value)) match = this.eatExpressions(false, match, stack); // arguments are optional\n\n            if (match.value != ')') match = this.failsafe('UnclosedCallParens', match);\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              match.twin = lhp;\n              lhp.twin = match;\n              match.isCallExpressionStop = true;\n\n              if (stack[stack.length - 1].desc == 'expressions') {\n                // create ref to this expression group to the opening bracket\n                lhp.expressionArg = stack[stack.length - 1];\n              }\n            } //#endif\n\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\n\n            acceptAssignment = false;\n          }\n        } // check for postfix operators ++ and --\n        // they are stronger than the + or - binary operators\n        // they can be applied to any lhs (even when it wouldnt make sense)\n        // if there was a newline, it should get an ASI\n\n\n        if ((match.value == '++' || match.value == '--') && !match.newline) {\n          if (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\n          match = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // may parse div\n        }\n\n        if (this.ast) {\n          //#ifdef FULL_AST\n          // restore \"expression\" stack\n          stack = estack;\n        } //#endif\n        // now see if there is an operator following...\n\n\n        do {\n          // this do allows us to parse multiple ternary expressions in succession without screwing up.\n          var ternary = false;\n\n          if (!forHeader && match.value == 'in' || // one of two named binary operators, may not be first expression in for-header (when semi's occur in the for-header)\n          match.value == 'instanceof' || // only other named binary operator\n          match.name == 11\n          /*PUNCTUATOR*/\n          && ( // we can only expect a punctuator now\n          match.isAssignment = this.regexAssignments.test(match.value)) || // assignments are only okay with proper lhs\n          this.regexNonAssignmentBinaryExpressionOperators.test(match.value) // test all other binary operators\n          ) {\n            if (match.isAssignment) {\n              if (!acceptAssignment) this.failignore('IllegalLhsForAssignment', match, stack);else if (parsedNonAssignmentOperator) this.failignore('AssignmentNotAllowedAfterNonAssignmentInExpression', match, stack);\n            }\n\n            if (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\n            if (!match.isAssignment) parsedNonAssignmentOperator = true; // last allowed assignment\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              match.isBinaryOperator = true; // we build a stack to ensure any whitespace doesnt break the 1+(n*2) children rule for expressions\n\n              var ostack = stack;\n              stack = [];\n              stack.desc = 'operator-expression';\n              stack.isBinaryOperator = true;\n              stack.sub = match.value;\n              stack.nextBlack = match.tokposb;\n              ostack.sub = match.value;\n              stack.isAssignment = match.isAssignment;\n              ostack.push(stack);\n            } //#endif\n\n\n            ternary = match.value == '?'; // math, logic, assignment or in or instanceof\n\n            match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n            if (this.ast) {\n              //#ifdef FULL_AST\n              // restore \"expression\" stack\n              stack = ostack;\n            } //#endif\n            // minor exception to ternary operator, we need to parse two expressions nao. leave the trailing expression to the loop.\n\n\n            if (ternary) {\n              // LogicalORExpression \"?\" AssignmentExpression \":\" AssignmentExpression\n              // so that means just one expression center and right.\n              if (!(\n              /*is left hand side start?*/\n              match.name <= 6 || this.regexLhsStart.test(match.value))) this.failignore('InvalidCenterTernaryExpression', match, stack);\n              match = this.eatExpressions(false, match, stack, true, forHeader); // only one expression allowed inside ternary center/right\n\n              if (match.value != ':') {\n                if (match.value == ',') match = this.failsafe('TernarySecondExpressionCanNotContainComma', match);else match = this.failsafe('UnfinishedTernaryOperator', match);\n              }\n\n              if (this.ast) {\n                //#ifdef FULL_AST\n                // we build a stack to ensure any whitespace doesnt break the 1+(n*2) children rule for expressions\n                var ostack = stack;\n                stack = [];\n                stack.desc = 'operator-expression';\n                stack.sub = match.value;\n                stack.nextBlack = match.tokposb;\n                ostack.sub = match.value;\n                stack.isAssignment = match.isAssignment;\n                ostack.push(stack);\n              } //#endif\n\n\n              match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n              if (this.ast) {\n                //#ifdef FULL_AST\n                stack = ostack;\n              } //#endif\n              // rhs of the ternary can not contain a comma either\n\n\n              match = this.eatExpressions(false, match, stack, true, forHeader); // only one expression allowed inside ternary center/right\n            }\n          } else {\n            parseAnotherExpression = false;\n          }\n        } while (ternary); // if we just parsed a ternary expression, we need to check _again_ whether the next token is a binary operator.\n        // start over. match is the rhs for the lhs we just parsed, but lhs for the next expression\n\n\n        if (parseAnotherExpression && !(\n        /*is left hand side start?*/\n        match.name <= 6 || this.regexLhsStart.test(match.value))) {\n          // no idea what to do now. lets just ignore and see where it ends. TOFIX: maybe just break the loop or return?\n          this.failignore('InvalidRhsExpression', match, stack);\n        }\n      }\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        // restore \"expressions\" stack\n        stack = astack;\n      } //#endif\n      // at this point we should have parsed one AssignmentExpression\n      // lets see if we can parse another one...\n\n\n      mayParseLabeledStatementInstead = first = false;\n    } while (!onlyOne && match.value == ',');\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      // remove empty array\n      if (!stack.length) pstack.length = pstack.length - 1;\n      pstack.numberOfExpressions = parsedExpressions;\n      if (pstack[0]) pstack[0].numberOfExpressions = parsedExpressions;\n      stack.expressionCount = parsedExpressions;\n    } //#endif\n\n\n    return match;\n  },\n  eatFunctionDeclaration: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      var prevscope = this.scope;\n      stack.desc = 'func decl';\n      stack.isFunction = true;\n      stack.nextBlack = match.tokposb;\n      if (!this.scope.functions) this.scope.functions = [];\n      match.functionId = this.scope.functions.length;\n      this.scope.functions.push(match); // add new scope\n\n      match.scope = stack.scope = this.scope = [this.scope, // add current scope (build scope chain up-down)\n      // Object.create(null,\n      {\n        value: 'this',\n        isDeclared: true,\n        isEcma: true,\n        functionStack: stack\n      }, // Object.create(null,\n      {\n        value: 'arguments',\n        isDeclared: true,\n        isEcma: true,\n        varType: ['Object']\n      }]; // ref to back to function that's the cause for this scope\n\n      this.scope.scopeFor = match;\n      match.targetScope = prevscope; // consistency\n\n      match.functionStack = stack;\n      match.isFuncDeclKeyword = true;\n    } //#endif\n    // only place that this function is used already checks whether next token is function\n\n\n    var functionKeyword = match;\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.name != 2\n    /*IDENTIFIER*/\n    ) match = this.failsafe('FunctionDeclarationsMustHaveName', match);\n    if (this.hashStartKeyOrReserved[match.value[0]]\n    /*this.regexStartKeyOrReserved.test(match.value[0])*/\n    && this.regexIsKeywordOrReserved.test(match.value)) this.failignore('FunctionNameMayNotBeReserved', match, stack);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      functionKeyword.funcName = match;\n      prevscope.push({\n        value: match.value\n      });\n      match.meta = 'func decl name'; // that's what it is, really\n\n      match.varType = ['Function'];\n      match.functionStack = stack;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatFunctionParametersAndBody(match, stack, false, functionKeyword); // first token after func-decl is regex\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      // restore previous scope\n      this.scope = prevscope;\n    } //#endif\n\n\n    return match;\n  },\n  eatObjectLiteralColonAndBody: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var propValueStack = stack;\n      stack = [];\n      stack.desc = 'objlit pair colon';\n      stack.nextBlack = match.tokposb;\n      propValueStack.push(stack);\n    } //#endif\n\n\n    if (match.value != ':') match = this.failsafe('ObjectLiteralExpectsColonAfterName', match);\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack = propValueStack;\n    } //#endif\n    // this might actually fail due to ASI optimization.\n    // if the property name does not exist and it is the last item\n    // of the objlit, the expression parser will see an unexpected\n    // } and ignore it, giving some leeway to apply ASI. of course,\n    // that doesnt work for objlits. but we dont want to break the\n    // existing mechanisms. so we check this differently... :)\n\n\n    var prevMatch = match;\n    match = this.eatExpressions(false, match, stack, true); // only one expression\n\n    if (match == prevMatch) match = this.failsafe('ObjectLiteralMissingPropertyValue', match);\n    return match;\n  },\n  eatFunctionParametersAndBody: function (match, stack, div, funcToken) {\n    // div: the first token _after_ a function expression may be a division...\n    if (match.value != '(') match = this.failsafe('ExpectingFunctionHeaderStart', match);else if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      funcToken.lhp = match;\n    } //#endif\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n    if (match.name == 2\n    /*IDENTIFIER*/\n    ) {\n        // params\n        if (this.hashStartKeyOrReserved[match.value[0]]\n        /*this.regexStartKeyOrReserved.test(match.value[0])*/\n        && this.regexIsKeywordOrReserved.test(match.value)) this.failignore('FunctionArgumentsCanNotBeReserved', match, stack);\n\n        if (this.ast) {\n          //#ifdef FULL_AST\n          if (!funcToken.paramNames) funcToken.paramNames = [];\n          stack.paramNames = funcToken.paramNames;\n          funcToken.paramNames.push(match);\n          this.scope.push({\n            value: match.value\n          }); // add param name to scope\n\n          match.meta = 'parameter';\n        } //#endif\n\n\n        match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n        while (match.value == ',') {\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n          if (match.name != 2\n          /*IDENTIFIER*/\n          ) {\n              // example: if name is 12, the source is incomplete...\n              this.failignore('FunctionParametersMustBeIdentifiers', match, stack);\n            } else if (this.hashStartKeyOrReserved[match.value[0]]\n          /*this.regexStartKeyOrReserved.test(match.value[0])*/\n          && this.regexIsKeywordOrReserved.test(match.value)) {\n            this.failignore('FunctionArgumentsCanNotBeReserved', match, stack);\n          }\n\n          if (this.ast) {\n            //#ifdef FULL_AST\n            // Object.create(null,\n            this.scope.push({\n              value: match.value\n            }); // add param name to scope\n\n            match.meta = 'parameter';\n            if (match.name == 2\n            /*IDENTIFIER*/\n            ) funcToken.paramNames.push(match);\n          } //#endif\n\n\n          match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n        }\n      }\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      if (lhp) {\n        match.twin = lhp;\n        lhp.twin = match;\n        funcToken.rhp = match;\n      }\n    } //#endif\n\n\n    if (match.value != ')') match = this.failsafe('ExpectedFunctionHeaderClose', match); // TOFIX: can be various things here...\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatFunctionBody(match, stack, div, funcToken);\n    return match;\n  },\n  eatFunctionBody: function (match, stack, div, funcToken) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'func body';\n      stack.nextBlack = match.tokposb; // create EMPTY list of functions. labels cannot cross function boundaries\n\n      var labelBackup = this.statementLabels;\n      this.statementLabels = [];\n      stack.labels = this.statementLabels;\n    } //#endif\n    // if div, a division can occur _after_ this function expression\n    //this.stats.eatFunctionBody = (+//this.stats.eatFunctionBody||0)+1;\n\n\n    if (match.value != '{') match = this.failsafe('ExpectedFunctionBodyCurlyOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhc = match;\n      if (funcToken) funcToken.lhc = lhc;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatSourceElements(match, stack);\n    if (match.value != '}') match = this.failsafe('ExpectedFunctionBodyCurlyClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhc;\n      lhc.twin = match;\n      if (funcToken) funcToken.rhc = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(div, match, stack);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      // restore label set\n      this.statementLabels = labelBackup;\n    } //#endif\n\n\n    return match;\n  },\n  eatVar: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'var';\n      stack.nextBlack = match.tokposb;\n      match.stack = stack;\n      match.isVarKeyword = true;\n    } //#endif\n\n\n    match = this.eatVarDecl(match, stack);\n    match = this.eatSemiColon(match, stack);\n    return match;\n  },\n  eatVarDecl: function (match, stack, forHeader) {\n    // assumes match is indeed the identifier 'var'\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'var decl';\n      stack.nextBlack = match.tokposb;\n      var targetScope = this.scope;\n\n      while (targetScope.catchScope) targetScope = targetScope[0];\n    } //#endif\n\n\n    var first = true;\n    var varsDeclared = 0;\n\n    do {\n      ++varsDeclared;\n      match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // start: var, iteration: comma\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        var declStack = stack;\n        var stack = [];\n        stack.desc = 'single var decl';\n        stack.varStack = declStack; // reference to the var statement stack, it might hook to jsdoc needed for these vars\n\n        stack.nextBlack = match.tokposb;\n        declStack.push(stack);\n        var singleDecStack = stack;\n        stack = [];\n        stack.desc = 'sub-expression';\n        stack.nextBlack = match.tokposb;\n        singleDecStack.push(stack);\n      } //#endif\n      // next token should be a valid identifier\n\n\n      if (match.name == 12\n      /*eof*/\n      ) {\n          if (first) match = this.failsafe('VarKeywordMissingName', match); // else, ignore. TOFIX: return?\n          else match = this.failsafe('IllegalTrailingComma', match);\n        } else if (match.name != 2\n      /*IDENTIFIER*/\n      ) {\n          match = this.failsafe('VarNamesMayOnlyBeIdentifiers', match);\n        } else if (this.hashStartKeyOrReserved[match.value[0]]\n      /*this.regexStartKeyOrReserved.test(match.value[0])*/\n      && this.regexIsKeywordOrReserved.test(match.value)) {\n        match = this.failsafe('VarNamesCanNotBeReserved', match);\n      } // mark the match as being a variable name. we need it for lookup later :)\n\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        match.meta = 'var name';\n        targetScope.push({\n          value: match.value\n        });\n      } //#endif\n\n\n      match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack = singleDecStack;\n      } //#endif\n      // next token should either be a = , or ;\n      // if = parse an expression and optionally a comma\n\n\n      if (match.value == '=') {\n        if (this.ast) {\n          //#ifdef FULL_AST\n          singleDecStack = stack;\n          stack = [];\n          stack.desc = 'operator-expression';\n          stack.sub = '=';\n          stack.nextBlack = match.tokposb;\n          singleDecStack.push(stack);\n          stack.isAssignment = true;\n        } //#endif\n\n\n        match.isInitialiser = true;\n        match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n        if (this.ast) {\n          //#ifdef FULL_AST\n          stack = singleDecStack;\n        } //#endif\n\n\n        if (!(\n        /*is left hand side start?*/\n        match.name <= 6 || match.name == 14\n        /*error*/\n        || this.regexLhsStart.test(match.value))) match = this.failsafe('VarInitialiserExpressionExpected', match);\n        match = this.eatExpressions(false, match, stack, true, forHeader); // only one expression \n        // var statement: comma or semi now\n        // for statement: semi, comma or 'in'\n      }\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack = declStack;\n      } //#endif\n      // determines proper error message in one case\n\n\n      first = false; // keep parsing name(=expression) sequences as long as you see a comma here\n    } while (match.value == ',');\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.varsDeclared = varsDeclared;\n    } //#endif\n\n\n    return match;\n  },\n  eatIf: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'if';\n      stack.hasElse = false;\n      stack.nextBlack = match.tokposb;\n    } //#endif\n    // (\n    // expression\n    // )\n    // statement\n    // [else statement]\n\n\n    var ifKeyword = match;\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      match.statementHeaderStart = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (!(\n    /*is left hand side start?*/\n    match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\n    match = this.eatExpressions(false, match, stack);\n    if (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      match.statementHeaderStop = true;\n      lhp.twin = match;\n\n      if (stack[stack.length - 1].desc == 'expressions') {\n        // create ref to this expression group to the opening bracket\n        lhp.expressionArg = stack[stack.length - 1];\n      }\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatStatement(false, match, stack); // match might be null here... (if the if-statement was end part of the source)\n\n    if (match && match.value == 'else') {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        ifKeyword.hasElse = match;\n      } //#endif\n\n\n      match = this.eatElse(match, stack);\n    }\n\n    return match;\n  },\n  eatElse: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.hasElse = true;\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'else';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatStatement(false, match, stack);\n    return match;\n  },\n  eatDo: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'do';\n      stack.isIteration = true;\n      stack.nextBlack = match.tokposb;\n      this.statementLabels.push(''); // add \"empty\"\n\n      var doToken = match;\n    } //#endif\n    // statement\n    // while\n    // (\n    // expression\n    // )\n    // semi-colon\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatStatement(false, match, stack);\n    if (match.value != 'while') match = this.failsafe('DoShouldBeFollowedByWhile', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.hasDo = doToken;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      match.statementHeaderStart = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (!(\n    /*is left hand side start?*/\n    match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\n    match = this.eatExpressions(false, match, stack);\n    if (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      match.statementHeaderStop = true;\n      match.isForDoWhile = true; // prevents missing block warnings\n\n      lhp.twin = match;\n\n      if (stack[stack.length - 1].desc == 'expressions') {\n        // create ref to this expression group to the opening bracket\n        lhp.expressionArg = stack[stack.length - 1];\n      }\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatSemiColon(match, stack); // TOFIX: this is not optional according to the spec, but browsers apply ASI anyways\n\n    return match;\n  },\n  eatWhile: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'while';\n      stack.isIteration = true;\n      stack.nextBlack = match.tokposb;\n      this.statementLabels.push(''); // add \"empty\"\n    } //#endif\n    // (\n    // expression\n    // )\n    // statement\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      match.statementHeaderStart = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (!(\n    /*is left hand side start?*/\n    match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\n    match = this.eatExpressions(false, match, stack);\n    if (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      match.statementHeaderStop = true;\n      lhp.twin = match;\n\n      if (stack[stack.length - 1].desc == 'expressions') {\n        // create ref to this expression group to the opening bracket\n        lhp.expressionArg = stack[stack.length - 1];\n      }\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatStatement(false, match, stack);\n    return match;\n  },\n  eatFor: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'for';\n      stack.isIteration = true;\n      stack.nextBlack = match.tokposb;\n      this.statementLabels.push(''); // add \"empty\"\n    } //#endif\n    // either a for(..in..) or for(..;..;..)\n    // start eating an expression but refuse to parse\n    // 'in' on the top-level of that expression. they are fine\n    // in sub-levels (group, array, etc). Now the expression\n    // must be followed by either ';' or 'in'. Else throw.\n    // Branch on that case, ; requires two.\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      match.statementHeaderStart = true;\n      match.forHeaderStart = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // for (either case) may start with var, in which case you'll parse a var declaration before encountering the 'in' or first semi.\n\n    if (match.value == 'var') {\n      match = this.eatVarDecl(match, stack, true);\n    } else if (match.value != ';') {\n      // expressions are optional in for-each\n      if (!(\n      /*is left hand side start?*/\n      match.name <= 6 || this.regexLhsStart.test(match.value))) {\n        this.failignore('StatementHeaderIsNotOptional', match, stack);\n      }\n\n      match = this.eatExpressions(false, match, stack, false, true); // can parse multiple expressions, in is not ok here\n    } // now we parsed an expression if it existed. the next token should be either ';' or 'in'. branch accordingly\n\n\n    if (match.value == 'in') {\n      var declStack = stack[stack.length - 1];\n\n      if (declStack.varsDeclared > 1) {\n        // disallowed. for-in var decls can only have one var name declared\n        this.failignore('ForInCanOnlyDeclareOnVar', match, stack);\n      }\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.forType = 'in';\n        match.forFor = true; // make easy distinction between conditional and iterational operator\n      } //#endif\n      // just parse another expression, where 'in' is allowed.\n\n\n      match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n      match = this.eatExpressions(false, match, stack);\n    } else {\n      if (match.value != ';') match = this.failsafe('ForHeaderShouldHaveSemisOrIn', match);\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.forType = 'each';\n        match.forEachHeaderStart = true;\n      } //#endif\n      // parse another optional no-in expression, another semi and then one more optional no-in expression\n\n\n      match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n      if (\n      /*is left hand side start?*/\n      match.name <= 6 || this.regexLhsStart.test(match.value)) match = this.eatExpressions(false, match, stack); // in is ok here\n\n      if (match.value != ';') match = this.failsafe('ExpectedSecondSemiOfForHeader', match);\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        match.forEachHeaderStop = true;\n      } //#endif\n\n\n      match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n      if (\n      /*is left hand side start?*/\n      match.name <= 6 || this.regexLhsStart.test(match.value)) match = this.eatExpressions(false, match, stack); // in is ok here\n    }\n\n    if (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      match.statementHeaderStop = true;\n      match.forHeaderStop = true;\n      lhp.twin = match;\n\n      if (match.forType == 'in' && stack[stack.length - 1].desc == 'expressions') {\n        // create ref to this expression group to the opening bracket\n        lhp.expressionArg = stack[stack.length - 1];\n      }\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatStatement(false, match, stack);\n    return match;\n  },\n  eatContinue: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'continue';\n      stack.nextBlack = match.tokposb;\n      match.restricted = true;\n    } //#endif\n    // (no-line-break identifier)\n    // ;\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\n\n    if (!match.newline && match.value != ';' && match.name != 12\n    /*EOF*/\n    && match.value != '}') {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        match.isLabel = true;\n        match.isLabelTarget = true;\n        var continueArg = match; // remember to see if this continue parsed a label\n      } //#endif\n      // may only parse exactly an identifier at this point\n\n\n      match = this.eatExpressions(false, match, stack, true, false, true); // first true=onlyOne, second: continue/break arg\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.hasLabel = continueArg != match;\n      } //#endif\n\n\n      if (match.value != ';' && !match.newline && match.name != 12\n      /*eof*/\n      && match.value != '}') match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\n    }\n\n    match = this.eatSemiColon(match, stack);\n    return match;\n  },\n  eatBreak: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var parentstack = stack;\n      stack = [];\n      stack.desc = 'statement';\n      stack.sub = 'break';\n      stack.nextBlack = match.tokposb;\n      parentstack.push(stack);\n      match.restricted = true;\n    } //#endif\n    // (no-line-break identifier)\n    // ;\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\n\n    if (!match.newline && match.value != ';' && match.name != 12\n    /*EOF*/\n    && match.value != '}') {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        match.isLabel = true;\n        match.isLabelTarget = true;\n        var breakArg = match; // remember to see if this break parsed a label\n      } //#endif\n      // may only parse exactly an identifier at this point\n\n\n      match = this.eatExpressions(false, match, stack, true, false, true); // first true=onlyOne, second: continue/break arg\n\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.hasLabel = breakArg != match;\n      } //#endif\n\n\n      if (match.value != ';' && !match.newline && match.name != 12\n      /*eof*/\n      && match.value != '}') match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\n    }\n\n    match = this.eatSemiColon(match, stack);\n    return match;\n  },\n  eatReturn: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'return';\n      stack.nextBlack = match.tokposb;\n      stack.returnFor = this.scope.scopeFor;\n      match.restricted = true;\n    } //#endif\n    // (no-line-break expression)\n    // ;\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\n\n    if (!match.newline && match.value != ';' && match.name != 12\n    /*EOF*/\n    && match.value != '}') {\n      match = this.eatExpressions(false, match, stack);\n    }\n\n    match = this.eatSemiColon(match, stack);\n    return match;\n  },\n  eatThrow: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'throw';\n      stack.nextBlack = match.tokposb;\n      match.restricted = true;\n    } //#endif\n    // (no-line-break expression)\n    // ;\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\n\n    if (match.newline) match = this.failsafe('ThrowCannotHaveReturn', match);\n    if (match.value == ';') match = this.failsafe('ThrowMustHaveArgument', match);\n    match = this.eatExpressions(false, match, stack);\n    match = this.eatSemiColon(match, stack);\n    return match;\n  },\n  eatSwitch: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'switch';\n      stack.nextBlack = match.tokposb;\n      this.statementLabels.push(''); // add \"empty\"\n    } //#endif\n    // meh.\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      match.statementHeaderStart = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n    if (!(\n    /*is left hand side start?*/\n    match.name <= 6 || this.regexLhsStart.test(match.value))) {\n      this.failignore('StatementHeaderIsNotOptional', match, stack);\n    }\n\n    match = this.eatExpressions(false, match, stack);\n    if (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      match.statementHeaderStop = true;\n      lhp.twin = match;\n\n      if (stack[stack.length - 1].desc == 'expressions') {\n        // create ref to this expression group to the opening bracket\n        lhp.expressionArg = stack[stack.length - 1];\n      }\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '{') match = this.failsafe('SwitchBodyStartsWithCurly', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhc = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // you may parse a default case, and only once per switch. but you may do so anywhere.\n\n    var parsedAnything = false;\n\n    while (match.value == 'case' || !stack.parsedSwitchDefault && match.value == 'default') {\n      parsedAnything = true;\n      match = this.eatSwitchClause(match, stack);\n    } // if you didnt parse anything but not encountering a closing curly now, you might be thinking that switches may start with silly stuff\n\n\n    if (!parsedAnything && match.value != '}') {\n      match = this.failsafe('SwitchBodyMustStartWithClause', match);\n    }\n\n    if (stack.parsedSwitchDefault && match.value == 'default') {\n      this.failignore('SwitchCannotHaveDoubleDefault', match, stack);\n    }\n\n    if (match.value != '}' && match.name != 14\n    /*error*/\n    ) match = this.failsafe('SwitchBodyEndsWithCurly', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhc;\n      lhc.twin = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    return match;\n  },\n  eatSwitchClause: function (match, stack) {\n    match = this.eatSwitchHeader(match, stack);\n    match = this.eatSwitchBody(match, stack);\n    return match;\n  },\n  eatSwitchHeader: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      // collect whitespace...\n      var switchHeaderStack = stack;\n      stack.push(stack = []);\n      stack.desc = 'switch clause header';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    if (match.value == 'case') {\n      match = this.eatSwitchCaseHead(match, stack);\n    } else {\n      // default\n      if (this.ast) {\n        //#ifdef FULL_AST\n        switchHeaderStack.hasDefaultClause = true;\n      } //#endif\n\n\n      match = this.eatSwitchDefaultHead(match, stack);\n    }\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      // just to group whitespace (makes certain navigation easier..)\n      stack.push(stack = []);\n      stack.desc = 'colon';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    if (match.value != ':') {\n      match = this.failsafe('SwitchClausesEndWithColon', match);\n    }\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    return match;\n  },\n  eatSwitchBody: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'switch clause body';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n    // parse body of case or default, just so long case and default keywords are not seen and end of switch is not reached\n    // (clause bodies may be empty, for instance to fall through)\n\n\n    var lastMatch = null;\n\n    while (match.value != 'default' && match.value != 'case' && match.value != '}' && match.name != 14\n    /*error*/\n    && match.name != 12\n    /*eof*/\n    && lastMatch != match) {\n      lastMatch = match; // prevents endless loops on error ;)\n\n      match = this.eatStatement(true, match, stack);\n    }\n\n    if (lastMatch == match) this.failsafe('UnexpectedInputSwitch', match);\n    return match;\n  },\n  eatSwitchCaseHead: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.sub = 'case';\n      var caseHeadStack = stack;\n      stack.push(stack = []);\n      stack.desc = 'case';\n      stack.nextBlack = match.tokposb;\n      match.isCase = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n    if (match.value == ':') {\n      this.failignore('CaseMissingExpression', match, stack);\n    } else {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        caseHeadStack.push(stack = []);\n        stack.desc = 'case arg';\n        stack.nextBlack = match.tokposb;\n      } //#endif\n\n\n      match = this.eatExpressions(false, match, stack);\n    }\n\n    return match;\n  },\n  eatSwitchDefaultHead: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.sub = 'default';\n      stack.push(stack = []);\n      stack.desc = 'case';\n      stack.nextBlack = match.tokposb;\n      match.isDefault = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    return match;\n  },\n  eatTryCatchFinally: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'try';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    match = this.eatTry(match, stack);\n\n    if (match.value == 'catch') {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.hasCatch = true;\n      } //#endif\n\n\n      match = this.eatCatch(match, stack);\n    }\n\n    if (match.value == 'finally') {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.hasFinally = true;\n      } //#endif\n\n\n      match = this.eatFinally(match, stack);\n    } // at least a catch or finally block must follow. may be both.\n\n\n    if (!stack.tryHasCatchOrFinally) {\n      this.failignore('TryMustHaveCatchOrFinally', match, stack);\n    }\n\n    return match;\n  },\n  eatTry: function (match, stack) {\n    // block\n    // (catch ( identifier ) block )\n    // (finally block)\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '{') match = this.failsafe('MissingTryBlockCurlyOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'tryblock';\n      stack.nextBlack = match.tokposb;\n      var lhc = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '}') match = this.eatStatements(match, stack);\n    if (match.value != '}') match = this.failsafe('MissingTryBlockCurlyClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhc;\n      lhc.twin = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    return match;\n  },\n  eatCatch: function (match, stack) {\n    stack.tryHasCatchOrFinally = true;\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'catch';\n      stack.nextBlack = match.tokposb; // the catch block has a header which can contain at most one parameter\n      // this parameter is bound to a local stack. formally, if that parameter\n      // shadows another variable, changes made to the variable inside the catch\n      // should not be reflected by the variable being shadowed. however, this\n      // is not very safe to rely on so there ought to be a warning. note that\n      // only this parameter gets bound to this inner scope, other parameters.\n\n      var catchScopeBackup = this.scope;\n      match.scope = this.scope = stack.scope = [this.scope];\n      this.scope.catchScope = true; // mark this as being a catchScope\n      // find first function scope or global scope object...\n\n      var nonCatchScope = catchScopeBackup;\n\n      while (nonCatchScope.catchScope) nonCatchScope = nonCatchScope[0]; // get catch id, which is governed by the function/global scope only\n\n\n      if (!nonCatchScope.catches) nonCatchScope.catches = [];\n      match.catchId = nonCatchScope.catches.length;\n      nonCatchScope.catches.push(match);\n      match.targetScope = nonCatchScope;\n      match.catchScope = this.scope; // ref to back to function that's the cause for this scope\n\n      this.scope.scopeFor = match; // catch clauses dont have a special `this` or `arguments`, map them to their parent scope\n\n      if (catchScopeBackup.global) this.scope.push(catchScopeBackup[0]); // global (has no `arguments` but always a `this`)\n      else if (catchScopeBackup.catchScope) {\n          // tricky. there will at least be a this\n          this.scope.push(catchScopeBackup[1]); // but there might not be an arguments\n\n          if (catchScopeBackup[2] && catchScopeBackup[2].value == 'arguments') this.scope.push(catchScopeBackup[2]);\n        } else this.scope.push(catchScopeBackup[1], catchScopeBackup[2]); // function scope, copy this and arguments\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('CatchHeaderMissingOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.name != 2\n    /*IDENTIFIER*/\n    ) match = this.failsafe('MissingCatchParameter', match);\n\n    if (this.hashStartKeyOrReserved[match.value[0]]\n    /*this.regexStartKeyOrReserved.test(match.value[0])*/\n    && this.regexIsKeywordOrReserved.test(match.value)) {\n      this.failignore('CatchParameterNameMayNotBeReserved', match, stack);\n    }\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.meta = 'var name'; // this is the catch variable. bind it to a scope but keep the scope as\n      // it currently is.\n\n      this.scope.push(match);\n      match.isCatchVar = true;\n    } //#endif\n    // now the catch body will use the outer scope to bind new variables. the problem is that\n    // inner scopes, if any, should have access to the scope variable, so their scope should\n    // be linked to the catch scope. this is a problem in the current architecture but the \n    // idea is to pass on the catchScope as the scope to the eatStatements call, etc.\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != ')') match = this.failsafe('CatchHeaderMissingClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      lhp.twin = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '{') match = this.failsafe('MissingCatchBlockCurlyOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhc = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // catch body. statements are optional.\t\n\n    if (match.value != '}') match = this.eatStatements(match, stack);\n    if (match.value != '}') match = this.failsafe('MissingCatchBlockCurlyClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhc;\n      lhc.twin = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      this.scope = catchScopeBackup;\n    } //#endif\n\n\n    return match;\n  },\n  eatFinally: function (match, stack) {\n    stack.tryHasCatchOrFinally = true;\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'finally';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '{') match = this.failsafe('MissingFinallyBlockCurlyOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhc = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '}') match = this.eatStatements(match, stack);\n    if (match.value != '}') match = this.failsafe('MissingFinallyBlockCurlyClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhc;\n      lhc.twin = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    return match;\n  },\n  eatDebugger: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'debugger';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatSemiColon(match, stack);\n    return match;\n  },\n  eatWith: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.push(stack = []);\n      stack.desc = 'statement';\n      stack.sub = 'with';\n      stack.nextBlack = match.tokposb;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var lhp = match;\n      match.statementHeaderStart = true;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    if (!(\n    /*is left hand side start?*/\n    match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\n    match = this.eatExpressions(false, match, stack);\n    if (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhp;\n      match.statementHeaderStop = true;\n      lhp.twin = match;\n\n      if (stack[stack.length - 1].desc == 'expressions') {\n        // create ref to this expression group to the opening bracket\n        lhp.expressionArg = stack[stack.length - 1];\n      }\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    match = this.eatStatement(false, match, stack);\n    return match;\n  },\n  eatFunction: function (match, stack) {\n    var pe = new ZeParser.Error();\n    this.errorStack.push(pe); // ignore. browsers will accept it anyways\n\n    var error = {\n      start: match.stop,\n      stop: match.stop,\n      name: 14\n      /*error*/\n      ,\n      error: pe\n    };\n    this.specialError(error, match, stack); // now try parsing a function declaration...\n\n    match = this.eatFunctionDeclaration(match, stack);\n    return match;\n  },\n  eatLabelOrExpression: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      var parentstack = stack;\n      stack = [];\n      stack.desc = 'statement';\n      stack.sub = 'expression';\n      stack.nextBlack = match.tokposb;\n      parentstack.push(stack);\n    } //#endif\n    // must be an expression or a labeled statement.\n    // in order to prevent very weird return constructs, we'll first check the first match\n    // if that's an identifier, we'll gobble it here and move on to the second.\n    // if that's a colon, we'll gobble it as a labeled statement. otherwise, we'll pass on\n    // control to eatExpression, with the note that we've already gobbled a \n\n\n    match = this.eatExpressions(true, match, stack); // if we parsed a label, the returned match (colon) will have this property\n\n    if (match.wasLabel) {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.sub = 'labeled';\n      } //#endif\n      // it will have already eaten another statement for the label\n\n    } else {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.sub = 'expression';\n      } //#endif\n      // only parse semi if we didnt parse a label just now...\n\n\n      match = this.eatSemiColon(match, stack);\n    }\n\n    return match;\n  },\n  eatBlock: function (match, stack) {\n    if (this.ast) {\n      //#ifdef FULL_AST\n      stack.sub = 'block';\n      var lhc = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n\n    if (match.value == '}') {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        stack.isEmptyBlock = true;\n      } //#endif\n\n    } else {\n      match = this.eatStatements(match, stack);\n    }\n\n    if (match.value != '}') match = this.failsafe('BlockCurlyClose', match);\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.twin = lhc;\n      lhc.twin = match;\n    } //#endif\n\n\n    match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\n    return match;\n  },\n  eatStatements: function (match, stack) {\n    //this.stats.eatStatements = (+//this.stats.eatStatements||0)+1;\n    // detecting the start of a statement \"quickly\" is virtually impossible.\n    // instead we keep eating statements until the match stops changing\n    // the first argument indicates that the statement is optional. if that\n    // statement was not found, the input match will also be the output.\n    while (match != (match = this.eatStatement(true, match, stack)));\n\n    return match;\n  },\n  eatStatement: function (isOptional, match, stack) {\n    if (!match && isOptional) return match; // eof\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      match.statementStart = true;\n      var pstack = stack;\n      stack = [];\n      stack.desc = 'statement-parent';\n      stack.nextBlack = match.tokposb;\n      pstack.push(stack); // list of labels, these are bound to statements (and can access any label higher up, but not cross functions)\n\n      var labelBackup = this.statementLabels;\n      this.statementLabels = [labelBackup]; // make ref like tree. we need this to catch labels parsed beyond the current position (not yet known to use)\n\n      stack.labels = this.statementLabels;\n    } //#endif\n\n\n    if (match.name == 2\n    /*IDENTIFIER*/\n    ) {\n        // try to determine whether it's a statement\n        // (block/empty statements come later, this branch is only for identifiers)\n        switch (match.value) {\n          case 'var':\n            match = this.eatVar(match, stack);\n            break;\n\n          case 'if':\n            match = this.eatIf(match, stack);\n            break;\n\n          case 'do':\n            match = this.eatDo(match, stack);\n            break;\n\n          case 'while':\n            match = this.eatWhile(match, stack);\n            break;\n\n          case 'for':\n            match = this.eatFor(match, stack);\n            break;\n\n          case 'continue':\n            match = this.eatContinue(match, stack);\n            break;\n\n          case 'break':\n            match = this.eatBreak(match, stack);\n            break;\n\n          case 'return':\n            match = this.eatReturn(match, stack);\n            break;\n\n          case 'throw':\n            match = this.eatThrow(match, stack);\n            break;\n\n          case 'switch':\n            match = this.eatSwitch(match, stack);\n            break;\n\n          case 'try':\n            match = this.eatTryCatchFinally(match, stack);\n            break;\n\n          case 'debugger':\n            match = this.eatDebugger(match, stack);\n            break;\n\n          case 'with':\n            match = this.eatWith(match, stack);\n            break;\n\n          case 'function':\n            // I'm not sure whether this is at all possible.... (but it's bad, either way ;)\n            // so add an error token, but parse the function as if it was a declaration.\n            this.failignore('StatementMayNotStartWithFunction', match, stack); // now parse as declaration... (most likely?)\n\n            match = this.eatFunctionDeclaration(match, stack);\n            break;\n\n          default:\n            // either a label or an expression-statement\n            match = this.eatLabelOrExpression(match, stack);\n        }\n      } else if (match.value == '{') {\n      // Block (make sure you do this before checking for expression...)\n      match = this.eatBlock(match, stack);\n    } else if ( // expression statements:\n    match.isString || match.isNumber || match.name == 1\n    /*REG_EX*/\n    || this.regexLhsStart.test(match.value)) {\n      match = this.eatExpressions(false, match, stack);\n      match = this.eatSemiColon(match, stack);\n    } else if (match.value == ';') {\n      // empty statement\n      match.emptyStatement = true;\n      match = this.eatSemiColon(match, stack);\n    } else if (!isOptional) {\n      if (this.ast) {\n        //#ifdef FULL_AST\n        // unmark token as being start of a statement, since it's obviously not\n        match.statementStart = false;\n      } //#endif\n\n\n      match = this.failsafe('UnableToParseStatement', match);\n    } else {\n      // unmark token as being start of a statement, since it's obviously not\n      if (this.ast) match.statementStart = true;\n    }\n\n    if (this.ast) {\n      //#ifdef FULL_AST\n      if (!stack.length) pstack.length = pstack.length - 1; // restore label set\n\n      this.statementLabels = labelBackup;\n    } //#endif\n\n\n    return match;\n  },\n  eatSourceElements: function (match, stack) {\n    //this.stats.eatSourceElements = (+//this.stats.eatSourceElements||0)+1;\n    // detecting the start of a statement \"quickly\" is virtually impossible.\n    // instead we keep eating statements until the match stops changing\n    // the first argument indicates that the statement is optional. if that\n    // statement was not found, the input match will also be the output.\n    while (match != oldMatch) {\n      // difficult to determine whether ` && match.name != 12/*EOF*/` is actually speeding things up. it's an extra check vs one less call to eatStatement...\n      var oldMatch = match; // always try to eat function declaration first. otherwise 'function' at the start might cause eatStatement to throw up\n\n      if (match.value == 'function') match = this.eatFunctionDeclaration(match, stack);else match = this.eatStatement(true, match, stack);\n    }\n\n    return match;\n  },\n  failsafe: function (name, match, doNotAddMatch) {\n    var pe = new ZeParser.Error(name, match);\n    this.errorStack.push(pe);\n\n    if (!doNotAddMatch) {\n      // the match was bad, but add it to the ast anyways. in most cases this is the case but in some its not.\n      // the tokenizer will pick up on the errorEscape property and add it after the match we passed on.\n      if (this.tokenizer.errorEscape) this.stack.push(this.tokenizer.errorEscape);\n      this.tokenizer.errorEscape = match;\n    }\n\n    var error = {\n      start: match.start,\n      stop: match.start,\n      len: 0,\n      name: 14\n      /*error*/\n      ,\n      error: pe,\n      value: ''\n    };\n    this.tokenizer.addTokenToStreamBefore(error, match);\n    return error;\n  },\n  failignore: function (name, match, stack) {\n    var pe = new ZeParser.Error(name, match);\n    this.errorStack.push(pe); // ignore the error (this will screw up :)\n\n    var error = {\n      start: match.start,\n      stop: match.start,\n      len: 0,\n      name: 14\n      /*error*/\n      ,\n      error: pe,\n      value: ''\n    };\n    stack.push(error);\n    this.tokenizer.addTokenToStreamBefore(error, match);\n  },\n  failSpecial: function (error, match, stack) {\n    // we cant really ignore this. eat the token\n    stack.push(error);\n    this.tokenizer.addTokenToStreamBefore(error, match);\n  },\n  0: 0\n}; //#ifdef TEST_SUITE\n\nZeParser.testSuite = function (tests) {\n  var ok = 0;\n  var fail = 0;\n  var start = +new Date();\n\n  for (var i = 0; i < tests.length; ++i) {\n    var test = tests[i],\n        input = test[0],\n        desc = test[test.length - 1],\n        stack = [];\n\n    try {\n      new ZeParser(input, new Tokenizer(input), stack).parse();\n      ++ok;\n    } catch (e) {\n      ++fail;\n    }\n\n    document.getElementsByTagName('div')[0].innerHTML = 'Ze parser test suite finished (' + (+new Date() - start) + ' ms). ok:' + ok + ', fail:' + fail;\n  }\n\n  ;\n}; //#endif\n\n\nZeParser.regexLhsStart = /[\\+\\-\\~\\!\\(\\{\\[]/;\n/*\r\nZeParser.regexStartKeyword = /[bcdefinrstvw]/;\r\nZeParser.regexKeyword = /^break$|^catch$|^continue$|^debugger$|^default$|^delete$|^do$|^else$|^finally$|^for$|^function$|^if$|^in$|^instanceof$|^new$|^return$|^switch$|^this$|^throw$|^try$|^typeof$|^var$|^void$|^while$|^with$/;\r\nZeParser.regexStartReserved = /[ceis]/;\r\nZeParser.regexReserved = /^class$|^const$|^enum$|^export$|^extends$|^import$|^super$/;\r\n*/\n\nZeParser.regexStartKeyOrReserved = /[bcdefinrstvw]/;\nZeParser.hashStartKeyOrReserved = Object.create ? Object.create(null, {\n  b: {\n    value: 1\n  },\n  c: {\n    value: 1\n  },\n  d: {\n    value: 1\n  },\n  e: {\n    value: 1\n  },\n  f: {\n    value: 1\n  },\n  i: {\n    value: 1\n  },\n  n: {\n    value: 1\n  },\n  r: {\n    value: 1\n  },\n  s: {\n    value: 1\n  },\n  t: {\n    value: 1\n  },\n  v: {\n    value: 1\n  },\n  w: {\n    value: 1\n  }\n}) : {\n  b: 1,\n  c: 1,\n  d: 1,\n  e: 1,\n  f: 1,\n  i: 1,\n  n: 1,\n  r: 1,\n  s: 1,\n  t: 1,\n  v: 1,\n  w: 1\n};\nZeParser.regexIsKeywordOrReserved = /^break$|^catch$|^continue$|^debugger$|^default$|^delete$|^do$|^else$|^finally$|^for$|^function$|^if$|^in$|^instanceof$|^new$|^return$|^switch$|^case$|^this$|^true$|^false$|^null$|^throw$|^try$|^typeof$|^var$|^void$|^while$|^with$|^class$|^const$|^enum$|^export$|^extends$|^import$|^super$/;\nZeParser.regexAssignments = /^[\\+\\-\\*\\%\\&\\|\\^\\/]?=$|^\\<\\<\\=$|^\\>{2,3}\\=$/;\nZeParser.regexNonAssignmentBinaryExpressionOperators = /^[\\+\\-\\*\\%\\|\\^\\&\\?\\/]$|^[\\<\\>]\\=?$|^[\\=\\!]\\=\\=?$|^\\<\\<|\\>\\>\\>?$|^\\&\\&$|^\\|\\|$/;\nZeParser.regexUnaryKeywords = /^delete$|^void$|^typeof$|^new$/;\nZeParser.hashUnaryKeywordStart = Object.create ? Object.create(null, {\n  d: {\n    value: 1\n  },\n  v: {\n    value: 1\n  },\n  t: {\n    value: 1\n  },\n  n: {\n    value: 1\n  }\n}) : {\n  d: 1,\n  v: 1,\n  t: 1,\n  n: 1\n};\nZeParser.regexUnaryOperators = /[\\+\\-\\~\\!]/;\nZeParser.regexLiteralKeywords = /^this$|^null$|^true$|^false$/;\n\nZeParser.Error = function (type, match) {\n  //if (type == 'BreakOrContinueArgMustBeJustIdentifier') throw here;\n  this.msg = ZeParser.Errors[type].msg;\n  this.before = ZeParser.Errors[type].before;\n  this.match = match;\n};\n\nZeParser.Errors = {\n  NoASI: {\n    msg: 'Expected semi-colon, was unable to apply ASI'\n  },\n  ExpectedAnotherExpressionComma: {\n    msg: 'expecting another (left hand sided) expression after the comma'\n  },\n  ExpectedAnotherExpressionRhs: {\n    msg: \"expected a rhs expression\"\n  },\n  UnclosedGroupingOperator: {\n    msg: \"Unclosed grouping operator\"\n  },\n  GroupingShouldStartWithExpression: {\n    msg: 'The grouping operator (`(`) should start with a left hand sided expression'\n  },\n  ArrayShouldStartWithExpression: {\n    msg: 'The array literal (`[`) should start with a left hand sided expression'\n  },\n  UnclosedPropertyBracket: {\n    msg: 'Property bracket was not closed after expression (expecting `]`)'\n  },\n  IllegalPropertyNameToken: {\n    msg: 'Object literal property names can only be assigned as strings, numbers or identifiers'\n  },\n  IllegalGetterSetterNameToken: {\n    msg: 'Name of a getter/setter can only be assigned as strings, numbers or identifiers'\n  },\n  GetterSetterNameFollowedByOpenParen: {\n    msg: 'The name of the getter/setter should immediately be followed by the opening parenthesis `(`'\n  },\n  GetterHasNoArguments: {\n    msg: 'The opening parenthesis `(` of the getter should be immediately followed by the closing parenthesis `)`, the getter cannot have an argument'\n  },\n  IllegalSetterArgumentNameToken: {\n    msg: 'Expecting the name of the argument of a setter, can only be assigned as strings, numbers or identifiers'\n  },\n  SettersOnlyGetOneArgument: {\n    msg: 'Setters have one and only one argument, missing the closing parenthesis `)`'\n  },\n  SetterHeaderShouldHaveClosingParen: {\n    msg: 'After the first argument of a setter should come a closing parenthesis `)`'\n  },\n  SettersMustHaveArgument: {\n    msg: 'Setters must have exactly one argument defined'\n  },\n  UnclosedObjectLiteral: {\n    msg: 'Expected to find a comma `,` for the next expression or a closing curly brace `}` to end the object literal'\n  },\n  FunctionNameMustNotBeReserved: {\n    msg: 'Function name may not be a keyword or a reserved word'\n  },\n  ExpressionMayNotStartWithKeyword: {\n    msg: 'Expressions may not start with keywords or reserved words that are not in this list: [this, null, true, false, void, typeof, delete, new]'\n  },\n  LabelsMayOnlyBeIdentifiers: {\n    msg: 'Label names may only be defined as an identifier'\n  },\n  LabelsMayNotBeReserved: {\n    msg: 'Labels may not be a keyword or a reserved word'\n  },\n  UnknownToken: {\n    msg: 'Unknown token encountered, dont know how to proceed'\n  },\n  PropertyNamesMayOnlyBeIdentifiers: {\n    msg: 'The tokens of property names accessed through the dot operator may only be identifiers'\n  },\n  SquareBracketExpectsExpression: {\n    msg: 'The square bracket property access expects an expression'\n  },\n  SquareBracketsMayNotBeEmpty: {\n    msg: 'Square brackets may never be empty, expecting an expression'\n  },\n  UnclosedSquareBrackets: {\n    msg: 'Unclosed square bracket encountered, was expecting `]` after the expression'\n  },\n  UnclosedCallParens: {\n    msg: 'Unclosed call parenthesis, expecting `)` after the optional expression'\n  },\n  InvalidCenterTernaryExpression: {\n    msg: 'Center expression of ternary operator should be a regular expression (but may not contain the comma operator directly)'\n  },\n  UnfinishedTernaryOperator: {\n    msg: 'Encountered a ternary operator start (`?`) but did not find the required colon (`:`) after the center expression'\n  },\n  TernarySecondExpressionCanNotContainComma: {\n    msg: 'The second and third expressions of the ternary operator can/may not \"directly\" contain a comma operator'\n  },\n  InvalidRhsExpression: {\n    msg: 'Expected a right hand side expression after the operator (which should also be a valid lhs) but did not find one'\n  },\n  FunctionDeclarationsMustHaveName: {\n    msg: 'Function declaration must have name'\n  },\n  FunctionNameMayNotBeReserved: {\n    msg: 'Function name may not be a keyword or reserved word'\n  },\n  ExpectingFunctionHeaderStart: {\n    msg: 'Expected the opening parenthesis of the function header'\n  },\n  FunctionArgumentsCanNotBeReserved: {\n    msg: 'Function arguments may not be keywords or reserved words'\n  },\n  FunctionParametersMustBeIdentifiers: {\n    msg: 'Function arguments must be identifiers'\n  },\n  ExpectedFunctionHeaderClose: {\n    msg: 'Expected the closing parenthesis `)` of the function header'\n  },\n  ExpectedFunctionBodyCurlyOpen: {\n    msg: 'Expected the opening curly brace `{` for the function body'\n  },\n  ExpectedFunctionBodyCurlyClose: {\n    msg: 'Expected the closing curly brace `}` for the function body'\n  },\n  VarNamesMayOnlyBeIdentifiers: {\n    msg: 'Missing variable name, must be a proper identifier'\n  },\n  VarNamesCanNotBeReserved: {\n    msg: 'Variable names may not be keywords or reserved words'\n  },\n  VarInitialiserExpressionExpected: {\n    msg: 'The initialiser of the variable statement should be an expression without comma'\n  },\n  ExpectedStatementHeaderOpen: {\n    msg: 'Expected opening parenthesis `(` for statement header'\n  },\n  StatementHeaderIsNotOptional: {\n    msg: 'Statement header must not be empty'\n  },\n  ExpectedStatementHeaderClose: {\n    msg: 'Expected closing parenthesis `)` for statement header'\n  },\n  DoShouldBeFollowedByWhile: {\n    msg: 'The do-while statement requires the `while` keyword after the expression'\n  },\n  ExpectedSecondSemiOfForHeader: {\n    msg: 'Expected the second semi-colon of the for-each header'\n  },\n  ForHeaderShouldHaveSemisOrIn: {\n    msg: 'The for-header should contain at least the `in` operator or two semi-colons (`;`)'\n  },\n  SwitchBodyStartsWithCurly: {\n    msg: 'The body of a switch statement starts with a curly brace `{`'\n  },\n  SwitchClausesEndWithColon: {\n    msg: 'Switch clauses (`case` and `default`) end with a colon (`:`)'\n  },\n  SwitchCannotHaveDoubleDefault: {\n    msg: 'Switches cannot have more than one `default` clause'\n  },\n  SwitchBodyEndsWithCurly: {\n    msg: 'The body of a switch statement ends with a curly brace `}`'\n  },\n  MissingTryBlockCurlyOpen: {\n    msg: 'Missing the opening curly brace (`{`) for the block of the try statement'\n  },\n  MissingTryBlockCurlyClose: {\n    msg: 'Missing the closing curly brace (`}`) for the block of the try statement'\n  },\n  CatchHeaderMissingOpen: {\n    msg: 'Missing the opening parenthesis of the catch header'\n  },\n  MissingCatchParameter: {\n    msg: 'Catch clauses should have exactly one argument which will be bound to the error object being thrown'\n  },\n  CatchParameterNameMayNotBeReserved: {\n    msg: 'Catch clause parameter may not be a keyword or reserved word'\n  },\n  CatchHeaderMissingClose: {\n    msg: 'Missing the closing parenthesis of the catch header'\n  },\n  MissingCatchBlockCurlyOpen: {\n    msg: 'Missing the opening curly brace (`{`) for the block of the catch statement'\n  },\n  MissingCatchBlockCurlyClose: {\n    msg: 'Missing the closing curly brace (`}`) for the block of the catch statement'\n  },\n  MissingFinallyBlockCurlyOpen: {\n    msg: 'Missing the opening curly brace (`{`) for the block of the finally statement'\n  },\n  MissingFinallyBlockCurlyClose: {\n    msg: 'Missing the closing curly brace (`}`) for the block of the finally statement'\n  },\n  StatementMayNotStartWithFunction: {\n    msg: 'statements may not start with function...',\n    before: true\n  },\n  BlockCurlyClose: {\n    msg: 'Expected the closing curly (`}`) for a block statement'\n  },\n  BlockCurlyOpen: {\n    msg: 'Expected the closing curly (`}`) for a block statement'\n  },\n  UnableToParseStatement: {\n    msg: 'Was unable to find a statement when it was requested'\n  },\n  IllegalDoubleCommaInObjectLiteral: {\n    msg: 'A double comma in object literals is not allowed'\n  },\n  ObjectLiteralExpectsColonAfterName: {\n    msg: 'After every property name (identifier, string or number) a colon (`:`) should follow'\n  },\n  ThrowMustHaveArgument: {\n    msg: 'The expression argument for throw is not optional'\n  },\n  ThrowCannotHaveReturn: {\n    msg: 'There may not be a return between throw and the start of its expression argument'\n  },\n  SwitchBodyMustStartWithClause: {\n    msg: 'The body of a switch clause must start with at a case or default clause (but may be empty, which would be silly)'\n  },\n  BreakOrContinueArgMustBeJustIdentifier: {\n    msg: 'The argument to a break or continue statement must be exactly and only an identifier (an existing label)'\n  },\n  AssignmentNotAllowedAfterNonAssignmentInExpression: {\n    msg: 'An assignment is not allowed if it is preceeded by a non-expression operator in the same expression-level'\n  },\n  IllegalLhsForAssignment: {\n    msg: 'Illegal left hand side for assignment (you cannot assign to things like string literals, number literals or function calls}'\n  },\n  VarKeywordMissingName: {\n    msg: 'Var keyword should be followed by a variable name'\n  },\n  IllegalTrailingComma: {\n    msg: 'Illegal trailing comma found'\n  },\n  ObjectLiteralMissingPropertyValue: {\n    msg: 'Missing object literal property value'\n  },\n  TokenizerError: {\n    msg: 'Tokenizer encountered unexpected input'\n  },\n  LabelRequiresStatement: {\n    msg: 'Saw a label without the (required) statement following'\n  },\n  DidNotExpectElseHere: {\n    msg: 'Did not expect an else here. To what if should it belong? Maybe you put a ; after the if-block? (if(x){};else{})'\n  },\n  UnexpectedToken: {\n    msg: 'Found an unexpected token and have no idea why'\n  },\n  InvalidPostfixOperandArray: {\n    msg: 'You cannot apply ++ or -- to an array'\n  },\n  InvalidPostfixOperandObject: {\n    msg: 'You cannot apply ++ or -- to an object'\n  },\n  InvalidPostfixOperandFunction: {\n    msg: 'You cannot apply ++ or -- to a function'\n  },\n  CaseMissingExpression: {\n    msg: 'Case expects an expression before the colon'\n  },\n  TryMustHaveCatchOrFinally: {\n    msg: 'The try statement must have a catch or finally block'\n  },\n  UnexpectedInputSwitch: {\n    msg: 'Unexpected input while parsing a switch clause...'\n  },\n  ForInCanOnlyDeclareOnVar: {\n    msg: 'For-in header can only introduce one new variable'\n  }\n};","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/zeparser/ZeParser.js"],"names":["exports","Tokenizer","require","ZeParser","inp","tok","stack","simple","input","tokenizer","root","scope","value","isDeclared","isEcma","thisIsGlobal","global","statementLabels","errorStack","labels","regexLhsStart","regexStartKeyOrReserved","hashStartKeyOrReserved","regexIsKeywordOrReserved","regexAssignments","regexNonAssignmentBinaryExpressionOperators","regexUnaryKeywords","hashUnaryKeywordStart","regexUnaryOperators","regexLiteralKeywords","testing","ast","parse","parser","e","console","log","createParser","prototype","match","storeCurrentAndFetchNextToken","eatSourceElements","cycled","name","failignore","errorEscape","push","eatSemiColon","semi","newline","asi","start","stop","addTokenToStreamBefore","eatExpressions","mayParseLabeledStatementInstead","onlyOne","forHeader","isBreakOrContinueArg","pstack","desc","nextBlack","tokposb","parsedExpressions","first","parsedNonAssignmentOperator","test","failsafe","astack","parseAnotherExpression","estack","news","parsedUnaryOperator","isUnary","isUnaryOp","acceptAssignment","groupStack","lhp","isGroupStart","twin","isGroupStop","length","expressionArg","sub","hasArrayLiteral","lhsb","isArrayLiteralStart","arrays","arrayId","targetScope","foundAtLeastOneComma","isArrayLiteralStop","hasObjectLiteral","isObjectLiteralStart","objects","objectId","targetObject","lhc","isNumber","isString","objLitStack","isObjectLiteralPair","propNameStack","propName","isPropertyName","getset","isPropertyOf","eatObjectLiteralColonAndBody","isAccessor","eatFunctionBody","isObjectLiteralStop","oldstack","isFunction","functions","functionId","oldscope","functionStack","varType","upper","scopeFor","isFuncExprKeyword","funcExprToken","funcName","meta","eatFunctionParametersAndBody","possibleLabel","leadValue","isLabel","isLabelDeclaration","errorIdToReplace","eatStatement","error","msg","Errors","UnableToParseStatement","Error","wasLabel","tokenError","pe","failSpecial","propertyAccessStart","propertyAccessStop","isCallExpressionStart","parensBelongToNew","isCallExpressionStop","ternary","isAssignment","isBinaryOperator","ostack","numberOfExpressions","expressionCount","eatFunctionDeclaration","prevscope","isFuncDeclKeyword","functionKeyword","propValueStack","prevMatch","div","funcToken","paramNames","rhp","labelBackup","rhc","eatVar","isVarKeyword","eatVarDecl","catchScope","varsDeclared","declStack","varStack","singleDecStack","isInitialiser","eatIf","hasElse","ifKeyword","statementHeaderStart","statementHeaderStop","eatElse","eatDo","isIteration","doToken","hasDo","isForDoWhile","eatWhile","eatFor","forHeaderStart","forType","forFor","forEachHeaderStart","forEachHeaderStop","forHeaderStop","eatContinue","restricted","isLabelTarget","continueArg","hasLabel","eatBreak","parentstack","breakArg","eatReturn","returnFor","eatThrow","eatSwitch","parsedAnything","parsedSwitchDefault","eatSwitchClause","eatSwitchHeader","eatSwitchBody","switchHeaderStack","eatSwitchCaseHead","hasDefaultClause","eatSwitchDefaultHead","lastMatch","caseHeadStack","isCase","isDefault","eatTryCatchFinally","eatTry","hasCatch","eatCatch","hasFinally","eatFinally","tryHasCatchOrFinally","eatStatements","catchScopeBackup","nonCatchScope","catches","catchId","isCatchVar","eatDebugger","eatWith","eatFunction","specialError","eatLabelOrExpression","eatBlock","isEmptyBlock","isOptional","statementStart","emptyStatement","oldMatch","doNotAddMatch","len","testSuite","tests","ok","fail","Date","i","document","getElementsByTagName","innerHTML","Object","create","b","c","d","f","n","r","s","t","v","w","type","before","NoASI","ExpectedAnotherExpressionComma","ExpectedAnotherExpressionRhs","UnclosedGroupingOperator","GroupingShouldStartWithExpression","ArrayShouldStartWithExpression","UnclosedPropertyBracket","IllegalPropertyNameToken","IllegalGetterSetterNameToken","GetterSetterNameFollowedByOpenParen","GetterHasNoArguments","IllegalSetterArgumentNameToken","SettersOnlyGetOneArgument","SetterHeaderShouldHaveClosingParen","SettersMustHaveArgument","UnclosedObjectLiteral","FunctionNameMustNotBeReserved","ExpressionMayNotStartWithKeyword","LabelsMayOnlyBeIdentifiers","LabelsMayNotBeReserved","UnknownToken","PropertyNamesMayOnlyBeIdentifiers","SquareBracketExpectsExpression","SquareBracketsMayNotBeEmpty","UnclosedSquareBrackets","UnclosedCallParens","InvalidCenterTernaryExpression","UnfinishedTernaryOperator","TernarySecondExpressionCanNotContainComma","InvalidRhsExpression","FunctionDeclarationsMustHaveName","FunctionNameMayNotBeReserved","ExpectingFunctionHeaderStart","FunctionArgumentsCanNotBeReserved","FunctionParametersMustBeIdentifiers","ExpectedFunctionHeaderClose","ExpectedFunctionBodyCurlyOpen","ExpectedFunctionBodyCurlyClose","VarNamesMayOnlyBeIdentifiers","VarNamesCanNotBeReserved","VarInitialiserExpressionExpected","ExpectedStatementHeaderOpen","StatementHeaderIsNotOptional","ExpectedStatementHeaderClose","DoShouldBeFollowedByWhile","ExpectedSecondSemiOfForHeader","ForHeaderShouldHaveSemisOrIn","SwitchBodyStartsWithCurly","SwitchClausesEndWithColon","SwitchCannotHaveDoubleDefault","SwitchBodyEndsWithCurly","MissingTryBlockCurlyOpen","MissingTryBlockCurlyClose","CatchHeaderMissingOpen","MissingCatchParameter","CatchParameterNameMayNotBeReserved","CatchHeaderMissingClose","MissingCatchBlockCurlyOpen","MissingCatchBlockCurlyClose","MissingFinallyBlockCurlyOpen","MissingFinallyBlockCurlyClose","StatementMayNotStartWithFunction","BlockCurlyClose","BlockCurlyOpen","IllegalDoubleCommaInObjectLiteral","ObjectLiteralExpectsColonAfterName","ThrowMustHaveArgument","ThrowCannotHaveReturn","SwitchBodyMustStartWithClause","BreakOrContinueArgMustBeJustIdentifier","AssignmentNotAllowedAfterNonAssignmentInExpression","IllegalLhsForAssignment","VarKeywordMissingName","IllegalTrailingComma","ObjectLiteralMissingPropertyValue","TokenizerError","LabelRequiresStatement","DidNotExpectElseHere","UnexpectedToken","InvalidPostfixOperandArray","InvalidPostfixOperandObject","InvalidPostfixOperandFunction","CaseMissingExpression","TryMustHaveCatchOrFinally","UnexpectedInputSwitch","ForInCanOnlyDeclareOnVar"],"mappings":"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","sourcesContent":["if (typeof exports !== 'undefined') {\r\n\tvar Tokenizer = require('./Tokenizer').Tokenizer;\r\n\texports.ZeParser = ZeParser;\r\n}\r\n\r\n/**\r\n * This is my js Parser: Ze. It's actually the post-dev pre-cleanup version. Clearly.\r\n * Some optimizations have been applied :)\r\n * (c) Peter van der Zee, qfox.nl\r\n * @param {String} inp Input\r\n * @param {Tokenizer} tok\r\n * @param {Array} stack The tokens will be put in this array. If you're looking for the AST, this would be it :)\r\n */\r\nfunction ZeParser(inp, tok, stack, simple){\r\n\tthis.input = inp;\r\n\tthis.tokenizer = tok;\r\n\tthis.stack = stack;\r\n\tthis.stack.root = true;\r\n\tthis.scope = stack.scope = [{value:'this', isDeclared:true, isEcma:true, thisIsGlobal:true}]; // names of variables\r\n\tthis.scope.global = true;\r\n\tthis.statementLabels = [];\r\n\r\n\tthis.errorStack = [];\r\n\r\n\tstack.scope = this.scope; // hook root\r\n\tstack.labels = this.statementLabels;\r\n\r\n\tthis.regexLhsStart = ZeParser.regexLhsStart;\r\n/*\r\n\tthis.regexStartKeyword = ZeParser.regexStartKeyword;\r\n\tthis.regexKeyword = ZeParser.regexKeyword;\r\n\tthis.regexStartReserved = ZeParser.regexStartReserved;\r\n\tthis.regexReserved = ZeParser.regexReserved;\r\n*/\r\n\tthis.regexStartKeyOrReserved = ZeParser.regexStartKeyOrReserved;\r\n\tthis.hashStartKeyOrReserved = ZeParser.hashStartKeyOrReserved;\r\n\tthis.regexIsKeywordOrReserved = ZeParser.regexIsKeywordOrReserved;\r\n\tthis.regexAssignments = ZeParser.regexAssignments;\r\n\tthis.regexNonAssignmentBinaryExpressionOperators = ZeParser.regexNonAssignmentBinaryExpressionOperators;\r\n\tthis.regexUnaryKeywords = ZeParser.regexUnaryKeywords;\r\n\tthis.hashUnaryKeywordStart = ZeParser.hashUnaryKeywordStart;\r\n\tthis.regexUnaryOperators = ZeParser.regexUnaryOperators;\r\n\tthis.regexLiteralKeywords = ZeParser.regexLiteralKeywords;\r\n\tthis.testing = {'this':1,'null':1,'true':1,'false':1};\r\n\r\n\tthis.ast = !simple; ///#define FULL_AST\r\n};\r\n/**\r\n * Returns just a stacked parse tree (regular array)\r\n * @param {string} input\r\n * @param {boolean} simple=false\r\n * @return {Array}\r\n */\r\nZeParser.parse = function(input, simple){\r\n\tvar tok = new Tokenizer(input);\r\n\tvar stack = [];\r\n\ttry {\r\n\t\tvar parser = new ZeParser(input, tok, stack);\r\n\t\tif (simple) parser.ast = false;\r\n\t\tparser.parse();\r\n\t\treturn stack;\r\n\t} catch (e) {\r\n\t\tconsole.log(\"Parser has a bug for this input, please report it :)\", e);\r\n\t\treturn null;\r\n\t}\r\n};\r\n/**\r\n * Returns a new parser instance with parse details for input\r\n * @param {string} input\r\n * @returns {ZeParser}\r\n */\r\nZeParser.createParser = function(input){\r\n\tvar tok = new Tokenizer(input);\r\n\tvar stack = [];\r\n\ttry {\r\n\t\tvar parser = new ZeParser(input, tok, stack);\r\n\t\tparser.parse();\r\n\t\treturn parser;\r\n\t} catch (e) {\r\n\t\tconsole.log(\"Parser has a bug for this input, please report it :)\", e);\r\n\t\treturn null;\r\n\t}\r\n};\r\nZeParser.prototype = {\r\n\tinput: null,\r\n\ttokenizer: null,\r\n\tstack: null,\r\n\tscope: null,\r\n\tstatementLabels: null,\r\n\terrorStack: null,\r\n\r\n\tast: null,\r\n\r\n\tparse: function(match){\r\n\t\tif (match) match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, this.stack); // meh\r\n\t\telse match = this.tokenizer.storeCurrentAndFetchNextToken(false, null, this.stack, true); // initialization step, dont store the match (there isnt any!)\r\n\r\n\t\tmatch = this.eatSourceElements(match, this.stack);\r\n\r\n\t\tvar cycled = false;\r\n\t\tdo {\r\n\t\t\tif (match && match.name != 12/*eof*/) {\r\n\t\t\t\t// if not already an error, insert an error before it\r\n\t\t\t\tif (match.name != 14/*error*/) this.failignore('UnexpectedToken', match, this.stack);\r\n\t\t\t\t// just parse the token as is and continue.\r\n\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, this.stack);\r\n\t\t\t\tcycled = true;\r\n\t\t\t}\r\n\r\n\t\t// keep gobbling any errors...\r\n\t\t} while (match && match.name == 14/*error*/);\r\n\r\n\t\t// now try again (but only if we gobbled at least one token)...\r\n\t\tif (cycled && match && match.name != 12/*eof*/) match = this.parse(match);\r\n\r\n\t\t// pop the last token off the stack if it caused an error at eof\r\n\t\tif (this.tokenizer.errorEscape) {\r\n\t\t\tthis.stack.push(this.tokenizer.errorEscape);\r\n\t\t\tthis.tokenizer.errorEscape = null;\r\n\t\t}\r\n\r\n\t\treturn match;\r\n\t},\r\n\r\n\teatSemiColon: function(match, stack){\r\n\t\t//this.stats.eatSemiColon = (+//this.stats.eatSemiColon||0)+1;\r\n\t\tif (match.value == ';') match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\telse {\r\n\t\t\t// try asi\r\n\t\t\t// only if:\r\n\t\t\t// - this token was preceeded by at least one newline (match.newline) or next token is }\r\n\t\t\t// - this is EOF\r\n\t\t\t// - prev token was one of return,continue,break,throw (restricted production), not checked here.\r\n\r\n\t\t\t// the exceptions to this rule are \r\n\t\t\t// - if the next line is a regex \r\n\t\t\t// - the semi is part of the for-header. \r\n\t\t\t// these exceptions are automatically caught by the way the parser is built\r\n\r\n\t\t\t// not eof and just parsed semi or no newline preceeding and next isnt }\r\n\t\t\tif (match.name != 12/*EOF*/ && (match.semi || (!match.newline && match.value != '}')) && !(match.newline && (match.value == '++' || match.value == '--'))) {\r\n\t\t\t\tthis.failignore('NoASI', match, stack);\r\n\t\t\t} else {\r\n\t\t\t\t// ASI\r\n\t\t\t\t// (match is actually the match _after_ this asi, so the position of asi is match.start, not stop (!)\r\n\t\t\t\tvar asi = {start:match.start,stop:match.start,name:13/*ASI*/};\r\n\t\t\t\tstack.push(asi);\r\n\t\t\t\t\r\n\t\t\t\t// slip it in the stream, before the current match.\r\n\t\t\t\t// for the other tokens see the tokenizer near the end of the main parsing function\r\n\t\t\t\tthis.tokenizer.addTokenToStreamBefore(asi, match);\r\n\t\t\t}\r\n\t\t}\r\n\t\tmatch.semi = true;\r\n\t\treturn match;\r\n\t},\r\n\t/**\r\n\t * Eat one or more \"AssignmentExpression\"s. May also eat a labeled statement if\r\n\t * the parameters are set that way. This is the only way to linearly distinct between\r\n\t * an expression-statement and a labeled-statement without double lookahead. (ok, maybe not \"only\")\r\n\t * @param {boolean} mayParseLabeledStatementInstead=false If the first token is an identifier and the second a colon, accept this match as a labeled statement instead... Only true if the match in the parameter is an (unreserved) identifier (so no need to validate that further) \r\n\t * @param {Object} match\r\n\t * @param {Array} stack\r\n\t * @param {boolean} onlyOne=false Only parse a AssignmentExpression\r\n\t * @param {boolean} forHeader=false Do not allow the `in` operator\r\n\t * @param {boolean} isBreakOrContinueArg=false The argument for break or continue is always a single identifier\r\n\t * @return {Object}\r\n\t */\r\n\teatExpressions: function(mayParseLabeledStatementInstead, match, stack, onlyOne, forHeader, isBreakOrContinueArg){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar pstack = stack;\r\n\t\t\tstack = [];\r\n\t\t\tstack.desc = 'expressions';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tpstack.push(stack);\r\n\r\n\t\t\tvar parsedExpressions = 0;\r\n\t\t} //#endif\r\n\r\n\t\tvar first = true;\r\n\t\tdo {\r\n\t\t\tvar parsedNonAssignmentOperator = false; // once we parse a non-assignment, this expression can no longer parse an assignment\r\n\t\t\t// TOFIX: can probably get the regex out somehow...\r\n\t\t\tif (!first) {\r\n\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('ExpectedAnotherExpressionComma', match);\r\n\t\t\t}\r\n\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t++parsedExpressions;\r\n\r\n\t\t\t\tvar astack = stack;\r\n\t\t\t\tstack = [];\r\n\t\t\t\tstack.desc = 'expression';\r\n\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\tastack.push(stack);\r\n\t\t\t} //#endif\r\n\r\n\t\t\t// start of expression is given: match\r\n\t\t\t// it should indeed be a properly allowed lhs\r\n\t\t\t// first eat all unary operators\r\n\t\t\t// they can be added to the stack, but we need to ensure they have indeed a valid operator\r\n\r\n\t\t\tvar parseAnotherExpression = true;\r\n\t\t\twhile (parseAnotherExpression) { // keep parsing lhs+operator as long as there is an operator after the lhs.\r\n\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\tvar estack = stack;\r\n\t\t\t\t\tstack = [];\r\n\t\t\t\t\tstack.desc = 'sub-expression';\r\n\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\testack.push(stack);\r\n\r\n\t\t\t\t\tvar news = 0; // encountered new operators waiting for parenthesis\r\n\t\t\t\t} //#endif\r\n\r\n\t\t\t\t// start checking lhs\r\n\t\t\t\t// if lhs is identifier (new/call expression), allow to parse an assignment operator next\r\n\t\t\t\t// otherwise keep eating unary expressions and then any \"value\"\r\n\t\t\t\t// after that search for a binary operator. if we only ate a new/call expression then\r\n\t\t\t\t// also allow to eat assignments. repeat for the rhs.\r\n\t\t\t\tvar parsedUnaryOperator = false;\r\n\t\t\t\tvar isUnary = null;\r\n\t\t\t\twhile (\r\n\t\t\t\t\t!isBreakOrContinueArg && // no unary for break/continue\r\n\t\t\t\t\t(isUnary =\r\n\t\t\t\t\t\t(match.value && this.hashUnaryKeywordStart[match.value[0]] && this.regexUnaryKeywords.test(match.value)) || // (match.value == 'delete' || match.value == 'void' || match.value == 'typeof' || match.value == 'new') ||\r\n\t\t\t\t\t\t(match.name == 11/*PUNCTUATOR*/ && this.regexUnaryOperators.test(match.value))\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (isUnary) match.isUnaryOp = true;\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t// find parenthesis\r\n\t\t\t\t\t\tif (match.value == 'new') ++news;\r\n\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t// ensure that it is in fact a valid lhs-start\r\n\t\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('ExpectedAnotherExpressionRhs', match);\r\n\t\t\t\t\t// not allowed to parse assignment\r\n\t\t\t\t\tparsedUnaryOperator = true;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// if we parsed any kind of unary operator, we cannot be parsing a labeled statement\r\n\t\t\t\tif (parsedUnaryOperator) mayParseLabeledStatementInstead = false;\r\n\r\n\t\t\t\t// so now we know match is a valid lhs-start and not a unary operator\r\n\t\t\t\t// it must be a string, number, regex, identifier \r\n\t\t\t\t// or the start of an object literal ({), array literal ([) or group operator (().\r\n\r\n\t\t\t\tvar acceptAssignment = false;\r\n\r\n\t\t\t\t// take care of the \"open\" cases first (group, array, object)\r\n\t\t\t\tif (match.value == '(') {\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tvar groupStack = stack;\r\n\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\tstack.desc = 'grouped';\r\n\t\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\t\tgroupStack.push(stack);\r\n\r\n\t\t\t\t\t\tvar lhp = match;\r\n\r\n\t\t\t\t\t\tmatch.isGroupStart = true;\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('GroupingShouldStartWithExpression', match);\r\n\t\t\t\t\t// keep parsing expressions as long as they are followed by a comma\r\n\t\t\t\t\tmatch = this.eatExpressions(false, match, stack);\r\n\r\n\t\t\t\t\tif (match.value != ')') match = this.failsafe('UnclosedGroupingOperator', match);\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tmatch.twin = lhp;\r\n\t\t\t\t\t\tlhp.twin = match;\r\n\r\n\t\t\t\t\t\tmatch.isGroupStop = true;\r\n\r\n\t\t\t\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t\t\t\t// create ref to this expression group to the opening paren\r\n\t\t\t\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\r\n\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tstack = groupStack;\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t\t// you can assign to group results. and as long as the group does not contain a comma (and valid ref), it will work too :)\r\n\t\t\t\t\tacceptAssignment = true;\r\n\t\t\t\t// there's an extra rule for [ namely that, it must start with an expression but after that, expressions are optional\r\n\t\t\t\t} else if (match.value == '[') {\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tstack.sub = 'array literal';\r\n\t\t\t\t\t\tstack.hasArrayLiteral = true;\r\n\t\t\t\t\t\tvar lhsb = match;\r\n\r\n\t\t\t\t\t\tmatch.isArrayLiteralStart = true;\r\n\r\n\t\t\t\t\t\tif (!this.scope.arrays) this.scope.arrays = [];\r\n\t\t\t\t\t\tmatch.arrayId = this.scope.arrays.length;\r\n\t\t\t\t\t\tthis.scope.arrays.push(match);\r\n\r\n\t\t\t\t\t\tmatch.targetScope = this.scope;\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t\t// keep parsing expressions as long as they are followed by a comma\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t\t\t\t// arrays may start with \"elided\" commas\r\n\t\t\t\t\twhile (match.value == ',') match = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t\t\t\tvar foundAtLeastOneComma = true; // for entry in while\r\n\t\t\t\t\twhile (foundAtLeastOneComma && match.value != ']') {\r\n\t\t\t\t\t\tfoundAtLeastOneComma = false;\r\n\r\n\t\t\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value)) && match.name != 14/*error*/) match = this.failsafe('ArrayShouldStartWithExpression', match);\r\n\t\t\t\t\t\tmatch = this.eatExpressions(false, match, stack, true);\r\n\r\n\t\t\t\t\t\twhile (match.value == ',') {\r\n\t\t\t\t\t\t\tfoundAtLeastOneComma = true;\r\n\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (match.value != ']') {\r\n\t\t\t\t\t\tmatch = this.failsafe('UnclosedPropertyBracket', match);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tmatch.twin = lhsb;\r\n\t\t\t\t\t\tlhsb.twin = match;\r\n\r\n\t\t\t\t\t\tmatch.isArrayLiteralStop = true;\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\r\n\t\t\t\t\twhile (match.value == '++' || match.value == '--') {\r\n\t\t\t\t\t\t// gobble and ignore?\r\n\t\t\t\t\t\tthis.failignore('InvalidPostfixOperandArray', match, stack);\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t}\r\n\t\t\t\t// object literals need seperate handling...\r\n\t\t\t\t} else if (match.value == '{') {\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tstack.sub = 'object literal';\r\n\t\t\t\t\t\tstack.hasObjectLiteral = true;\r\n\r\n\t\t\t\t\t\tmatch.isObjectLiteralStart = true;\r\n\r\n\t\t\t\t\t\tif (!this.scope.objects) this.scope.objects = [];\r\n\t\t\t\t\t\tmatch.objectId = this.scope.objects.length;\r\n\t\t\t\t\t\tthis.scope.objects.push(match);\r\n\r\n\t\t\t\t\t\tvar targetObject = match;\r\n\t\t\t\t\t\tmatch.targetScope = this.scope;\r\n\t\r\n\t\t\t\t\t\tvar lhc = match;\r\n\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\tif (match.name == 12/*eof*/) {\r\n\t\t\t\t\t\tmatch = this.failsafe('ObjectLiteralExpectsColonAfterName', match);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// ObjectLiteral\r\n\t\t\t\t\t// PropertyNameAndValueList\r\n\r\n\t\t\t\t\twhile (match.value != '}' && match.name != 14/*error*/) { // will stop if next token is } or throw if not and no comma is found\r\n\t\t\t\t\t\t// expecting a string, number, or identifier\r\n\t\t\t\t\t\t//if (match.name != 5/*STRING_SINGLE*/ && match.name != 6/*STRING_DOUBLE*/ && match.name != 3/*NUMERIC_HEX*/ && match.name != 4/*NUMERIC_DEC*/ && match.name != 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t\t// TOFIX: more specific errors depending on type...\r\n\t\t\t\t\t\tif (!match.isNumber && !match.isString && match.name != 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t\t\tmatch = this.failsafe('IllegalPropertyNameToken', match);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tvar objLitStack = stack;\r\n\t\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\t\tstack.desc = 'objlit pair';\r\n\t\t\t\t\t\t\tstack.isObjectLiteralPair = true;\r\n\t\t\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\t\t\tobjLitStack.push(stack);\r\n\r\n\t\t\t\t\t\t\tvar propNameStack = stack;\r\n\t\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\t\tstack.desc = 'objlit pair name';\r\n\t\t\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\t\t\tpropNameStack.push(stack);\r\n\r\n\t\t\t\t\t\t\tpropNameStack.sub = 'data';\r\n\r\n\t\t\t\t\t\t\tvar propName = match;\r\n\t\t\t\t\t\t\tpropName.isPropertyName = true;\r\n\t\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\t\tvar getset = match.value;\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tstack = propNameStack;\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for get/set we parse a function-like definition. but only if it's immediately followed by an identifier (otherwise it'll just be the property 'get' or 'set')\r\n\t\t\t\t\t\tif (getset == 'get') {\r\n\t\t\t\t\t\t\t// \"get\" PropertyName \"(\" \")\" \"{\" FunctionBody \"}\"\r\n\t\t\t\t\t\t\tif (match.value == ':') {\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tpropName.isPropertyOf = targetObject;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tmatch = this.eatObjectLiteralColonAndBody(match, stack);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tmatch.isPropertyOf = targetObject;\r\n\t\t\t\t\t\t\t\t\tpropNameStack.sub = 'getter';\r\n\t\t\t\t\t\t\t\t\tpropNameStack.isAccessor = true;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\t// if (match.name != 2/*IDENTIFIER*/ && match.name != 5/*STRING_SINGLE*/ && match.name != 6/*STRING_DOUBLE*/ && match.name != 3/*NUMERIC_HEX*/ && match.name != 4/*NUMERIC_DEC*/) {\r\n\t\t\t\t\t\t\t\tif (!match.isNumber && !match.isString && match.name != 2/*IDENTIFIER*/) match = this.failsafe('IllegalGetterSetterNameToken', match, true);\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tif (match.value != '(') match = this.failsafe('GetterSetterNameFollowedByOpenParen', match);\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tvar lhp = match;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tif (match.value != ')') match = this.failsafe('GetterHasNoArguments', match);\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tmatch.twin = lhp;\r\n\t\t\t\t\t\t\t\t\tlhp.twin = match;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tmatch = this.eatFunctionBody(match, stack);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (getset == 'set') {\r\n\t\t\t\t\t\t\t// \"set\" PropertyName \"(\" PropertySetParameterList \")\" \"{\" FunctionBody \"}\"\r\n\t\t\t\t\t\t\tif (match.value == ':') {\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tpropName.isPropertyOf = targetObject;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tmatch = this.eatObjectLiteralColonAndBody(match, stack);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tmatch.isPropertyOf = targetObject;\r\n\t\t\t\t\t\t\t\t\tpropNameStack.sub = 'setter';\r\n\t\t\t\t\t\t\t\t\tpropNameStack.isAccessor = true;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tif (!match.isNumber && !match.isString && match.name != 2/*IDENTIFIER*/) match = this.failsafe('IllegalGetterSetterNameToken', match);\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tif (match.value != '(') match = this.failsafe('GetterSetterNameFollowedByOpenParen', match);\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tvar lhp = match;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tif (match.name != 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t\t\t\t\tif (match.value == ')') match = this.failsafe('SettersMustHaveArgument', match);\r\n\t\t\t\t\t\t\t\t\telse match = this.failsafe('IllegalSetterArgumentNameToken', match);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tif (match.value != ')') {\r\n\t\t\t\t\t\t\t\t\tif (match.value == ',') match = this.failsafe('SettersOnlyGetOneArgument', match);\r\n\t\t\t\t\t\t\t\t\telse match = this.failsafe('SetterHeaderShouldHaveClosingParen', match);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t\tmatch.twin = lhp;\r\n\t\t\t\t\t\t\t\t\tlhp.twin = match;\r\n\t\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\t\tmatch = this.eatFunctionBody(match, stack);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// PropertyName \":\" AssignmentExpression\r\n\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\tpropName.isPropertyOf = targetObject;\r\n\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\tmatch = this.eatObjectLiteralColonAndBody(match, stack);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tstack = objLitStack;\r\n\t\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\t\t// one trailing comma allowed\r\n\t\t\t\t\t\tif (match.value == ',') {\r\n\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\tif (match.value == ',') match = this.failsafe('IllegalDoubleCommaInObjectLiteral', match);\r\n\t\t\t\t\t\t} else if (match.value != '}') match = this.failsafe('UnclosedObjectLiteral', match);\r\n\r\n\t\t\t\t\t\t// either the next token is } and the loop breaks or\r\n\t\t\t\t\t\t// the next token is the start of the next PropertyAssignment...\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// closing curly\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tmatch.twin = lhc;\r\n\t\t\t\t\t\tlhc.twin = match;\r\n\r\n\t\t\t\t\t\tmatch.isObjectLiteralStop = true;\r\n\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // next may be div\r\n\t\t\t\t\twhile (match.value == '++' || match.value == '--') {\r\n\t\t\t\t\t\tthis.failignore('InvalidPostfixOperandObject', match, stack);\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (match.value == 'function') { // function expression\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\tvar oldstack = stack;\r\n\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\tstack.desc = 'func expr';\r\n\t\t\t\t\t\tstack.isFunction = true;\r\n\t\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\t\tif (!this.scope.functions) this.scope.functions = [];\r\n\t\t\t\t\t\tmatch.functionId = this.scope.functions.length;\r\n\t\t\t\t\t\tthis.scope.functions.push(match);\r\n\t\t\t\t\t\toldstack.push(stack);\r\n\t\t\t\t\t\tvar oldscope = this.scope;\r\n\t\t\t\t\t\t// add new scope\r\n\t\t\t\t\t\tmatch.scope = stack.scope = this.scope = [\r\n\t\t\t\t\t\t\tthis.scope,\r\n\t\t\t\t\t\t\t{value:'this', isDeclared:true, isEcma:true, functionStack: stack},\r\n\t\t\t\t\t\t\t{value:'arguments', isDeclared:true, isEcma:true, varType:['Object']}\r\n\t\t\t\t\t\t]; // add the current scope (to build chain up-down)\r\n\t\t\t\t\t\tthis.scope.upper = oldscope;\r\n\t\t\t\t\t\t// ref to back to function that's the cause for this scope\r\n\t\t\t\t\t\tthis.scope.scopeFor = match;\r\n\t\t\t\t\t\tmatch.targetScope = oldscope; // consistency\r\n\t\t\t\t\t\tmatch.isFuncExprKeyword = true;\r\n\t\t\t\t\t\tmatch.functionStack = stack;\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t\tvar funcExprToken = match;\r\n\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\tif (mayParseLabeledStatementInstead && match.value == ':') match = this.failsafe('LabelsMayNotBeReserved', match);\r\n\t\t\t\t\tif (match.name == 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t\tfuncExprToken.funcName = match;\r\n\t\t\t\t\t\tmatch.meta = \"func expr name\";\r\n\t\t\t\t\t\tmatch.varType = ['Function'];\r\n\t\t\t\t\t\tmatch.functionStack = stack; // ref to the stack, in case we detect the var being a constructor\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t// name is only available to inner scope\r\n\t\t\t\t\t\t\tthis.scope.push({value:match.value});\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\tif (this.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)) match = this.failsafe('FunctionNameMustNotBeReserved', match);\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmatch = this.eatFunctionParametersAndBody(match, stack, true, funcExprToken); // first token after func-expr is div\r\n\r\n\t\t\t\t\twhile (match.value == '++' || match.value == '--') {\r\n\t\t\t\t\t\tthis.failignore('InvalidPostfixOperandFunction', match, stack);\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t// restore stack and scope\r\n\t\t\t\t\t\tstack = oldstack;\r\n\t\t\t\t\t\tthis.scope = oldscope;\r\n\t\t\t\t\t} //#endif\r\n\t\t\t\t} else if (match.name <= 6) { // IDENTIFIER STRING_SINGLE STRING_DOUBLE NUMERIC_HEX NUMERIC_DEC REG_EX\r\n\t\t\t\t\t// save it in case it turns out to be a label.\r\n\t\t\t\t\tvar possibleLabel = match;\r\n\r\n\t\t\t\t\t// validate the identifier, if any\r\n\t\t\t\t\tif (match.name == 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t// this, null, true, false are actually allowed here\r\n\t\t\t\t\t\t\t!this.regexLiteralKeywords.test(match.value) &&\r\n\t\t\t\t\t\t\t// other reserved words are not\r\n\t\t\t\t\t\t\tthis.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t// if break/continue, we skipped the unary operator check so throw the proper error here\r\n\t\t\t\t\t\t\tif (isBreakOrContinueArg) {\r\n\t\t\t\t\t\t\t\tthis.failignore('BreakOrContinueArgMustBeJustIdentifier', match, stack);\r\n\t\t\t\t\t\t\t} else if (match.value == 'else') {\r\n\t\t\t\t\t\t\t\tthis.failignore('DidNotExpectElseHere', match, stack);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t//if (mayParseLabeledStatementInstead) {new ZeParser.Error('LabelsMayNotBeReserved', match);\r\n\t\t\t\t\t\t\t\t// TOFIX: lookahead to see if colon is following. throw label error instead if that's the case\r\n\t\t\t\t\t\t\t\t// any forbidden keyword at this point is likely to be a statement start.\r\n\t\t\t\t\t\t\t\t// its likely that the parser will take a while to recover from this point...\r\n\t\t\t\t\t\t\t\tthis.failignore('UnexpectedToken', match, stack);\r\n\t\t\t\t\t\t\t\t// TOFIX: maybe i should just return at this point. cut my losses and hope for the best.\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// only accept assignments after a member expression (identifier or ending with a [] suffix)\r\n\t\t\t\t\t\tacceptAssignment = true;\r\n\t\t\t\t\t} else if (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\r\n\r\n\t\t\t\t\t// the current match is the lead value being queried. tag it that way\r\n\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t// dont mark labels\r\n\t\t\t\t\t\tif (!isBreakOrContinueArg) {\r\n\t\t\t\t\t\t\tmatch.meta = 'lead value';\r\n\t\t\t\t\t\t\tmatch.leadValue = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} //#endif\r\n\r\n\r\n\t\t\t\t\t// ok. gobble it.\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // division allowed\r\n\r\n\t\t\t\t\t// now check for labeled statement (if mayParseLabeledStatementInstead then the first token for this expression must be an (unreserved) identifier)\r\n\t\t\t\t\tif (mayParseLabeledStatementInstead && match.value == ':') {\r\n\t\t\t\t\t\tif (possibleLabel.name != 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t\t\t// label was not an identifier\r\n\t\t\t\t\t\t\t// TOFIX: this colon might be a different type of error... more analysis required\r\n\t\t\t\t\t\t\tthis.failignore('LabelsMayOnlyBeIdentifiers', match, stack);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmayParseLabeledStatementInstead = true; // mark label parsed (TOFIX:speed?)\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t\t\t\t\tpossibleLabel.isLabel = true;\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tdelete possibleLabel.meta; // oh oops, it's not a lead value.\r\n\r\n\t\t\t\t\t\t\tpossibleLabel.isLabelDeclaration = true;\r\n\t\t\t\t\t\t\tthis.statementLabels.push(possibleLabel.value);\r\n\r\n\t\t\t\t\t\t\tstack.desc = 'labeled statement';\r\n\t\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\t\tvar errorIdToReplace = this.errorStack.length;\r\n\t\t\t\t\t\t// eat another statement now, its the body of the labeled statement (like if and while)\r\n\t\t\t\t\t\tmatch = this.eatStatement(false, match, stack);\r\n\r\n\t\t\t\t\t\t// if no statement was found, check here now and correct error\r\n\t\t\t\t\t\tif (match.error && match.error.msg == ZeParser.Errors.UnableToParseStatement.msg) {\r\n\t\t\t\t\t\t\t// replace with better error...\r\n\t\t\t\t\t\t\tmatch.error = new ZeParser.Error('LabelRequiresStatement');\r\n\t\t\t\t\t\t\t// also replace on stack\r\n\t\t\t\t\t\t\tthis.errorStack[errorIdToReplace] = match.error;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmatch.wasLabel = true;\r\n\r\n\t\t\t\t\t\treturn match;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmayParseLabeledStatementInstead = false;\r\n\t\t\t\t} else if (match.value == '}') {\r\n\t\t\t\t\t// ignore... its certainly the end of this expression, but maybe asi can be applied...\r\n\t\t\t\t\t// it might also be an object literal expecting more, but that case has been covered else where.\r\n\t\t\t\t\t// if it turns out the } is bad after all, .parse() will try to recover\r\n\t\t\t\t} else if (match.name == 14/*error*/) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (match.tokenError) {\r\n\t\t\t\t\t\t\tvar pe = new ZeParser.Error('TokenizerError', match);\r\n\t\t\t\t\t\t\tpe.msg += ': '+match.error.msg;\r\n\t\t\t\t\t\t\tthis.errorStack.push(pe);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tthis.failSpecial({start:match.start,stop:match.start,name:14/*error*/,error:pe}, match, stack)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t} while (match.name == 14/*error*/);\r\n\t\t\t\t} else if (match.name == 12/*eof*/) {\r\n\t\t\t\t\t// cant parse any further. you're probably just typing...\r\n\t\t\t\t\treturn match;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//if (!this.errorStack.length && match.name != 12/*eof*/) console.log([\"unknown token\", match, stack, Gui.escape(this.input)]);\r\n\t\t\t\t\tthis.failignore('UnknownToken', match, stack);\r\n\t\t\t\t\t// we cant really ignore this. eat the token and try again. possibly you're just typing?\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for \"value\" suffix. property access and call parens.\r\n\t\t\t\twhile (match.value == '.' || match.value == '[' || match.value == '(') {\r\n\t\t\t\t\tif (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\r\n\r\n\t\t\t\t\tif (match.value == '.') {\r\n\t\t\t\t\t\t// property access. read in an IdentifierName (no keyword checks). allow assignments\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\tif (match.name != 2/*IDENTIFIER*/) this.failignore('PropertyNamesMayOnlyBeIdentifiers', match, stack);\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tmatch.isPropertyName = true;\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // may parse div\r\n\t\t\t\t\t\tacceptAssignment = true;\r\n\t\t\t\t\t} else if (match.value == '[') {\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tvar lhsb = match;\r\n\t\t\t\t\t\t\tmatch.propertyAccessStart = true;\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t// property access, read expression list. allow assignments\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) {\r\n\t\t\t\t\t\t\tif (match.value == ']') match = this.failsafe('SquareBracketsMayNotBeEmpty', match);\r\n\t\t\t\t\t\t\telse match = this.failsafe('SquareBracketExpectsExpression', match);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\t\t\t\t\tif (match.value != ']') match = this.failsafe('UnclosedSquareBrackets', match);\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tmatch.twin = lhsb;\r\n\t\t\t\t\t\t\tmatch.propertyAccessStop = true;\r\n\t\t\t\t\t\t\tlhsb.twin = match;\r\n\r\n\t\t\t\t\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\t\t\t\t\tlhsb.expressionArg = stack[stack.length-1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\r\n\t\t\t\t\t\tacceptAssignment = true;\r\n\t\t\t\t\t} else if (match.value == '(') {\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tvar lhp = match;\r\n\t\t\t\t\t\t\tmatch.isCallExpressionStart = true;\r\n\t\t\t\t\t\t\tif (news) {\r\n\t\t\t\t\t\t\t\tmatch.parensBelongToNew = true;\r\n\t\t\t\t\t\t\t\t--news;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t// call expression, eat optional expression list, disallow assignments\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\tif (/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value)) match = this.eatExpressions(false, match, stack); // arguments are optional\r\n\t\t\t\t\t\tif (match.value != ')') match = this.failsafe('UnclosedCallParens', match);\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tmatch.twin = lhp;\r\n\t\t\t\t\t\t\tlhp.twin = match;\r\n\t\t\t\t\t\t\tmatch.isCallExpressionStop = true;\r\n\r\n\t\t\t\t\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\t\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // might be div\r\n\t\t\t\t\t\tacceptAssignment = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check for postfix operators ++ and --\r\n\t\t\t\t// they are stronger than the + or - binary operators\r\n\t\t\t\t// they can be applied to any lhs (even when it wouldnt make sense)\r\n\t\t\t\t// if there was a newline, it should get an ASI\r\n\t\t\t\tif ((match.value == '++' || match.value == '--') && !match.newline) {\r\n\t\t\t\t\tif (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\r\n\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(true, match, stack); // may parse div\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t// restore \"expression\" stack\r\n\t\t\t\t\tstack = estack;\r\n\t\t\t\t} //#endif\r\n\t\t\t\t// now see if there is an operator following...\r\n\r\n\t\t\t\tdo { // this do allows us to parse multiple ternary expressions in succession without screwing up.\r\n\t\t\t\t\tvar ternary = false;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t(!forHeader && match.value == 'in') || // one of two named binary operators, may not be first expression in for-header (when semi's occur in the for-header)\r\n\t\t\t\t\t\t(match.value == 'instanceof') || // only other named binary operator\r\n\t\t\t\t\t\t((match.name == 11/*PUNCTUATOR*/) && // we can only expect a punctuator now\r\n\t\t\t\t\t\t\t(match.isAssignment = this.regexAssignments.test(match.value)) || // assignments are only okay with proper lhs\r\n\t\t\t\t\t\t\tthis.regexNonAssignmentBinaryExpressionOperators.test(match.value) // test all other binary operators\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tif (match.isAssignment) {\r\n\t\t\t\t\t\t\tif (!acceptAssignment) this.failignore('IllegalLhsForAssignment', match, stack);\r\n\t\t\t\t\t\t\telse if (parsedNonAssignmentOperator) this.failignore('AssignmentNotAllowedAfterNonAssignmentInExpression', match, stack);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (isBreakOrContinueArg) match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\r\n\r\n\t\t\t\t\t\tif (!match.isAssignment) parsedNonAssignmentOperator = true; // last allowed assignment\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\tmatch.isBinaryOperator = true;\r\n\t\t\t\t\t\t\t// we build a stack to ensure any whitespace doesnt break the 1+(n*2) children rule for expressions\r\n\t\t\t\t\t\t\tvar ostack = stack;\r\n\t\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\t\tstack.desc = 'operator-expression';\r\n\t\t\t\t\t\t\tstack.isBinaryOperator = true;\r\n\t\t\t\t\t\t\tstack.sub = match.value;\r\n\t\t\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\t\t\tostack.sub = match.value;\r\n\t\t\t\t\t\t\tstack.isAssignment = match.isAssignment;\r\n\t\t\t\t\t\t\tostack.push(stack);\r\n\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\tternary = match.value == '?';\r\n\t\t\t\t\t\t// math, logic, assignment or in or instanceof\r\n\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t// restore \"expression\" stack\r\n\t\t\t\t\t\t\tstack = ostack;\r\n\t\t\t\t\t\t} //#endif\r\n\r\n\t\t\t\t\t\t// minor exception to ternary operator, we need to parse two expressions nao. leave the trailing expression to the loop.\r\n\t\t\t\t\t\tif (ternary) {\r\n\t\t\t\t\t\t\t// LogicalORExpression \"?\" AssignmentExpression \":\" AssignmentExpression\r\n\t\t\t\t\t\t\t// so that means just one expression center and right.\r\n\t\t\t\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) this.failignore('InvalidCenterTernaryExpression', match, stack);\r\n\t\t\t\t\t\t\tmatch = this.eatExpressions(false, match, stack, true, forHeader); // only one expression allowed inside ternary center/right\r\n\r\n\t\t\t\t\t\t\tif (match.value != ':') {\r\n\t\t\t\t\t\t\t\tif (match.value == ',') match = this.failsafe('TernarySecondExpressionCanNotContainComma', match);\r\n\t\t\t\t\t\t\t\telse match = this.failsafe('UnfinishedTernaryOperator', match);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\t// we build a stack to ensure any whitespace doesnt break the 1+(n*2) children rule for expressions\r\n\t\t\t\t\t\t\t\tvar ostack = stack;\r\n\t\t\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\t\t\tstack.desc = 'operator-expression';\r\n\t\t\t\t\t\t\t\tstack.sub = match.value;\r\n\t\t\t\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\t\t\t\tostack.sub = match.value;\r\n\t\t\t\t\t\t\t\tstack.isAssignment = match.isAssignment;\r\n\t\t\t\t\t\t\t\tostack.push(stack);\r\n\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t\t\t\tstack = ostack;\r\n\t\t\t\t\t\t\t} //#endif\r\n\t\t\t\t\t\t\t// rhs of the ternary can not contain a comma either\r\n\t\t\t\t\t\t\tmatch = this.eatExpressions(false, match, stack, true, forHeader); // only one expression allowed inside ternary center/right\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tparseAnotherExpression = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (ternary); // if we just parsed a ternary expression, we need to check _again_ whether the next token is a binary operator.\r\n\r\n\t\t\t\t// start over. match is the rhs for the lhs we just parsed, but lhs for the next expression\r\n\t\t\t\tif (parseAnotherExpression && !(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) {\r\n\t\t\t\t\t// no idea what to do now. lets just ignore and see where it ends. TOFIX: maybe just break the loop or return?\r\n\t\t\t\t\tthis.failignore('InvalidRhsExpression', match, stack);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t// restore \"expressions\" stack\r\n\t\t\t\tstack = astack;\r\n\t\t\t} //#endif\r\n\r\n\t\t\t// at this point we should have parsed one AssignmentExpression\r\n\t\t\t// lets see if we can parse another one...\r\n\t\t\tmayParseLabeledStatementInstead = first = false;\r\n\t\t} while (!onlyOne && match.value == ',');\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t// remove empty array\r\n\t\t\tif (!stack.length) pstack.length = pstack.length-1;\r\n\t\t\tpstack.numberOfExpressions = parsedExpressions;\r\n\t\t\tif (pstack[0]) pstack[0].numberOfExpressions = parsedExpressions;\r\n\t\t\tstack.expressionCount = parsedExpressions;\r\n\t\t} //#endif\r\n\t\treturn match;\r\n\t},\r\n\teatFunctionDeclaration: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tvar prevscope = this.scope;\r\n\t\t\tstack.desc = 'func decl';\r\n\t\t\tstack.isFunction = true;\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tif (!this.scope.functions) this.scope.functions = [];\r\n\t\t\tmatch.functionId = this.scope.functions.length;\r\n\t\t\tthis.scope.functions.push(match);\r\n\t\t\t// add new scope\r\n\t\t\tmatch.scope = stack.scope = this.scope = [\r\n\t\t\t\tthis.scope, // add current scope (build scope chain up-down)\r\n\t\t\t\t// Object.create(null,\r\n\t\t\t\t{value:'this', isDeclared:true, isEcma:true, functionStack:stack},\r\n\t\t\t\t// Object.create(null,\r\n\t\t\t\t{value:'arguments', isDeclared:true, isEcma:true, varType:['Object']}\r\n\t\t\t];\r\n\t\t\t// ref to back to function that's the cause for this scope\r\n\t\t\tthis.scope.scopeFor = match;\r\n\t\t\tmatch.targetScope = prevscope; // consistency\r\n\t\t\t\r\n\t\t\tmatch.functionStack = stack;\r\n\r\n\t\t\tmatch.isFuncDeclKeyword = true;\r\n\t\t} //#endif\r\n\t\t// only place that this function is used already checks whether next token is function\r\n\t\tvar functionKeyword = match;\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.name != 2/*IDENTIFIER*/) match = this.failsafe('FunctionDeclarationsMustHaveName', match);\r\n\t\tif (this.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)) this.failignore('FunctionNameMayNotBeReserved', match, stack);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tfunctionKeyword.funcName = match;\r\n\t\t\tprevscope.push({value:match.value});\r\n\t\t\tmatch.meta = 'func decl name'; // that's what it is, really\r\n\t\t\tmatch.varType = ['Function'];\r\n\t\t\tmatch.functionStack = stack;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatFunctionParametersAndBody(match, stack, false, functionKeyword); // first token after func-decl is regex\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t// restore previous scope\r\n\t\t\tthis.scope = prevscope;\r\n\t\t} //#endif\r\n\t\treturn match;\r\n\t},\r\n\teatObjectLiteralColonAndBody: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar propValueStack = stack;\r\n\t\t\tstack = [];\r\n\t\t\tstack.desc = 'objlit pair colon';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tpropValueStack.push(stack);\r\n\t\t} //#endif\r\n\t\tif (match.value != ':') match = this.failsafe('ObjectLiteralExpectsColonAfterName', match);\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack = propValueStack;\r\n\t\t} //#endif\r\n\r\n\t\t// this might actually fail due to ASI optimization.\r\n\t\t// if the property name does not exist and it is the last item\r\n\t\t// of the objlit, the expression parser will see an unexpected\r\n\t\t// } and ignore it, giving some leeway to apply ASI. of course,\r\n\t\t// that doesnt work for objlits. but we dont want to break the\r\n\t\t// existing mechanisms. so we check this differently... :)\r\n\t\tvar prevMatch = match;\r\n\t\tmatch = this.eatExpressions(false, match, stack, true); // only one expression\r\n\t\tif (match == prevMatch) match = this.failsafe('ObjectLiteralMissingPropertyValue', match);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatFunctionParametersAndBody: function(match, stack, div, funcToken){\r\n\t\t// div: the first token _after_ a function expression may be a division...\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectingFunctionHeaderStart', match);\r\n\t\telse if (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tfuncToken.lhp = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.name == 2/*IDENTIFIER*/) { // params\r\n\t\t\tif (this.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)) this.failignore('FunctionArgumentsCanNotBeReserved', match, stack);\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tif (!funcToken.paramNames) funcToken.paramNames = [];\r\n\t\t\t\tstack.paramNames = funcToken.paramNames;\r\n\t\t\t\tfuncToken.paramNames.push(match);\r\n\t\t\t\tthis.scope.push({value:match.value}); // add param name to scope\r\n\t\t\t\tmatch.meta = 'parameter';\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\twhile (match.value == ',') {\r\n\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\tif (match.name != 2/*IDENTIFIER*/) {\r\n\t\t\t\t\t// example: if name is 12, the source is incomplete...\r\n\t\t\t\t\tthis.failignore('FunctionParametersMustBeIdentifiers', match, stack);\r\n\t\t\t\t} else if (this.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)) {\r\n\t\t\t\t\tthis.failignore('FunctionArgumentsCanNotBeReserved', match, stack);\r\n\t\t\t\t}\r\n\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\t// Object.create(null,\r\n\t\t\t\t\tthis.scope.push({value:match.value}); // add param name to scope\r\n\t\t\t\t\tmatch.meta = 'parameter';\r\n\t\t\t\t\tif (match.name == 2/*IDENTIFIER*/) funcToken.paramNames.push(match);\r\n\t\t\t\t} //#endif\r\n\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tif (lhp) {\r\n\t\t\t\tmatch.twin = lhp;\r\n\t\t\t\tlhp.twin = match;\r\n\t\t\t\tfuncToken.rhp = match;\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedFunctionHeaderClose', match); // TOFIX: can be various things here...\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatFunctionBody(match, stack, div, funcToken);\r\n\t\treturn match;\r\n\t},\r\n\teatFunctionBody: function(match, stack, div, funcToken){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'func body';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\t// create EMPTY list of functions. labels cannot cross function boundaries\r\n\t\t\tvar labelBackup = this.statementLabels;\r\n\t\t\tthis.statementLabels = [];\r\n\t\t\tstack.labels = this.statementLabels;\r\n\t\t} //#endif\r\n\r\n\t\t// if div, a division can occur _after_ this function expression\r\n\t\t//this.stats.eatFunctionBody = (+//this.stats.eatFunctionBody||0)+1;\r\n\t\tif (match.value != '{') match = this.failsafe('ExpectedFunctionBodyCurlyOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhc = match;\r\n\t\t\tif (funcToken) funcToken.lhc = lhc;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatSourceElements(match, stack);\r\n\t\tif (match.value != '}') match = this.failsafe('ExpectedFunctionBodyCurlyClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhc;\r\n\t\t\tlhc.twin = match;\r\n\t\t\tif (funcToken) funcToken.rhc = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(div, match, stack);\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t// restore label set\r\n\t\t\tthis.statementLabels = labelBackup;\r\n\t\t} //#endif\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatVar: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'var';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tmatch.stack = stack;\r\n\t\t\tmatch.isVarKeyword = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.eatVarDecl(match, stack);\r\n\t\tmatch = this.eatSemiColon(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatVarDecl: function(match, stack, forHeader){\r\n\t\t// assumes match is indeed the identifier 'var'\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'var decl';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\tvar targetScope = this.scope;\r\n\t\t\twhile (targetScope.catchScope) targetScope = targetScope[0];\r\n\t\t} //#endif\r\n\t\tvar first = true;\r\n\t\tvar varsDeclared = 0;\r\n\t\tdo {\r\n\t\t\t++varsDeclared;\r\n\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // start: var, iteration: comma\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tvar declStack = stack;\r\n\t\t\t\tvar stack = [];\r\n\t\t\t\tstack.desc = 'single var decl';\r\n\t\t\t\tstack.varStack = declStack; // reference to the var statement stack, it might hook to jsdoc needed for these vars\r\n\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\tdeclStack.push(stack);\r\n\r\n\t\t\t\tvar singleDecStack = stack;\r\n\t\t\t\tstack = [];\r\n\t\t\t\tstack.desc = 'sub-expression';\r\n\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\tsingleDecStack.push(stack);\r\n\t\t\t} //#endif\r\n\r\n\t\t\t// next token should be a valid identifier\r\n\t\t\tif (match.name == 12/*eof*/) {\r\n\t\t\t\tif (first) match = this.failsafe('VarKeywordMissingName', match);\r\n\t\t\t\t// else, ignore. TOFIX: return?\r\n\t\t\t\telse match = this.failsafe('IllegalTrailingComma', match);\r\n\t\t\t} else if (match.name != 2/*IDENTIFIER*/) {\r\n\t\t\t\tmatch = this.failsafe('VarNamesMayOnlyBeIdentifiers', match);\r\n\t\t\t} else if (this.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)) {\r\n\t\t\t\tmatch = this.failsafe('VarNamesCanNotBeReserved', match);\r\n\t\t\t}\r\n\t\t\t// mark the match as being a variable name. we need it for lookup later :)\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tmatch.meta = 'var name';\r\n\t\t\t\ttargetScope.push({value:match.value});\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack = singleDecStack;\r\n\t\t\t} //#endif\r\n\r\n\t\t\t// next token should either be a = , or ;\r\n\t\t\t// if = parse an expression and optionally a comma\r\n\t\t\tif (match.value == '=') {\r\n\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\tsingleDecStack = stack;\r\n\t\t\t\t\tstack = [];\r\n\t\t\t\t\tstack.desc = 'operator-expression';\r\n\t\t\t\t\tstack.sub = '=';\r\n\t\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\t\tsingleDecStack.push(stack);\r\n\r\n\t\t\t\t\tstack.isAssignment = true;\r\n\t\t\t\t} //#endif\r\n\t\t\t\tmatch.isInitialiser = true;\r\n\t\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t\tstack = singleDecStack;\r\n\t\t\t\t} //#endif\r\n\r\n\t\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || match.name == 14/*error*/ || this.regexLhsStart.test(match.value))) match = this.failsafe('VarInitialiserExpressionExpected', match);\r\n\t\t\t\tmatch = this.eatExpressions(false, match, stack, true, forHeader); // only one expression \r\n\t\t\t\t// var statement: comma or semi now\r\n\t\t\t\t// for statement: semi, comma or 'in'\r\n\t\t\t}\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack = declStack;\r\n\t\t\t} //#endif\r\n\r\n\t\t\t// determines proper error message in one case\r\n\t\t\tfirst = false;\r\n\t\t// keep parsing name(=expression) sequences as long as you see a comma here\r\n\t\t} while (match.value == ',');\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.varsDeclared = varsDeclared;\r\n\t\t} //#endif\r\n\r\n\t\treturn match;\r\n\t},\r\n\r\n\teatIf: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'if';\r\n\t\t\tstack.hasElse = false;\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\t\t// (\r\n\t\t// expression\r\n\t\t// )\r\n\t\t// statement\r\n\t\t// [else statement]\r\n\t\tvar ifKeyword = match;\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tmatch.statementHeaderStart = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\r\n\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tmatch.statementHeaderStop = true;\r\n\t\t\tlhp.twin = match;\r\n\r\n\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatStatement(false, match, stack);\r\n\r\n\t\t// match might be null here... (if the if-statement was end part of the source)\r\n\t\tif (match && match.value == 'else') {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tifKeyword.hasElse = match;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.eatElse(match, stack);\r\n\t\t}\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatElse: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.hasElse = true;\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'else';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatStatement(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatDo: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'do';\r\n\t\t\tstack.isIteration = true;\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tthis.statementLabels.push(''); // add \"empty\"\r\n\t\t\tvar doToken = match;\r\n\t\t} //#endif\r\n\t\t// statement\r\n\t\t// while\r\n\t\t// (\r\n\t\t// expression\r\n\t\t// )\r\n\t\t// semi-colon\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatStatement(false, match, stack);\r\n\t\tif (match.value != 'while') match = this.failsafe('DoShouldBeFollowedByWhile', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.hasDo = doToken;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tmatch.statementHeaderStart = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\r\n\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tmatch.statementHeaderStop = true;\r\n\t\t\tmatch.isForDoWhile = true; // prevents missing block warnings\r\n\t\t\tlhp.twin = match;\r\n\r\n\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatSemiColon(match, stack); // TOFIX: this is not optional according to the spec, but browsers apply ASI anyways\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatWhile: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'while';\r\n\t\t\tstack.isIteration = true;\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tthis.statementLabels.push(''); // add \"empty\"\r\n\t\t} //#endif\r\n\r\n\t\t// (\r\n\t\t// expression\r\n\t\t// )\r\n\t\t// statement\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tmatch.statementHeaderStart = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\r\n\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tmatch.statementHeaderStop = true;\r\n\t\t\tlhp.twin = match;\r\n\r\n\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatStatement(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\r\n\teatFor: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'for';\r\n\t\t\tstack.isIteration = true;\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tthis.statementLabels.push(''); // add \"empty\"\r\n\t\t} //#endif\r\n\t\t// either a for(..in..) or for(..;..;..)\r\n\t\t// start eating an expression but refuse to parse\r\n\t\t// 'in' on the top-level of that expression. they are fine\r\n\t\t// in sub-levels (group, array, etc). Now the expression\r\n\t\t// must be followed by either ';' or 'in'. Else throw.\r\n\t\t// Branch on that case, ; requires two.\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tmatch.statementHeaderStart = true;\r\n\t\t\tmatch.forHeaderStart = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t// for (either case) may start with var, in which case you'll parse a var declaration before encountering the 'in' or first semi.\r\n\t\tif (match.value == 'var') {\r\n\t\t\tmatch = this.eatVarDecl(match, stack, true);\r\n\t\t} else if (match.value != ';') { // expressions are optional in for-each\r\n\t\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) {\r\n\t\t\t\tthis.failignore('StatementHeaderIsNotOptional', match, stack);\r\n\t\t\t}\r\n\t\t\tmatch = this.eatExpressions(false, match, stack, false, true); // can parse multiple expressions, in is not ok here\r\n\t\t}\r\n\r\n\t\t// now we parsed an expression if it existed. the next token should be either ';' or 'in'. branch accordingly\r\n\t\tif (match.value == 'in') {\r\n\t\t\tvar declStack = stack[stack.length-1];\r\n\t\t\tif (declStack.varsDeclared > 1) {\r\n\t\t\t\t// disallowed. for-in var decls can only have one var name declared\r\n\t\t\t\tthis.failignore('ForInCanOnlyDeclareOnVar', match, stack);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.forType = 'in';\r\n\t\t\t\tmatch.forFor = true; // make easy distinction between conditional and iterational operator\r\n\t\t\t} //#endif\r\n\r\n\t\t\t// just parse another expression, where 'in' is allowed.\r\n\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\t} else {\r\n\t\t\tif (match.value != ';') match = this.failsafe('ForHeaderShouldHaveSemisOrIn', match);\r\n\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.forType = 'each';\r\n\t\t\t\tmatch.forEachHeaderStart = true;\r\n\t\t\t} //#endif\r\n\t\t\t// parse another optional no-in expression, another semi and then one more optional no-in expression\r\n\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\tif (/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value)) match = this.eatExpressions(false, match, stack); // in is ok here\r\n\t\t\tif (match.value != ';') match = this.failsafe('ExpectedSecondSemiOfForHeader', match);\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tmatch.forEachHeaderStop = true;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\t\tif (/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value)) match = this.eatExpressions(false, match, stack); // in is ok here\r\n\t\t}\r\n\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tmatch.statementHeaderStop = true;\r\n\t\t\tmatch.forHeaderStop = true;\r\n\t\t\tlhp.twin = match;\r\n\r\n\t\t\tif (match.forType == 'in' && stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\tmatch = this.eatStatement(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatContinue: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'continue';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\tmatch.restricted = true;\r\n\t\t} //#endif\r\n\t\t// (no-line-break identifier)\r\n\t\t// ;\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\r\n\t\tif (!match.newline && match.value != ';' && match.name != 12/*EOF*/ && match.value != '}') {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tmatch.isLabel = true;\r\n\t\t\t\tmatch.isLabelTarget = true;\r\n\r\n\t\t\t\tvar continueArg = match; // remember to see if this continue parsed a label\r\n\t\t\t} //#endif\r\n\t\t\t// may only parse exactly an identifier at this point\r\n\t\t\tmatch = this.eatExpressions(false, match, stack, true, false, true); // first true=onlyOne, second: continue/break arg\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.hasLabel = continueArg != match;\r\n\t\t\t} //#endif\r\n\t\t\tif (match.value != ';' && !match.newline && match.name != 12/*eof*/ && match.value != '}') match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\r\n\t\t}\r\n\t\tmatch = this.eatSemiColon(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatBreak: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar parentstack = stack\r\n\t\t\tstack = [];\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'break';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t\r\n\t\t\tparentstack.push(stack);\r\n\r\n\t\t\tmatch.restricted = true;\r\n\t\t} //#endif\r\n\t\t// (no-line-break identifier)\r\n\t\t// ;\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\r\n\t\tif (!match.newline && match.value != ';' && match.name != 12/*EOF*/ && match.value != '}') {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tmatch.isLabel = true;\r\n\t\t\t\tmatch.isLabelTarget = true;\r\n\t\t\t\tvar breakArg = match; // remember to see if this break parsed a label\r\n\t\t\t} //#endif\r\n\t\t\t// may only parse exactly an identifier at this point\r\n\t\t\tmatch = this.eatExpressions(false, match, stack, true, false, true); // first true=onlyOne, second: continue/break arg\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.hasLabel = breakArg != match;\r\n\t\t\t} //#endif\r\n\r\n\t\t\tif (match.value != ';' && !match.newline && match.name != 12/*eof*/ && match.value != '}') match = this.failsafe('BreakOrContinueArgMustBeJustIdentifier', match);\r\n\t\t}\r\n\t\tmatch = this.eatSemiColon(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatReturn: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'return';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tstack.returnFor = this.scope.scopeFor;\r\n\r\n\t\t\tmatch.restricted = true;\r\n\t\t} //#endif\r\n\t\t// (no-line-break expression)\r\n\t\t// ;\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\r\n\t\tif (!match.newline && match.value != ';' && match.name != 12/*EOF*/ && match.value != '}') {\r\n\t\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\t}\r\n\t\tmatch = this.eatSemiColon(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatThrow: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'throw';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\tmatch.restricted = true;\r\n\t\t} //#endif\r\n\t\t// (no-line-break expression)\r\n\t\t// ;\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack); // may not have line terminator...\r\n\t\tif (match.newline) match = this.failsafe('ThrowCannotHaveReturn', match);\r\n\t\tif (match.value == ';') match = this.failsafe('ThrowMustHaveArgument', match);\r\n\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\tmatch = this.eatSemiColon(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatSwitch: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'switch';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\tthis.statementLabels.push(''); // add \"empty\"\r\n\t\t} //#endif\r\n\t\t// meh.\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tmatch.statementHeaderStart = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) {\r\n\t\t\tthis.failignore('StatementHeaderIsNotOptional', match, stack);\r\n\t\t}\r\n\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tmatch.statementHeaderStop = true;\r\n\t\t\tlhp.twin = match;\r\n\r\n\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '{') match = this.failsafe('SwitchBodyStartsWithCurly', match);\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhc = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t// you may parse a default case, and only once per switch. but you may do so anywhere.\r\n\t\tvar parsedAnything = false;\r\n\r\n\t\twhile (match.value == 'case' || (!stack.parsedSwitchDefault && match.value == 'default')) {\r\n\t\t\tparsedAnything = true;\r\n\r\n\t\t\tmatch = this.eatSwitchClause(match, stack);\r\n\t\t}\r\n\r\n\t\t// if you didnt parse anything but not encountering a closing curly now, you might be thinking that switches may start with silly stuff\r\n\t\tif (!parsedAnything && match.value != '}') {\r\n\t\t\tmatch = this.failsafe('SwitchBodyMustStartWithClause', match);\r\n\t\t}\r\n\r\n\t\tif (stack.parsedSwitchDefault && match.value == 'default') {\r\n\t\t\tthis.failignore('SwitchCannotHaveDoubleDefault', match, stack);\r\n\t\t}\r\n\r\n\t\tif (match.value != '}' && match.name != 14/*error*/) match = this.failsafe('SwitchBodyEndsWithCurly', match);\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhc;\r\n\t\t\tlhc.twin = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatSwitchClause: function(match, stack){\r\n\t\tmatch = this.eatSwitchHeader(match, stack);\r\n\t\tmatch = this.eatSwitchBody(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatSwitchHeader: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t// collect whitespace...\r\n\t\t\tvar switchHeaderStack = stack\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'switch clause header';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\r\n\t\tif (match.value == 'case') {\r\n\t\t\tmatch = this.eatSwitchCaseHead(match, stack);\r\n\t\t} else { // default\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tswitchHeaderStack.hasDefaultClause = true;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.eatSwitchDefaultHead(match, stack);\r\n\t\t}\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t// just to group whitespace (makes certain navigation easier..)\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'colon';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\r\n\t\tif (match.value != ':') {\r\n\t\t\tmatch = this.failsafe('SwitchClausesEndWithColon', match);\r\n\t\t}\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatSwitchBody: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'switch clause body';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\r\n\t\t// parse body of case or default, just so long case and default keywords are not seen and end of switch is not reached\r\n\t\t// (clause bodies may be empty, for instance to fall through)\r\n\t\tvar lastMatch = null;\r\n\t\twhile (match.value != 'default' && match.value != 'case' && match.value != '}' && match.name != 14/*error*/ && match.name != 12/*eof*/ && lastMatch != match) {\r\n\t\t\tlastMatch = match; // prevents endless loops on error ;)\r\n\t\t\tmatch = this.eatStatement(true, match, stack);\r\n\t\t}\r\n\t\tif (lastMatch == match) this.failsafe('UnexpectedInputSwitch', match);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatSwitchCaseHead: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.sub = 'case';\r\n\t\t\tvar caseHeadStack = stack;\r\n\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'case';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\tmatch.isCase = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\tif (match.value == ':') {\r\n\t\t\tthis.failignore('CaseMissingExpression', match, stack);\r\n\t\t} else {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tcaseHeadStack.push(stack = []);\r\n\t\t\t\tstack.desc = 'case arg';\r\n\t\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\t}\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatSwitchDefaultHead: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.sub = 'default';\r\n\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'case';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\tmatch.isDefault = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatTryCatchFinally: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'try';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\r\n\t\tmatch = this.eatTry(match, stack);\r\n\r\n\t\tif (match.value == 'catch') {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.hasCatch = true;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.eatCatch(match, stack);\r\n\t\t}\r\n\t\tif (match.value == 'finally') {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.hasFinally = true;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.eatFinally(match, stack);\r\n\t\t}\r\n\r\n\t\t// at least a catch or finally block must follow. may be both.\r\n\t\tif (!stack.tryHasCatchOrFinally) {\r\n\t\t\tthis.failignore('TryMustHaveCatchOrFinally', match, stack);\r\n\t\t}\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatTry: function(match, stack){\r\n\t\t// block\r\n\t\t// (catch ( identifier ) block )\r\n\t\t// (finally block)\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '{') match = this.failsafe('MissingTryBlockCurlyOpen', match);\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'tryblock';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tvar lhc = match;\r\n\t\t} //#endif\r\n\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '}') match = this.eatStatements(match, stack);\r\n\t\tif (match.value != '}') match = this.failsafe('MissingTryBlockCurlyClose', match);\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhc;\r\n\t\t\tlhc.twin = match;\r\n\t\t} //#endif\r\n\t\t\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatCatch: function(match, stack){\r\n\t\tstack.tryHasCatchOrFinally = true;\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'catch';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\r\n\t\t\t// the catch block has a header which can contain at most one parameter\r\n\t\t\t// this parameter is bound to a local stack. formally, if that parameter\r\n\t\t\t// shadows another variable, changes made to the variable inside the catch\r\n\t\t\t// should not be reflected by the variable being shadowed. however, this\r\n\t\t\t// is not very safe to rely on so there ought to be a warning. note that\r\n\t\t\t// only this parameter gets bound to this inner scope, other parameters.\r\n\r\n\t\t\tvar catchScopeBackup = this.scope;\r\n\t\t\tmatch.scope = this.scope = stack.scope = [this.scope];\r\n\t\t\tthis.scope.catchScope = true; // mark this as being a catchScope\r\n\r\n\t\t\t// find first function scope or global scope object...\r\n\t\t\tvar nonCatchScope = catchScopeBackup;\r\n\t\t\twhile (nonCatchScope.catchScope) nonCatchScope = nonCatchScope[0];\r\n\r\n\t\t\t// get catch id, which is governed by the function/global scope only\r\n\t\t\tif (!nonCatchScope.catches) nonCatchScope.catches = [];\r\n\t\t\tmatch.catchId = nonCatchScope.catches.length;\r\n\t\t\tnonCatchScope.catches.push(match);\r\n\t\t\tmatch.targetScope = nonCatchScope;\r\n\t\t\tmatch.catchScope = this.scope;\r\n\r\n\t\t\t// ref to back to function that's the cause for this scope\r\n\t\t\tthis.scope.scopeFor = match;\r\n\t\t\t// catch clauses dont have a special `this` or `arguments`, map them to their parent scope\r\n\t\t\tif (catchScopeBackup.global) this.scope.push(catchScopeBackup[0]); // global (has no `arguments` but always a `this`)\r\n\t\t\telse if (catchScopeBackup.catchScope) {\r\n\t\t\t\t// tricky. there will at least be a this\r\n\t\t\t\tthis.scope.push(catchScopeBackup[1]);\r\n\t\t\t\t// but there might not be an arguments\r\n\t\t\t\tif (catchScopeBackup[2] && catchScopeBackup[2].value == 'arguments') this.scope.push(catchScopeBackup[2]);\r\n\t\t\t} else this.scope.push(catchScopeBackup[1], catchScopeBackup[2]); // function scope, copy this and arguments\r\n\t\t} //#endif\r\n\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('CatchHeaderMissingOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.name != 2/*IDENTIFIER*/) match = this.failsafe('MissingCatchParameter', match);\r\n\t\tif (this.hashStartKeyOrReserved[match.value[0]] /*this.regexStartKeyOrReserved.test(match.value[0])*/ && this.regexIsKeywordOrReserved.test(match.value)) {\r\n\t\t\tthis.failignore('CatchParameterNameMayNotBeReserved', match, stack);\r\n\t\t}\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.meta = 'var name';\r\n\t\t\t// this is the catch variable. bind it to a scope but keep the scope as\r\n\t\t\t// it currently is.\r\n\t\t\tthis.scope.push(match);\r\n\t\t\tmatch.isCatchVar = true;\r\n\t\t} //#endif\r\n\r\n\t\t// now the catch body will use the outer scope to bind new variables. the problem is that\r\n\t\t// inner scopes, if any, should have access to the scope variable, so their scope should\r\n\t\t// be linked to the catch scope. this is a problem in the current architecture but the \r\n\t\t// idea is to pass on the catchScope as the scope to the eatStatements call, etc.\r\n\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != ')') match = this.failsafe('CatchHeaderMissingClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tlhp.twin = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '{') match = this.failsafe('MissingCatchBlockCurlyOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhc = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\t// catch body. statements are optional.\t\r\n\t\tif (match.value != '}') match = this.eatStatements(match, stack);\r\n\r\n\t\tif (match.value != '}') match = this.failsafe('MissingCatchBlockCurlyClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhc;\r\n\t\t\tlhc.twin = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tthis.scope = catchScopeBackup;\r\n\t\t} //#endif\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatFinally: function(match, stack){\r\n\t\tstack.tryHasCatchOrFinally = true;\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'finally';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '{') match = this.failsafe('MissingFinallyBlockCurlyOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhc = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '}') match = this.eatStatements(match, stack);\r\n\t\tif (match.value != '}') match = this.failsafe('MissingFinallyBlockCurlyClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhc;\r\n\t\t\tlhc.twin = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatDebugger: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'debugger';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatSemiColon(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatWith: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.push(stack = []);\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'with';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (match.value != '(') match = this.failsafe('ExpectedStatementHeaderOpen', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar lhp = match;\r\n\t\t\tmatch.statementHeaderStart = true;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tif (!(/*is left hand side start?*/ match.name <= 6 || this.regexLhsStart.test(match.value))) match = this.failsafe('StatementHeaderIsNotOptional', match);\r\n\t\tmatch = this.eatExpressions(false, match, stack);\r\n\t\tif (match.value != ')') match = this.failsafe('ExpectedStatementHeaderClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhp;\r\n\t\t\tmatch.statementHeaderStop = true;\r\n\t\t\tlhp.twin = match;\r\n\r\n\t\t\tif (stack[stack.length-1].desc == 'expressions') {\r\n\t\t\t\t// create ref to this expression group to the opening bracket\r\n\t\t\t\tlhp.expressionArg = stack[stack.length-1];\r\n\t\t\t}\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\t\tmatch = this.eatStatement(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatFunction: function(match, stack){\r\n\t\tvar pe = new ZeParser.Error\r\n\t\tthis.errorStack.push(pe);\r\n\t\t// ignore. browsers will accept it anyways\r\n\t\tvar error = {start:match.stop,stop:match.stop,name:14/*error*/,error:pe};\r\n\t\tthis.specialError(error, match, stack);\r\n\t\t// now try parsing a function declaration...\r\n\t\tmatch = this.eatFunctionDeclaration(match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatLabelOrExpression: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tvar parentstack = stack;\r\n\r\n\t\t\tstack = [];\r\n\t\t\tstack.desc = 'statement';\r\n\t\t\tstack.sub = 'expression';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tparentstack.push(stack);\r\n\t\t} //#endif\r\n\t\t// must be an expression or a labeled statement.\r\n\t\t// in order to prevent very weird return constructs, we'll first check the first match\r\n\t\t// if that's an identifier, we'll gobble it here and move on to the second.\r\n\t\t// if that's a colon, we'll gobble it as a labeled statement. otherwise, we'll pass on\r\n\t\t// control to eatExpression, with the note that we've already gobbled a \r\n\r\n\t\tmatch = this.eatExpressions(true, match, stack);\r\n\t\t// if we parsed a label, the returned match (colon) will have this property\r\n\t\tif (match.wasLabel) {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.sub = 'labeled';\r\n\t\t\t} //#endif\r\n\t\t\t// it will have already eaten another statement for the label\r\n\t\t} else {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.sub = 'expression';\r\n\t\t\t} //#endif\r\n\t\t\t// only parse semi if we didnt parse a label just now...\r\n\t\t\tmatch = this.eatSemiColon(match, stack);\r\n\t\t}\r\n\r\n\t\treturn match;\r\n\t},\r\n\teatBlock: function(match, stack){\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tstack.sub = 'block';\r\n\t\t\tvar lhc = match;\r\n\t\t} //#endif\r\n\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\tif (match.value == '}') {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\tstack.isEmptyBlock = true;\r\n\t\t\t} //#endif\r\n\t\t} else {\r\n\t\t\tmatch = this.eatStatements(match, stack);\r\n\t\t}\r\n\t\tif (match.value != '}') match = this.failsafe('BlockCurlyClose', match);\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.twin = lhc;\r\n\t\t\tlhc.twin = match;\r\n\t\t} //#endif\r\n\t\tmatch = this.tokenizer.storeCurrentAndFetchNextToken(false, match, stack);\r\n\r\n\t\treturn match;\r\n\t},\r\n\r\n\teatStatements: function(match, stack){\r\n\t\t//this.stats.eatStatements = (+//this.stats.eatStatements||0)+1;\r\n\t\t// detecting the start of a statement \"quickly\" is virtually impossible.\r\n\t\t// instead we keep eating statements until the match stops changing\r\n\t\t// the first argument indicates that the statement is optional. if that\r\n\t\t// statement was not found, the input match will also be the output.\r\n\r\n\t\twhile (match != (match = this.eatStatement(true, match, stack)));\r\n\t\treturn match;\r\n\t},\r\n\teatStatement: function(isOptional, match, stack){\r\n\t\tif (!match && isOptional) return match; // eof\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tmatch.statementStart = true;\r\n\t\t\tvar pstack = stack;\r\n\t\t\tstack = [];\r\n\t\t\tstack.desc = 'statement-parent';\r\n\t\t\tstack.nextBlack = match.tokposb;\r\n\t\t\tpstack.push(stack);\r\n\r\n\t\t\t// list of labels, these are bound to statements (and can access any label higher up, but not cross functions)\r\n\t\t\tvar labelBackup = this.statementLabels;\r\n\t\t\tthis.statementLabels = [labelBackup]; // make ref like tree. we need this to catch labels parsed beyond the current position (not yet known to use)\r\n\t\t\tstack.labels = this.statementLabels;\r\n\t\t} //#endif\r\n\r\n\t\tif (match.name == 2/*IDENTIFIER*/) {\r\n\t\t\t// try to determine whether it's a statement\r\n\t\t\t// (block/empty statements come later, this branch is only for identifiers)\r\n\t\t\tswitch (match.value) {\r\n\t\t\t\tcase 'var':\r\n\t\t\t\t\tmatch = this.eatVar(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'if':\r\n\t\t\t\t\tmatch = this.eatIf(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'do':\r\n\t\t\t\t\tmatch = this.eatDo(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'while':\r\n\t\t\t\t\tmatch = this.eatWhile(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'for':\r\n\t\t\t\t\tmatch = this.eatFor(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'continue':\r\n\t\t\t\t\tmatch = this.eatContinue(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'break':\r\n\t\t\t\t\tmatch = this.eatBreak(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'return':\r\n\t\t\t\t\tmatch = this.eatReturn(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'throw':\r\n\t\t\t\t\tmatch = this.eatThrow(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'switch':\r\n\t\t\t\t\tmatch = this.eatSwitch(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'try':\r\n\t\t\t\t\tmatch = this.eatTryCatchFinally(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'debugger':\r\n\t\t\t\t\tmatch = this.eatDebugger(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'with':\r\n\t\t\t\t\tmatch = this.eatWith(match, stack);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'function':\r\n\t\t\t\t\t// I'm not sure whether this is at all possible.... (but it's bad, either way ;)\r\n\t\t\t\t\t// so add an error token, but parse the function as if it was a declaration.\r\n\t\t\t\t\tthis.failignore('StatementMayNotStartWithFunction', match, stack);\r\n\r\n\t\t\t\t\t// now parse as declaration... (most likely?)\r\n\t\t\t\t\tmatch = this.eatFunctionDeclaration(match, stack);\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault: // either a label or an expression-statement\r\n\t\t\t\t\tmatch = this.eatLabelOrExpression(match, stack);\r\n\t\t\t}\r\n\t\t} else if (match.value == '{') { // Block (make sure you do this before checking for expression...)\r\n\t\t\tmatch = this.eatBlock(match, stack);\r\n\t\t} else if (\r\n\t\t\t// expression statements:\r\n\t\t\tmatch.isString ||\r\n\t\t\tmatch.isNumber ||\r\n\t\t\tmatch.name == 1/*REG_EX*/ ||\r\n\t\t\tthis.regexLhsStart.test(match.value)\r\n\t\t) {\r\n\t\t\tmatch = this.eatExpressions(false, match,stack);\r\n\t\t\tmatch = this.eatSemiColon(match, stack);\r\n\t\t} else if (match.value == ';') { // empty statement\r\n\t\t\tmatch.emptyStatement = true;\r\n\t\t\tmatch = this.eatSemiColon(match, stack);\r\n\t\t} else if (!isOptional) {\r\n\t\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\t\t// unmark token as being start of a statement, since it's obviously not\r\n\t\t\t\tmatch.statementStart = false;\r\n\t\t\t} //#endif\r\n\t\t\tmatch = this.failsafe('UnableToParseStatement', match);\r\n\t\t} else {\r\n\t\t\t// unmark token as being start of a statement, since it's obviously not\r\n\t\t\tif (this.ast) match.statementStart = true;\r\n\t\t}\r\n\r\n\t\tif (this.ast) { //#ifdef FULL_AST\r\n\t\t\tif (!stack.length) pstack.length = pstack.length-1;\r\n\r\n\t\t\t// restore label set\r\n\t\t\tthis.statementLabels = labelBackup;\r\n\t\t} //#endif\r\n\r\n\t\treturn match;\r\n\t},\r\n\r\n\teatSourceElements: function(match, stack){\r\n\t\t//this.stats.eatSourceElements = (+//this.stats.eatSourceElements||0)+1;\r\n\t\t// detecting the start of a statement \"quickly\" is virtually impossible.\r\n\t\t// instead we keep eating statements until the match stops changing\r\n\t\t// the first argument indicates that the statement is optional. if that\r\n\t\t// statement was not found, the input match will also be the output.\r\n\t\twhile (match != oldMatch) { // difficult to determine whether ` && match.name != 12/*EOF*/` is actually speeding things up. it's an extra check vs one less call to eatStatement...\r\n\t\t\tvar oldMatch = match;\r\n\t\t\t// always try to eat function declaration first. otherwise 'function' at the start might cause eatStatement to throw up\r\n\t\t\tif (match.value == 'function') match = this.eatFunctionDeclaration(match, stack);\r\n\t\t\telse match = this.eatStatement(true, match, stack);\r\n\t\t}\r\n\t\treturn match;\r\n\t},\r\n\r\n\tfailsafe: function(name, match, doNotAddMatch){\r\n\t\tvar pe = new ZeParser.Error(name, match);\r\n\t\tthis.errorStack.push(pe);\r\n\r\n\t\tif (!doNotAddMatch) {\r\n\t\t\t// the match was bad, but add it to the ast anyways. in most cases this is the case but in some its not.\r\n\t\t\t// the tokenizer will pick up on the errorEscape property and add it after the match we passed on.\r\n\t\t\tif (this.tokenizer.errorEscape) this.stack.push(this.tokenizer.errorEscape);\r\n\t\t\tthis.tokenizer.errorEscape = match;\r\n\t\t}\r\n\t\tvar error = {start:match.start,stop:match.start,len:0, name:14/*error*/,error:pe, value:''};\r\n\t\tthis.tokenizer.addTokenToStreamBefore(error, match);\r\n\t\treturn error;\r\n\t},\r\n\tfailignore: function(name, match, stack){\r\n\t\tvar pe = new ZeParser.Error(name, match);\r\n\t\tthis.errorStack.push(pe);\r\n\t\t// ignore the error (this will screw up :)\r\n\t\tvar error = {start:match.start,stop:match.start,len:0,name:14/*error*/,error:pe, value:''};\r\n\t\tstack.push(error);\r\n\t\tthis.tokenizer.addTokenToStreamBefore(error, match);\r\n\t},\r\n\tfailSpecial: function(error, match, stack){\r\n\t\t// we cant really ignore this. eat the token\r\n\t\tstack.push(error);\r\n\t\tthis.tokenizer.addTokenToStreamBefore(error, match);\r\n\t},\r\n\r\n0:0};\r\n\r\n//#ifdef TEST_SUITE\r\nZeParser.testSuite = function(tests){\r\n\tvar ok = 0;\r\n\tvar fail = 0;\r\n\tvar start = +new Date;\r\n\tfor (var i = 0; i < tests.length; ++i) {\r\n\t\tvar test = tests[i], input = test[0], desc = test[test.length - 1], stack = [];\r\n\t\ttry {\r\n\t\t\tnew ZeParser(input, new Tokenizer(input), stack).parse();\r\n\t\t\t++ok;\r\n\t\t} catch (e) {\r\n\t\t\t++fail;\r\n\t\t}\r\n\t\tdocument.getElementsByTagName('div')[0].innerHTML = ('Ze parser test suite finished ('+(+new Date - start)+' ms). ok:'+ok+', fail:'+fail);\r\n\t};\r\n};\r\n//#endif\r\n\r\nZeParser.regexLhsStart = /[\\+\\-\\~\\!\\(\\{\\[]/;\r\n/*\r\nZeParser.regexStartKeyword = /[bcdefinrstvw]/;\r\nZeParser.regexKeyword = /^break$|^catch$|^continue$|^debugger$|^default$|^delete$|^do$|^else$|^finally$|^for$|^function$|^if$|^in$|^instanceof$|^new$|^return$|^switch$|^this$|^throw$|^try$|^typeof$|^var$|^void$|^while$|^with$/;\r\nZeParser.regexStartReserved = /[ceis]/;\r\nZeParser.regexReserved = /^class$|^const$|^enum$|^export$|^extends$|^import$|^super$/;\r\n*/\r\nZeParser.regexStartKeyOrReserved = /[bcdefinrstvw]/;\r\nZeParser.hashStartKeyOrReserved = Object.create ? Object.create(null, {b:{value:1},c:{value:1},d:{value:1},e:{value:1},f:{value:1},i:{value:1},n:{value:1},r:{value:1},s:{value:1},t:{value:1},v:{value:1},w:{value:1}}) : {b:1,c:1,d:1,e:1,f:1,i:1,n:1,r:1,s:1,t:1,v:1,w:1};\r\nZeParser.regexIsKeywordOrReserved = /^break$|^catch$|^continue$|^debugger$|^default$|^delete$|^do$|^else$|^finally$|^for$|^function$|^if$|^in$|^instanceof$|^new$|^return$|^switch$|^case$|^this$|^true$|^false$|^null$|^throw$|^try$|^typeof$|^var$|^void$|^while$|^with$|^class$|^const$|^enum$|^export$|^extends$|^import$|^super$/;\r\nZeParser.regexAssignments = /^[\\+\\-\\*\\%\\&\\|\\^\\/]?=$|^\\<\\<\\=$|^\\>{2,3}\\=$/;\r\nZeParser.regexNonAssignmentBinaryExpressionOperators = /^[\\+\\-\\*\\%\\|\\^\\&\\?\\/]$|^[\\<\\>]\\=?$|^[\\=\\!]\\=\\=?$|^\\<\\<|\\>\\>\\>?$|^\\&\\&$|^\\|\\|$/;\r\nZeParser.regexUnaryKeywords = /^delete$|^void$|^typeof$|^new$/;\r\nZeParser.hashUnaryKeywordStart = Object.create ? Object.create(null, {d:{value:1},v:{value:1},t:{value:1},n:{value:1}}) : {d:1,v:1,t:1,n:1};\r\nZeParser.regexUnaryOperators = /[\\+\\-\\~\\!]/;\r\nZeParser.regexLiteralKeywords = /^this$|^null$|^true$|^false$/;\r\n\r\nZeParser.Error = function(type, match){\r\n\t//if (type == 'BreakOrContinueArgMustBeJustIdentifier') throw here;\r\n\tthis.msg = ZeParser.Errors[type].msg;\r\n\tthis.before = ZeParser.Errors[type].before;\r\n\tthis.match = match;\r\n};\r\n\r\nZeParser.Errors = {\r\n\tNoASI: {msg:'Expected semi-colon, was unable to apply ASI'},\r\n\tExpectedAnotherExpressionComma: {msg:'expecting another (left hand sided) expression after the comma'},\r\n\tExpectedAnotherExpressionRhs: {msg:\"expected a rhs expression\"},\r\n\tUnclosedGroupingOperator: {msg:\"Unclosed grouping operator\"},\r\n\tGroupingShouldStartWithExpression: {msg:'The grouping operator (`(`) should start with a left hand sided expression'},\r\n\tArrayShouldStartWithExpression: {msg:'The array literal (`[`) should start with a left hand sided expression'},\r\n\tUnclosedPropertyBracket: {msg:'Property bracket was not closed after expression (expecting `]`)'},\r\n\tIllegalPropertyNameToken: {msg:'Object literal property names can only be assigned as strings, numbers or identifiers'},\r\n\tIllegalGetterSetterNameToken: {msg:'Name of a getter/setter can only be assigned as strings, numbers or identifiers'},\r\n\tGetterSetterNameFollowedByOpenParen: {msg:'The name of the getter/setter should immediately be followed by the opening parenthesis `(`'},\r\n\tGetterHasNoArguments: {msg:'The opening parenthesis `(` of the getter should be immediately followed by the closing parenthesis `)`, the getter cannot have an argument'},\r\n\tIllegalSetterArgumentNameToken: {msg:'Expecting the name of the argument of a setter, can only be assigned as strings, numbers or identifiers'},\r\n\tSettersOnlyGetOneArgument: {msg:'Setters have one and only one argument, missing the closing parenthesis `)`'},\r\n\tSetterHeaderShouldHaveClosingParen: {msg:'After the first argument of a setter should come a closing parenthesis `)`'},\r\n\tSettersMustHaveArgument: {msg:'Setters must have exactly one argument defined'},\r\n\tUnclosedObjectLiteral: {msg:'Expected to find a comma `,` for the next expression or a closing curly brace `}` to end the object literal'},\r\n\tFunctionNameMustNotBeReserved: {msg:'Function name may not be a keyword or a reserved word'},\r\n\tExpressionMayNotStartWithKeyword: {msg:'Expressions may not start with keywords or reserved words that are not in this list: [this, null, true, false, void, typeof, delete, new]'},\r\n\tLabelsMayOnlyBeIdentifiers: {msg:'Label names may only be defined as an identifier'},\r\n\tLabelsMayNotBeReserved: {msg:'Labels may not be a keyword or a reserved word'},\r\n\tUnknownToken: {msg:'Unknown token encountered, dont know how to proceed'},\r\n\tPropertyNamesMayOnlyBeIdentifiers: {msg:'The tokens of property names accessed through the dot operator may only be identifiers'},\r\n\tSquareBracketExpectsExpression: {msg:'The square bracket property access expects an expression'},\r\n\tSquareBracketsMayNotBeEmpty: {msg:'Square brackets may never be empty, expecting an expression'},\r\n\tUnclosedSquareBrackets: {msg:'Unclosed square bracket encountered, was expecting `]` after the expression'},\r\n\tUnclosedCallParens: {msg:'Unclosed call parenthesis, expecting `)` after the optional expression'},\r\n\tInvalidCenterTernaryExpression: {msg:'Center expression of ternary operator should be a regular expression (but may not contain the comma operator directly)'},\r\n\tUnfinishedTernaryOperator: {msg:'Encountered a ternary operator start (`?`) but did not find the required colon (`:`) after the center expression'},\r\n\tTernarySecondExpressionCanNotContainComma: {msg:'The second and third expressions of the ternary operator can/may not \"directly\" contain a comma operator'},\r\n\tInvalidRhsExpression: {msg:'Expected a right hand side expression after the operator (which should also be a valid lhs) but did not find one'},\r\n\tFunctionDeclarationsMustHaveName: {msg:'Function declaration must have name'},\r\n\tFunctionNameMayNotBeReserved: {msg:'Function name may not be a keyword or reserved word'},\r\n\tExpectingFunctionHeaderStart: {msg:'Expected the opening parenthesis of the function header'},\r\n\tFunctionArgumentsCanNotBeReserved: {msg:'Function arguments may not be keywords or reserved words'},\r\n\tFunctionParametersMustBeIdentifiers: {msg:'Function arguments must be identifiers'},\r\n\tExpectedFunctionHeaderClose: {msg:'Expected the closing parenthesis `)` of the function header'},\r\n\tExpectedFunctionBodyCurlyOpen: {msg:'Expected the opening curly brace `{` for the function body'},\r\n\tExpectedFunctionBodyCurlyClose: {msg:'Expected the closing curly brace `}` for the function body'},\r\n\tVarNamesMayOnlyBeIdentifiers: {msg:'Missing variable name, must be a proper identifier'},\r\n\tVarNamesCanNotBeReserved: {msg:'Variable names may not be keywords or reserved words'},\r\n\tVarInitialiserExpressionExpected: {msg:'The initialiser of the variable statement should be an expression without comma'},\r\n\tExpectedStatementHeaderOpen: {msg:'Expected opening parenthesis `(` for statement header'},\r\n\tStatementHeaderIsNotOptional: {msg:'Statement header must not be empty'},\r\n\tExpectedStatementHeaderClose: {msg:'Expected closing parenthesis `)` for statement header'},\r\n\tDoShouldBeFollowedByWhile: {msg:'The do-while statement requires the `while` keyword after the expression'},\r\n\tExpectedSecondSemiOfForHeader: {msg:'Expected the second semi-colon of the for-each header'},\r\n\tForHeaderShouldHaveSemisOrIn: {msg:'The for-header should contain at least the `in` operator or two semi-colons (`;`)'},\r\n\tSwitchBodyStartsWithCurly: {msg:'The body of a switch statement starts with a curly brace `{`'},\r\n\tSwitchClausesEndWithColon: {msg:'Switch clauses (`case` and `default`) end with a colon (`:`)'},\r\n\tSwitchCannotHaveDoubleDefault: {msg:'Switches cannot have more than one `default` clause'},\r\n\tSwitchBodyEndsWithCurly: {msg:'The body of a switch statement ends with a curly brace `}`'},\r\n\tMissingTryBlockCurlyOpen: {msg:'Missing the opening curly brace (`{`) for the block of the try statement'},\r\n\tMissingTryBlockCurlyClose: {msg:'Missing the closing curly brace (`}`) for the block of the try statement'},\r\n\tCatchHeaderMissingOpen: {msg:'Missing the opening parenthesis of the catch header'},\r\n\tMissingCatchParameter: {msg:'Catch clauses should have exactly one argument which will be bound to the error object being thrown'},\r\n\tCatchParameterNameMayNotBeReserved: {msg:'Catch clause parameter may not be a keyword or reserved word'},\r\n\tCatchHeaderMissingClose: {msg:'Missing the closing parenthesis of the catch header'},\r\n\tMissingCatchBlockCurlyOpen: {msg:'Missing the opening curly brace (`{`) for the block of the catch statement'},\r\n\tMissingCatchBlockCurlyClose: {msg:'Missing the closing curly brace (`}`) for the block of the catch statement'},\r\n\tMissingFinallyBlockCurlyOpen: {msg:'Missing the opening curly brace (`{`) for the block of the finally statement'},\r\n\tMissingFinallyBlockCurlyClose: {msg:'Missing the closing curly brace (`}`) for the block of the finally statement'},\r\n\tStatementMayNotStartWithFunction: {msg:'statements may not start with function...', before:true},\r\n\tBlockCurlyClose: {msg:'Expected the closing curly (`}`) for a block statement'},\r\n\tBlockCurlyOpen: {msg:'Expected the closing curly (`}`) for a block statement'},\r\n\tUnableToParseStatement: {msg:'Was unable to find a statement when it was requested'},\r\n\tIllegalDoubleCommaInObjectLiteral: {msg:'A double comma in object literals is not allowed'},\r\n\tObjectLiteralExpectsColonAfterName: {msg:'After every property name (identifier, string or number) a colon (`:`) should follow'},\r\n\tThrowMustHaveArgument: {msg:'The expression argument for throw is not optional'},\r\n\tThrowCannotHaveReturn: {msg:'There may not be a return between throw and the start of its expression argument'},\r\n\tSwitchBodyMustStartWithClause: {msg:'The body of a switch clause must start with at a case or default clause (but may be empty, which would be silly)'},\r\n\tBreakOrContinueArgMustBeJustIdentifier: {msg:'The argument to a break or continue statement must be exactly and only an identifier (an existing label)'},\r\n\tAssignmentNotAllowedAfterNonAssignmentInExpression: {msg:'An assignment is not allowed if it is preceeded by a non-expression operator in the same expression-level'},\r\n\tIllegalLhsForAssignment: {msg:'Illegal left hand side for assignment (you cannot assign to things like string literals, number literals or function calls}'},\r\n\tVarKeywordMissingName: {msg:'Var keyword should be followed by a variable name'},\r\n\tIllegalTrailingComma: {msg:'Illegal trailing comma found'},\r\n\tObjectLiteralMissingPropertyValue: {msg:'Missing object literal property value'},\r\n\tTokenizerError: {msg:'Tokenizer encountered unexpected input'},\r\n\tLabelRequiresStatement: {msg:'Saw a label without the (required) statement following'},\r\n\tDidNotExpectElseHere: {msg:'Did not expect an else here. To what if should it belong? Maybe you put a ; after the if-block? (if(x){};else{})'},\r\n\tUnexpectedToken: {msg:'Found an unexpected token and have no idea why'},\r\n\tInvalidPostfixOperandArray: {msg:'You cannot apply ++ or -- to an array'},\r\n\tInvalidPostfixOperandObject: {msg:'You cannot apply ++ or -- to an object'},\r\n\tInvalidPostfixOperandFunction: {msg:'You cannot apply ++ or -- to a function'},\r\n\tCaseMissingExpression: {msg:'Case expects an expression before the colon'},\r\n\tTryMustHaveCatchOrFinally: {msg:'The try statement must have a catch or finally block'},\r\n\tUnexpectedInputSwitch: {msg:'Unexpected input while parsing a switch clause...'},\r\n\tForInCanOnlyDeclareOnVar: {msg:'For-in header can only introduce one new variable'}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}