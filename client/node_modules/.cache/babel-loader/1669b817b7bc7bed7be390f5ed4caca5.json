{"ast":null,"code":"if (typeof exports !== 'undefined') {\n  var window = {\n    Unicode: require('./unicodecategories').Unicode\n  };\n  exports.Tokenizer = Tokenizer;\n}\n/*!\r\n * Tokenizer for JavaScript / ECMAScript 5\r\n * (c) Peter van der Zee, qfox.nl\r\n */\n\n/**\r\n * @param {Object} inp\r\n */\n\n\nfunction Tokenizer(inp) {\n  this.inp = inp || ''; // replace all other line terminators with \\n (leave \\r\\n in tact though). we should probably remove the shadowInp when finished...\n  // only replace \\r if it is not followed by a \\n else \\r\\n would become \\n\\n causing a double newline where it is just a single\n\n  this.shadowInp = (inp || '').replace(Tokenizer.regexNormalizeNewlines, '\\n');\n  this.pos = 0;\n  this.line = 0;\n  this.column = 0;\n  this.cache = {};\n  this.errorStack = [];\n  this.wtree = [];\n  this.btree = []; //\tthis.regexWhiteSpace = Tokenizer.regexWhiteSpace;\n\n  this.regexLineTerminator = Tokenizer.regexLineTerminator; // used in fallback\n\n  this.regexAsciiIdentifier = Tokenizer.regexAsciiIdentifier;\n  this.hashAsciiIdentifier = Tokenizer.hashAsciiIdentifier; //\tthis.regexHex = Tokenizer.regexHex;\n\n  this.hashHex = Tokenizer.hashHex;\n  this.regexUnicodeEscape = Tokenizer.regexUnicodeEscape;\n  this.regexIdentifierStop = Tokenizer.regexIdentifierStop;\n  this.hashIdentifierStop = Tokenizer.hashIdentifierStop; //\tthis.regexPunctuators = Tokenizer.regexPunctuators;\n\n  this.regexNumber = Tokenizer.regexNumber;\n  this.regexNewline = Tokenizer.regexNewline;\n  this.regexBig = Tokenizer.regexBig;\n  this.regexBigAlt = Tokenizer.regexBigAlt;\n  this.tokenCount = 0;\n  this.tokenCountNoWhite = 0;\n  this.Unicode = window.Unicode; // if the Parser throws an error. it will set this property to the next match\n  // at the time of the error (which was not what it was expecting at that point) \n  // and pass on an \"error\" match. the error should be scooped on the stack and \n  // this property should be returned, without looking at the input...\n\n  this.errorEscape = null;\n}\n\n;\nTokenizer.prototype = {\n  inp: null,\n  shadowInp: null,\n  pos: null,\n  line: null,\n  column: null,\n  cache: null,\n  errorStack: null,\n  wtree: null,\n  // contains whitespace (spaces, comments, newlines)\n  btree: null,\n  // does not contain any whitespace tokens.\n  regexLineTerminator: null,\n  regexAsciiIdentifier: null,\n  hashAsciiIdentifier: null,\n  hashHex: null,\n  regexUnicodeEscape: null,\n  regexIdentifierStop: null,\n  hashIdentifierStop: null,\n  regexNumber: null,\n  regexNewline: null,\n  regexBig: null,\n  regexBigAlt: null,\n  tokenCount: null,\n  tokenCountNoWhite: null,\n  Unicode: null,\n  // storeCurrentAndFetchNextToken(bool, false, false true) to get just one token\n  storeCurrentAndFetchNextToken: function (noRegex, returnValue, stack, _dontStore) {\n    var regex = !noRegex; // TOFIX :)\n\n    var pos = this.pos;\n    var inp = this.inp;\n    var shadowInp = this.shadowInp;\n    var matchedNewline = false;\n\n    do {\n      if (!_dontStore) {\n        ++this.tokenCount;\n        stack.push(returnValue); // did the parent Parser throw up?\n\n        if (this.errorEscape) {\n          returnValue = this.errorEscape;\n          this.errorEscape = null;\n          return returnValue;\n        }\n      }\n\n      _dontStore = false;\n\n      if (pos >= inp.length) {\n        returnValue = {\n          start: inp.length,\n          stop: inp.length,\n          name: 12\n          /*EOF*/\n\n        };\n        break;\n      }\n\n      var returnValue = null;\n      var start = pos;\n      var chr = inp[pos]; //\t\t\t\t\t\t\t1 ws\t\t\t\t\t\t\t2 lt\t\t\t\t   3 scmt 4 mcmt 5/6 str 7 nr     8 rx  9 punc\n      //if (true) {\n      // substring method (I think this is faster..)\n\n      var part2 = inp.substring(pos, pos + 4);\n      var part = this.regexBig.exec(part2); //} else {\n      //\t// non-substring method (lastIndex)\n      //\t// this method does not need a substring to apply it\n      //\tthis.regexBigAlt.lastIndex = pos;\n      //\tvar part = this.regexBigAlt.exec(inp);\n      //}\n\n      if (part[1]) {\n        //this.regexWhiteSpace.test(chr)) { // SP, TAB, VT, FF, NBSP, BOM (, TOFIX: USP)\n        ++pos;\n        returnValue = {\n          start: start,\n          stop: pos,\n          name: 9\n          /*WHITE_SPACE*/\n          ,\n          line: this.line,\n          col: this.column,\n          isWhite: true\n        };\n        ++this.column;\n      } else if (part[2]) {\n        //this.regexLineTerminator.test(chr)) { // LF, CR, LS, PS\n        var end = pos + 1;\n        if (chr == '\\r' && inp[pos + 1] == '\\n') ++end; // support crlf=>lf\n\n        returnValue = {\n          start: pos,\n          stop: end,\n          name: 10\n          /*LINETERMINATOR*/\n          ,\n          line: this.line,\n          col: this.column,\n          isWhite: true\n        };\n        pos = end; // mark newlines for ASI\n\n        matchedNewline = true;\n        ++this.line;\n        this.column = 0;\n        returnValue.hasNewline = 1;\n      } else if (part[3]) {\n        //chr == '/' && inp[pos+1] == '/') {\n        pos = shadowInp.indexOf('\\n', pos);\n        if (pos == -1) pos = inp.length;\n        returnValue = {\n          start: start,\n          stop: pos,\n          name: 7\n          /*COMMENT_SINGLE*/\n          ,\n          line: this.line,\n          col: this.column,\n          isComment: true,\n          isWhite: true\n        };\n        this.column = returnValue.stop;\n      } else if (part[4]) {\n        //chr == '/' && inp[pos+1] == '*') {\n        var newpos = inp.indexOf('*/', pos);\n\n        if (newpos == -1) {\n          newpos = shadowInp.indexOf('\\n', pos);\n          if (newpos < 0) pos += 2;else pos = newpos;\n          returnValue = {\n            start: start,\n            stop: pos,\n            name: 14\n            /*error*/\n            ,\n            value: inp.substring(start, pos),\n            line: this.line,\n            col: this.column,\n            isComment: true,\n            isWhite: true,\n            tokenError: true,\n            error: Tokenizer.Error.UnterminatedMultiLineComment\n          };\n          this.errorStack.push(returnValue);\n        } else {\n          pos = newpos + 2;\n          returnValue = {\n            start: start,\n            stop: pos,\n            name: 8\n            /*COMMENT_MULTI*/\n            ,\n            value: inp.substring(start, pos),\n            line: this.line,\n            col: this.column,\n            isComment: true,\n            isWhite: true\n          }; // multi line comments are also reason for asi, but only if they contain at least one newline (use shadow input, because all line terminators would be valid...)\n\n          var shadowValue = shadowInp.substring(start, pos);\n          var i = 0,\n              hasNewline = 0;\n\n          while (i < (i = shadowValue.indexOf('\\n', i + 1))) {\n            ++hasNewline;\n          }\n\n          if (hasNewline) {\n            matchedNewline = true;\n            returnValue.hasNewline = hasNewline;\n            this.line += hasNewline;\n            this.column = 0;\n          } else {\n            this.column = returnValue.stop;\n          }\n        }\n      } else if (part[5]) {\n        //chr == \"'\") {\n        // old method\n        //console.log(\"old method\");\n        var hasNewline = 0;\n\n        do {\n          // process escaped characters\n          while (pos < inp.length && inp[++pos] == '\\\\') {\n            if (shadowInp[pos + 1] == '\\n') ++hasNewline;\n            ++pos;\n          }\n\n          if (this.regexLineTerminator.test(inp[pos])) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              value: inp.substring(start, pos),\n              isString: true,\n              tokenError: true,\n              error: Tokenizer.Error.UnterminatedDoubleStringNewline\n            };\n            this.errorStack.push(returnValue);\n            break;\n          }\n        } while (pos < inp.length && inp[pos] != \"'\");\n\n        if (returnValue) {} // error\n        else if (inp[pos] != \"'\") {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              value: inp.substring(start, pos),\n              isString: true,\n              tokenError: true,\n              error: Tokenizer.Error.UnterminatedDoubleStringOther\n            };\n            this.errorStack.push(returnValue);\n          } else {\n            ++pos;\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 5\n              /*STRING_SINGLE*/\n              ,\n              isPrimitive: true,\n              isString: true\n            };\n\n            if (hasNewline) {\n              returnValue.hasNewline = hasNewline;\n              this.line += hasNewline;\n              this.column = 0;\n            } else {\n              this.column += pos - start;\n            }\n          }\n      } else if (part[6]) {\n        //chr == '\"') {\n        var hasNewline = 0; // TODO: something like this: var regexmatch = /([^\\']|$)+/.match();\n\n        do {\n          // process escaped chars\n          while (pos < inp.length && inp[++pos] == '\\\\') {\n            if (shadowInp[pos + 1] == '\\n') ++hasNewline;\n            ++pos;\n          }\n\n          if (this.regexLineTerminator.test(inp[pos])) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              value: inp.substring(start, pos),\n              isString: true,\n              tokenError: true,\n              error: Tokenizer.Error.UnterminatedSingleStringNewline\n            };\n            this.errorStack.push(returnValue);\n            break;\n          }\n        } while (pos < inp.length && inp[pos] != '\"');\n\n        if (returnValue) {} else if (inp[pos] != '\"') {\n          returnValue = {\n            start: start,\n            stop: pos,\n            name: 14\n            /*error*/\n            ,\n            value: inp.substring(start, pos),\n            isString: true,\n            tokenError: true,\n            error: Tokenizer.Error.UnterminatedSingleStringOther\n          };\n          this.errorStack.push(returnValue);\n        } else {\n          ++pos;\n          returnValue = {\n            start: start,\n            stop: pos,\n            name: 6\n            /*STRING_DOUBLE*/\n            ,\n            isPrimitive: true,\n            isString: true\n          };\n\n          if (hasNewline) {\n            returnValue.hasNewline = hasNewline;\n            this.line += hasNewline;\n            this.column = 0;\n          } else {\n            this.column += pos - start;\n          }\n        }\n      } else if (part[7]) {\n        //(chr >= '0' && chr <= '9') || (chr == '.' && inp[pos+1] >= '0' && inp[pos+1] <= '9')) {\n        var nextPart = inp.substring(pos, pos + 30);\n        var match = nextPart.match(this.regexNumber);\n\n        if (match[2]) {\n          // decimal\n          var value = match[2];\n          var parsingOctal = value[0] == '0' && value[1] && value[1] != 'e' && value[1] != 'E' && value[1] != '.';\n\n          if (parsingOctal) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              isNumber: true,\n              isOctal: true,\n              tokenError: true,\n              error: Tokenizer.Error.IllegalOctalEscape,\n              value: value\n            };\n            this.errorStack.push(returnValue);\n          } else {\n            returnValue = {\n              start: start,\n              stop: start + value.length,\n              name: 4\n              /*NUMERIC_DEC*/\n              ,\n              isPrimitive: true,\n              isNumber: true,\n              value: value\n            };\n          }\n        } else if (match[1]) {\n          // hex\n          var value = match[1];\n          returnValue = {\n            start: start,\n            stop: start + value.length,\n            name: 3\n            /*NUMERIC_HEX*/\n            ,\n            isPrimitive: true,\n            isNumber: true,\n            value: value\n          };\n        } else {\n          throw 'unexpected parser errror... regex fail :(';\n        }\n\n        if (value.length < 300) {\n          pos += value.length;\n        } else {\n          // old method of parsing numbers. only used for extremely long number literals (300+ chars).\n          // this method does not require substringing... just memory :)\n          var tmpReturnValue = this.oldNumberParser(pos, chr, inp, returnValue, start, Tokenizer);\n          pos = tmpReturnValue[0];\n          returnValue = tmpReturnValue[1];\n        }\n      } else if (regex && part[8]) {\n        //chr == '/') { // regex cannot start with /* (would be multiline comment, and not make sense anyways). but if it was /* then an earlier if would have eated it. so we only check for /\n        var twinfo = []; // matching {[( info\n\n        var found = false;\n        var parens = [];\n        var nonLethalError = null;\n\n        while (++pos < inp.length) {\n          chr = shadowInp[pos]; // parse RegularExpressionChar\n\n          if (chr == '\\n') {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              tokenError: true,\n              errorHasContent: true,\n              error: Tokenizer.Error.UnterminatedRegularExpressionNewline\n            };\n            this.errorStack.push(returnValue);\n            break; // fail\n          } else if (chr == '/') {\n            found = true;\n            break;\n          } else if (chr == '?' || chr == '*' || chr == '+') {\n            nonLethalError = Tokenizer.Error.NothingToRepeat;\n          } else if (chr == '^') {\n            if (inp[pos - 1] != '/' && inp[pos - 1] != '|' && inp[pos - 1] != '(' && !(inp[pos - 3] == '(' && inp[pos - 2] == '?' && (inp[pos - 1] == ':' || inp[pos - 1] == '!' || inp[pos - 1] == '='))) {\n              nonLethalError = Tokenizer.Error.StartOfMatchShouldBeAtStart;\n            }\n          } else if (chr == '$') {\n            if (inp[pos + 1] != '/' && inp[pos + 1] != '|' && inp[pos + 1] != ')') nonLethalError = Tokenizer.Error.DollarShouldBeEnd;\n          } else if (chr == '}') {\n            nonLethalError = Tokenizer.Error.MissingOpeningCurly;\n          } else {\n            // it's a \"character\" (can be group or class), something to match\n            // match parenthesis\n            if (chr == '(') {\n              parens.push(pos - start);\n            } else if (chr == ')') {\n              if (parens.length == 0) {\n                nonLethalError = {\n                  start: start,\n                  stop: pos,\n                  name: 14\n                  /*error*/\n                  ,\n                  tokenError: true,\n                  error: Tokenizer.Error.RegexNoOpenGroups\n                };\n              } else {\n                var twin = parens.pop();\n                var now = pos - start;\n                twinfo[twin] = now;\n                twinfo[now] = twin;\n              }\n            } // first process character class\n\n\n            if (chr == '[') {\n              var before = pos - start;\n\n              while (++pos < inp.length && shadowInp[pos] != '\\n' && inp[pos] != ']') {\n                // only newline is not allowed in class range\n                // anything else can be escaped, most of it does not have to be escaped...\n                if (inp[pos] == '\\\\') {\n                  if (shadowInp[pos + 1] == '\\n') break;else ++pos; // skip next char. (mainly prohibits ] to be picked up as closing the group...)\n                }\n              }\n\n              if (inp[pos] != ']') {\n                returnValue = {\n                  start: start,\n                  stop: pos,\n                  name: 14\n                  /*error*/\n                  ,\n                  tokenError: true,\n                  error: Tokenizer.Error.ClosingClassRangeNotFound\n                };\n                this.errorStack.push(returnValue);\n                break;\n              } else {\n                var after = pos - start;\n                twinfo[before] = after;\n                twinfo[after] = before;\n              }\n            } else if (chr == '\\\\' && shadowInp[pos + 1] != '\\n') {\n              // is ok anywhere in the regex (match next char literally, regardless of its otherwise special meaning)\n              ++pos;\n            } // now process repeaters (+, ? and *)\n            // non-collecting group (?:...) and positive (?=...) or negative (?!...) lookahead\n\n\n            if (chr == '(') {\n              if (inp[pos + 1] == '?' && (inp[pos + 2] == ':' || inp[pos + 2] == '=' || inp[pos + 2] == '!')) {\n                pos += 2;\n              }\n            } // matching \"char\"\n            else if (inp[pos + 1] == '?') ++pos;else if (inp[pos + 1] == '*' || inp[pos + 1] == '+') {\n                ++pos;\n                if (inp[pos + 1] == '?') ++pos; // non-greedy match\n              } else if (inp[pos + 1] == '{') {\n                pos += 1;\n                var before = pos - start; // quantifier:\n                // - {n}\n                // - {n,}\n                // - {n,m}\n\n                if (!/[0-9]/.test(inp[pos + 1])) {\n                  nonLethalError = Tokenizer.Error.QuantifierRequiresNumber;\n                }\n\n                while (++pos < inp.length && /[0-9]/.test(inp[pos + 1]));\n\n                if (inp[pos + 1] == ',') {\n                  ++pos;\n\n                  while (pos < inp.length && /[0-9]/.test(inp[pos + 1])) ++pos;\n                }\n\n                if (inp[pos + 1] != '}') {\n                  nonLethalError = Tokenizer.Error.QuantifierRequiresClosingCurly;\n                } else {\n                  ++pos;\n                  var after = pos - start;\n                  twinfo[before] = after;\n                  twinfo[after] = before;\n                  if (inp[pos + 1] == '?') ++pos; // non-greedy match\n                }\n              }\n          }\n        } // if found=false, fail right now. otherwise try to parse an identifiername (that's all RegularExpressionFlags is..., but it's constructed in a stupid fashion)\n\n\n        if (!found || returnValue) {\n          if (!returnValue) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              tokenError: true,\n              error: Tokenizer.Error.UnterminatedRegularExpressionOther\n            };\n            this.errorStack.push(returnValue);\n          }\n        } else {\n          // this is the identifier scanner, for now\n          do ++pos; while (pos < inp.length && this.hashAsciiIdentifier[inp[pos]]);\n          /*this.regexAsciiIdentifier.test(inp[pos])*/\n\n\n          if (parens.length) {\n            // nope, this is still an error, there was at least one paren that did not have a matching twin\n            if (parens.length > 0) returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              tokenError: true,\n              error: Tokenizer.Error.RegexOpenGroup\n            };\n            this.errorStack.push(returnValue);\n          } else if (nonLethalError) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              errorHasContent: true,\n              tokenError: true,\n              error: nonLethalError\n            };\n            this.errorStack.push(returnValue);\n          } else {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 1\n              /*REG_EX*/\n              ,\n              isPrimitive: true\n            };\n          }\n        }\n\n        returnValue.twinfo = twinfo;\n      } else {\n        // note: operators need to be ordered from longest to smallest. regex will take care of the rest.\n        // no need to worry about div vs regex. if looking for regex, earlier if will have eaten it\n        //var result = this.regexPunctuators.exec(inp.substring(pos,pos+4));\n        // note: due to the regex, the single forward slash might be caught by an earlier part of the regex. so check for that.\n        var result = part[8] || part[9];\n\n        if (result) {\n          //result = result[1];\n          returnValue = {\n            start: pos,\n            stop: pos += result.length,\n            name: 11\n            /*PUNCTUATOR*/\n            ,\n            value: result\n          };\n        } else {\n          var found = false; // identifiers cannot start with a number. but if the leading string would be a number, another if would have eaten it already for numeric literal :)\n\n          while (pos < inp.length) {\n            var c = inp[pos];\n            if (this.hashAsciiIdentifier[c]) ++pos; //if (this.regexAsciiIdentifier.test(c)) ++pos;\n            else if (c == '\\\\' && this.regexUnicodeEscape.test(inp.substring(pos, pos + 6))) pos += 6; // this is like a \\uxxxx\n              // ok, now test unicode ranges...\n              // basically this hardly ever happens so there's little risk of this hitting performance\n              // however, if you do happen to have used them, it's not a problem. the parser will support it :)\n              else if (this.Unicode) {\n                  // the unicode is optional.\n                  // these chars may not be part of identifier. i want to try to prevent running the unicode regexes here...\n                  if (this.hashIdentifierStop[c]\n                  /*this.regexIdentifierStop.test(c)*/\n                  ) break; // for most scripts, the code wont reach here. which is good, because this is going to be relatively slow :)\n\n                  var Unicode = this.Unicode; // cache\n\n                  if (!( // these may all occur in an identifier... (pure a specification compliance thing :)\n                  Unicode.Lu.test(c) || Unicode.Ll.test(c) || Unicode.Lt.test(c) || Unicode.Lm.test(c) || Unicode.Lo.test(c) || Unicode.Nl.test(c) || Unicode.Mn.test(c) || Unicode.Mc.test(c) || Unicode.Nd.test(c) || Unicode.Pc.test(c) || Unicode.sp.test(c))) break; // end of match.\n                  // passed, next char\n\n                  ++pos;\n                } else break; // end of match.\n\n            found = true;\n          }\n\n          if (found) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 2\n              /*IDENTIFIER*/\n              ,\n              value: inp.substring(start, pos)\n            };\n            if (returnValue.value == 'undefined' || returnValue.value == 'null' || returnValue.value == 'true' || returnValue.value == 'false') returnValue.isPrimitive = true;\n          } else {\n            if (inp[pos] == '`') {\n              returnValue = {\n                start: start,\n                stop: pos + 1,\n                name: 14\n                /*error*/\n                ,\n                tokenError: true,\n                error: Tokenizer.Error.BacktickNotSupported\n              };\n              this.errorStack.push(returnValue);\n            } else if (inp[pos] == '\\\\') {\n              if (inp[pos + 1] == 'u') {\n                returnValue = {\n                  start: start,\n                  stop: pos + 1,\n                  name: 14\n                  /*error*/\n                  ,\n                  tokenError: true,\n                  error: Tokenizer.Error.InvalidUnicodeEscape\n                };\n                this.errorStack.push(returnValue);\n              } else {\n                returnValue = {\n                  start: start,\n                  stop: pos + 1,\n                  name: 14\n                  /*error*/\n                  ,\n                  tokenError: true,\n                  error: Tokenizer.Error.InvalidBackslash\n                };\n                this.errorStack.push(returnValue);\n              }\n            } else {\n              returnValue = {\n                start: start,\n                stop: pos + 1,\n                name: 14\n                /*error*/\n                ,\n                tokenError: true,\n                error: Tokenizer.Error.Unknown,\n                value: c\n              };\n              this.errorStack.push(returnValue); // try to skip this char. it's not going anywhere.\n            }\n\n            ++pos;\n          }\n        }\n      }\n\n      if (returnValue) {\n        // note that ASI's are slipstreamed in here from the parser since the tokenizer cant determine that\n        // if this part ever changes, make sure you change that too :)\n        returnValue.tokposw = this.wtree.length;\n        this.wtree.push(returnValue);\n\n        if (!returnValue.isWhite) {\n          returnValue.tokposb = this.btree.length;\n          this.btree.push(returnValue);\n        }\n      }\n    } while (stack && returnValue && returnValue.isWhite); // WHITE_SPACE LINETERMINATOR COMMENT_SINGLE COMMENT_MULTI\n\n\n    ++this.tokenCountNoWhite;\n    this.pos = pos;\n    if (matchedNewline) returnValue.newline = true;\n    return returnValue;\n  },\n  addTokenToStreamBefore: function (token, match) {\n    var wtree = this.wtree;\n    var btree = this.btree;\n\n    if (match.name == 12\n    /*asi*/\n    ) {\n        token.tokposw = wtree.length;\n        wtree.push(token);\n        token.tokposb = btree.length;\n        btree.push(token);\n      } else {\n      token.tokposw = match.tokposw;\n      wtree[token.tokposw] = token;\n      match.tokposw += 1;\n      wtree[match.tokposw] = match;\n\n      if (match.tokposb) {\n        token.tokposb = match.tokposb;\n        btree[token.tokposb] = token;\n        match.tokposb += 1;\n        btree[match.tokposb] = match;\n      }\n    }\n  },\n  oldNumberParser: function (pos, chr, inp, returnValue, start, Tokenizer) {\n    ++pos; // either: 0x 0X 0 .3\n\n    if (chr == '0' && (inp[pos] == 'x' || inp[pos] == 'X')) {\n      // parsing hex\n      while (++pos < inp.length && this.hashHex[inp[pos]]); // this.regexHex.test(inp[pos]));\n\n\n      returnValue = {\n        start: start,\n        stop: pos,\n        name: 3\n        /*NUMERIC_HEX*/\n        ,\n        isPrimitive: true,\n        isNumber: true\n      };\n    } else {\n      var parsingOctal = chr == '0' && inp[pos] >= '0' && inp[pos] <= '9'; // parsing dec\n\n      if (chr != '.') {\n        // integer part\n        while (pos < inp.length && inp[pos] >= '0' && inp[pos] <= '9') ++pos;\n\n        if (inp[pos] == '.') ++pos;\n      } // decimal part\n\n\n      while (pos < inp.length && inp[pos] >= '0' && inp[pos] <= '9') ++pos; // exponent part\n\n\n      if (inp[pos] == 'e' || inp[pos] == 'E') {\n        if (inp[++pos] == '+' || inp[pos] == '-') ++pos;\n        var expPosBak = pos;\n\n        while (pos < inp.length && inp[pos] >= '0' && inp[pos] <= '9') ++pos;\n\n        if (expPosBak == pos) {\n          returnValue = {\n            start: start,\n            stop: pos,\n            name: 14\n            /*error*/\n            ,\n            tokenError: true,\n            error: Tokenizer.Error.NumberExponentRequiresDigits\n          };\n          this.errorStack.push(returnValue);\n        }\n      }\n\n      if (returnValue.name != 14\n      /*error*/\n      ) {\n          if (parsingOctal) {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 14\n              /*error*/\n              ,\n              isNumber: true,\n              isOctal: true,\n              tokenError: true,\n              error: Tokenizer.Error.IllegalOctalEscape\n            };\n            this.errorStack.push(returnValue);\n            console.log(\"foo\");\n          } else {\n            returnValue = {\n              start: start,\n              stop: pos,\n              name: 4\n              /*NUMERIC_DEC*/\n              ,\n              isPrimitive: true,\n              isNumber: true\n            };\n          }\n        }\n    }\n\n    return [pos, returnValue];\n  },\n  tokens: function (arrx) {\n    arrx = arrx || [];\n    var n = 0;\n    var last;\n    var stack = [];\n\n    while ((last = this.storeCurrentAndFetchNextToken(!arrx[n++], false, false, true)) && last.name != 12\n    /*EOF*/\n    ) stack.push(last);\n\n    return stack;\n  },\n  fixValues: function () {\n    this.wtree.forEach(function (t) {\n      if (!t.value) t.value = this.inp.substring(t.start, t.stop);\n    }, this);\n  }\n}; //#ifdef TEST_SUITE\n\nTokenizer.escape = function (s) {\n  return s.replace(/\\n/g, '\\\\n').replace(/\\t/g, '\\\\t').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\uFFFF/g, '\\\\uFFFF').replace(/\\s/g, function (s) {\n    // replace whitespace as is...\n    var ord = s.charCodeAt(0).toString(16);\n\n    switch (ord.length) {\n      case 1:\n        ord = '000' + ord;\n        break;\n\n      case 2:\n        ord = '00' + ord;\n        break;\n\n      case 3:\n        ord = '0' + ord;\n        break;\n    }\n\n    return '\\\\u' + ord;\n  });\n};\n\nTokenizer.testSuite = function (arr) {\n  var out = document.createElement('pre');\n  document.body.appendChild(out);\n\n  var debug = function () {\n    var f = document.createElement('div');\n    f.innerHTML = Array.prototype.slice.call(arguments).join(' ');\n    out.appendChild(f);\n    return arguments[0];\n  };\n\n  debug(\"Running test suite...\", arr.length, \"tests\");\n  debug(' ');\n  var start = +new Date();\n  var ok = 0;\n  var fail = 0;\n\n  for (var i = 0; i < arr.length; ++i) {\n    var test = arr[i],\n        result;\n    var input = test[1];\n    var outputLen = test[2];\n    var regexHints = test[4] ? test[3] : null; // if flags, then len=4\n\n    var desc = test[4] || test[3];\n    var result = new Tokenizer(input).tokens(regexHints); // regexHints can be null, that's ok\n\n    if (result.length == outputLen) {\n      debug('<span class=\"green\">Test ' + i + ' ok:</span>', desc);\n      ++ok;\n    } else {\n      debug('<b class=\"red\">Test failed:</span>', desc, '(found', result.length, 'expected', outputLen + ')'), console.log(desc, result);\n      ++fail;\n    }\n\n    debug('<b>' + Tokenizer.escape(input) + '</b>');\n    debug('<br/>');\n  }\n\n  debug(\"Tokenizer test suite finished (\" + (+new Date() - start) + ' ms). ok:' + ok + ', fail:' + fail);\n}; //#endif\n\n\nTokenizer.regexWhiteSpace = /[ \\t\\u000B\\u000C\\u00A0\\uFFFF]/;\nTokenizer.regexLineTerminator = /[\\u000A\\u000D\\u2028\\u2029]/;\nTokenizer.regexAsciiIdentifier = /[a-zA-Z0-9\\$_]/;\nTokenizer.hashAsciiIdentifier = {\n  _: 1,\n  $: 1,\n  a: 1,\n  b: 1,\n  c: 1,\n  d: 1,\n  e: 1,\n  f: 1,\n  g: 1,\n  h: 1,\n  i: 1,\n  j: 1,\n  k: 1,\n  l: 1,\n  m: 1,\n  n: 1,\n  o: 1,\n  p: 1,\n  q: 1,\n  r: 1,\n  s: 1,\n  t: 1,\n  u: 1,\n  v: 1,\n  w: 1,\n  x: 1,\n  y: 1,\n  z: 1,\n  A: 1,\n  B: 1,\n  C: 1,\n  D: 1,\n  E: 1,\n  F: 1,\n  G: 1,\n  H: 1,\n  I: 1,\n  J: 1,\n  K: 1,\n  L: 1,\n  M: 1,\n  N: 1,\n  O: 1,\n  P: 1,\n  Q: 1,\n  R: 1,\n  S: 1,\n  T: 1,\n  U: 1,\n  V: 1,\n  W: 1,\n  X: 1,\n  Y: 1,\n  Z: 1,\n  0: 1,\n  1: 1,\n  2: 1,\n  3: 1,\n  4: 1,\n  5: 1,\n  6: 1,\n  7: 1,\n  8: 1,\n  9: 1\n};\nTokenizer.regexHex = /[0-9A-Fa-f]/;\nTokenizer.hashHex = {\n  0: 1,\n  1: 1,\n  2: 1,\n  3: 1,\n  4: 1,\n  5: 1,\n  6: 1,\n  7: 1,\n  8: 1,\n  9: 1,\n  a: 1,\n  b: 1,\n  c: 1,\n  d: 1,\n  e: 1,\n  f: 1,\n  A: 1,\n  B: 1,\n  C: 1,\n  D: 1,\n  E: 1,\n  F: 1\n};\nTokenizer.regexUnicodeEscape = /u[0-9A-Fa-f]{4}/; // the \\ is already checked at usage...\n\nTokenizer.regexIdentifierStop = /[\\>\\=\\!\\|\\<\\+\\-\\&\\*\\%\\^\\/\\{\\}\\(\\)\\[\\]\\.\\;\\,\\~\\?\\:\\ \\t\\n\\\\\\'\\\"]/;\nTokenizer.hashIdentifierStop = {\n  '>': 1,\n  '=': 1,\n  '!': 1,\n  '|': 1,\n  '<': 1,\n  '+': 1,\n  '-': 1,\n  '&': 1,\n  '*': 1,\n  '%': 1,\n  '^': 1,\n  '/': 1,\n  '{': 1,\n  '}': 1,\n  '(': 1,\n  ')': 1,\n  '[': 1,\n  ']': 1,\n  '.': 1,\n  ';': 1,\n  ',': 1,\n  '~': 1,\n  '?': 1,\n  ':': 1,\n  '\\\\': 1,\n  '\\'': 1,\n  '\"': 1,\n  ' ': 1,\n  '\\t': 1,\n  '\\n': 1\n};\nTokenizer.regexNewline = /\\n/g; //Tokenizer.regexPunctuators = /^(>>>=|===|!==|>>>|<<=|>>=|<=|>=|==|!=|\\+\\+|--|<<|>>|\\&\\&|\\|\\||\\+=|-=|\\*=|%=|\\&=|\\|=|\\^=|\\/=|\\{|\\}|\\(|\\)|\\[|\\]|\\.|;|,|<|>|\\+|-|\\*|%|\\||\\&|\\||\\^|!|~|\\?|:|=|\\/)/;\n\nTokenizer.Unidocde = window.Unicode;\nTokenizer.regexNumber = /^(?:(0[xX][0-9A-Fa-f]+)|((?:(?:(?:(?:[0-9]+)(?:\\.[0-9]*)?))|(?:\\.[0-9]+))(?:[eE][-+]?[0-9]{1,})?))/;\nTokenizer.regexNormalizeNewlines = /(\\u000D[^\\u000A])|[\\u2028\\u2029]/; //\t\t\t\t\t\t\t1 ws\t\t\t\t\t\t\t2 lt\t\t\t\t   3 scmt 4 mcmt 5/6 str 7 nr     8 rx  9 punc\n\nTokenizer.regexBig = /^([ \\t\\u000B\\u000C\\u00A0\\uFFFF])?([\\u000A\\u000D\\u2028\\u2029])?(\\/\\/)?(\\/\\*)?(')?(\")?(\\.?[0-9])?(?:(\\/)[^=])?(>>>=|===|!==|>>>|<<=|>>=|<=|>=|==|!=|\\+\\+|--|<<|>>|\\&\\&|\\|\\||\\+=|-=|\\*=|%=|\\&=|\\|=|\\^=|\\/=|\\{|\\}|\\(|\\)|\\[|\\]|\\.|;|,|<|>|\\+|-|\\*|%|\\||\\&|\\||\\^|!|~|\\?|:|=|\\/)?/;\nTokenizer.regexBigAlt = /([ \\t\\u000B\\u000C\\u00A0\\uFFFF])?([\\u000A\\u000D\\u2028\\u2029])?(\\/\\/)?(\\/\\*)?(')?(\")?(\\.?[0-9])?(?:(\\/)[^=])?(>>>=|===|!==|>>>|<<=|>>=|<=|>=|==|!=|\\+\\+|--|<<|>>|\\&\\&|\\|\\||\\+=|-=|\\*=|%=|\\&=|\\|=|\\^=|\\/=|\\{|\\}|\\(|\\)|\\[|\\]|\\.|;|,|<|>|\\+|-|\\*|%|\\||\\&|\\||\\^|!|~|\\?|:|=|\\/)?/g;\nTokenizer.Error = {\n  UnterminatedSingleStringNewline: {\n    msg: 'Newlines are not allowed in string literals'\n  },\n  UnterminatedSingleStringOther: {\n    msg: 'Unterminated single string'\n  },\n  UnterminatedDoubleStringNewline: {\n    msg: 'Newlines are not allowed in string literals'\n  },\n  UnterminatedDoubleStringOther: {\n    msg: 'Unterminated double string'\n  },\n  UnterminatedRegularExpressionNewline: {\n    msg: 'Newlines are not allowed in regular expressions'\n  },\n  NothingToRepeat: {\n    msg: 'Used a repeat character (*?+) in a regex without something prior to it to match'\n  },\n  ClosingClassRangeNotFound: {\n    msg: 'Unable to find ] for class range'\n  },\n  RegexOpenGroup: {\n    msg: 'Open group did not find closing parenthesis'\n  },\n  RegexNoOpenGroups: {\n    msg: 'Closing parenthesis found but no group open'\n  },\n  UnterminatedRegularExpressionOther: {\n    msg: 'Unterminated regular expression'\n  },\n  UnterminatedMultiLineComment: {\n    msg: 'Unterminated multi line comment'\n  },\n  UnexpectedIdentifier: {\n    msg: 'Unexpected identifier'\n  },\n  IllegalOctalEscape: {\n    msg: 'Octal escapes are not valid'\n  },\n  Unknown: {\n    msg: 'Unknown input'\n  },\n  // if this happens, my parser is bad :(\n  NumberExponentRequiresDigits: {\n    msg: 'Numbers with exponents require at least one digit after the `e`'\n  },\n  BacktickNotSupported: {\n    msg: 'The backtick is not used in js, maybe you copy/pasted from a fancy site/doc?'\n  },\n  InvalidUnicodeEscape: {\n    msg: 'Encountered an invalid unicode escape, must be followed by exactly four hex numbers'\n  },\n  InvalidBackslash: {\n    msg: 'Encountered a backslash where it not allowed'\n  },\n  StartOfMatchShouldBeAtStart: {\n    msg: 'The ^ signifies the start of match but was not found at a start'\n  },\n  DollarShouldBeEnd: {\n    msg: 'The $ signifies the stop of match but was not found at a stop'\n  },\n  QuantifierRequiresNumber: {\n    msg: 'Quantifier curly requires at least one digit before the comma'\n  },\n  QuantifierRequiresClosingCurly: {\n    msg: 'Quantifier curly requires to be closed'\n  },\n  MissingOpeningCurly: {\n    msg: 'Encountered closing quantifier curly without seeing an opening curly'\n  }\n};","map":{"version":3,"sources":["C:/Users/Human/Documents/MildMayhemFull/mildmayhem/client/node_modules/zeparser/Tokenizer.js"],"names":["exports","window","Unicode","require","Tokenizer","inp","shadowInp","replace","regexNormalizeNewlines","pos","line","column","cache","errorStack","wtree","btree","regexLineTerminator","regexAsciiIdentifier","hashAsciiIdentifier","hashHex","regexUnicodeEscape","regexIdentifierStop","hashIdentifierStop","regexNumber","regexNewline","regexBig","regexBigAlt","tokenCount","tokenCountNoWhite","errorEscape","prototype","storeCurrentAndFetchNextToken","noRegex","returnValue","stack","_dontStore","regex","matchedNewline","push","length","start","stop","name","chr","part2","substring","part","exec","col","isWhite","end","hasNewline","indexOf","isComment","newpos","value","tokenError","error","Error","UnterminatedMultiLineComment","shadowValue","i","test","isString","UnterminatedDoubleStringNewline","UnterminatedDoubleStringOther","isPrimitive","UnterminatedSingleStringNewline","UnterminatedSingleStringOther","nextPart","match","parsingOctal","isNumber","isOctal","IllegalOctalEscape","tmpReturnValue","oldNumberParser","twinfo","found","parens","nonLethalError","errorHasContent","UnterminatedRegularExpressionNewline","NothingToRepeat","StartOfMatchShouldBeAtStart","DollarShouldBeEnd","MissingOpeningCurly","RegexNoOpenGroups","twin","pop","now","before","ClosingClassRangeNotFound","after","QuantifierRequiresNumber","QuantifierRequiresClosingCurly","UnterminatedRegularExpressionOther","RegexOpenGroup","result","c","Lu","Ll","Lt","Lm","Lo","Nl","Mn","Mc","Nd","Pc","sp","BacktickNotSupported","InvalidUnicodeEscape","InvalidBackslash","Unknown","tokposw","tokposb","newline","addTokenToStreamBefore","token","expPosBak","NumberExponentRequiresDigits","console","log","tokens","arrx","n","last","fixValues","forEach","t","escape","s","ord","charCodeAt","toString","testSuite","arr","out","document","createElement","body","appendChild","debug","f","innerHTML","Array","slice","call","arguments","join","Date","ok","fail","input","outputLen","regexHints","desc","regexWhiteSpace","_","$","a","b","d","e","g","h","j","k","l","m","o","p","q","r","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","regexHex","Unidocde","msg","UnexpectedIdentifier"],"mappings":"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","sourcesContent":["if (typeof exports !== 'undefined') {\r\n\tvar window = {Unicode: require('./unicodecategories').Unicode};\r\n\texports.Tokenizer = Tokenizer;\r\n}\r\n\r\n/*!\r\n * Tokenizer for JavaScript / ECMAScript 5\r\n * (c) Peter van der Zee, qfox.nl\r\n */\r\n\r\n/**\r\n * @param {Object} inp\r\n */\r\nfunction Tokenizer(inp){\r\n\tthis.inp = inp||'';\r\n\t// replace all other line terminators with \\n (leave \\r\\n in tact though). we should probably remove the shadowInp when finished...\r\n\t// only replace \\r if it is not followed by a \\n else \\r\\n would become \\n\\n causing a double newline where it is just a single\r\n\tthis.shadowInp = (inp||'').replace(Tokenizer.regexNormalizeNewlines, '\\n');\r\n\tthis.pos = 0;\r\n\tthis.line = 0;\r\n\tthis.column = 0;\r\n\tthis.cache = {};\r\n\t\r\n\tthis.errorStack = [];\r\n\t\r\n\tthis.wtree = [];\r\n\tthis.btree = [];\r\n\t\r\n//\tthis.regexWhiteSpace = Tokenizer.regexWhiteSpace;\r\n\tthis.regexLineTerminator = Tokenizer.regexLineTerminator; // used in fallback\r\n\tthis.regexAsciiIdentifier = Tokenizer.regexAsciiIdentifier;\r\n\tthis.hashAsciiIdentifier = Tokenizer.hashAsciiIdentifier;\r\n//\tthis.regexHex = Tokenizer.regexHex;\r\n\tthis.hashHex = Tokenizer.hashHex\r\n\tthis.regexUnicodeEscape = Tokenizer.regexUnicodeEscape;\r\n\tthis.regexIdentifierStop = Tokenizer.regexIdentifierStop;\r\n\tthis.hashIdentifierStop = Tokenizer.hashIdentifierStop;\r\n//\tthis.regexPunctuators = Tokenizer.regexPunctuators;\r\n\tthis.regexNumber = Tokenizer.regexNumber;\r\n\tthis.regexNewline = Tokenizer.regexNewline;\r\n\t\r\n\tthis.regexBig = Tokenizer.regexBig;\r\n\tthis.regexBigAlt = Tokenizer.regexBigAlt;\r\n\t\r\n\tthis.tokenCount = 0;\r\n\tthis.tokenCountNoWhite = 0;\r\n\t\r\n\tthis.Unicode = window.Unicode;\r\n\t\r\n\t// if the Parser throws an error. it will set this property to the next match\r\n\t// at the time of the error (which was not what it was expecting at that point) \r\n\t// and pass on an \"error\" match. the error should be scooped on the stack and \r\n\t// this property should be returned, without looking at the input...\r\n\tthis.errorEscape = null;\r\n};\r\n\r\nTokenizer.prototype = {\r\n\tinp:null,\r\n\tshadowInp:null,\r\n\tpos:null,\r\n\tline:null,\r\n\tcolumn:null,\r\n\tcache:null,\r\n\terrorStack:null,\r\n\t\r\n\twtree: null, // contains whitespace (spaces, comments, newlines)\r\n\tbtree: null, // does not contain any whitespace tokens.\r\n\t\r\n\tregexLineTerminator:null,\r\n\tregexAsciiIdentifier:null,\r\n\thashAsciiIdentifier:null,\r\n\thashHex:null,\r\n\tregexUnicodeEscape:null,\r\n\tregexIdentifierStop:null,\r\n\thashIdentifierStop:null,\r\n\tregexNumber:null,\r\n\tregexNewline:null,\r\n\tregexBig:null,\r\n\tregexBigAlt:null,\r\n\ttokenCount:null,\r\n\ttokenCountNoWhite:null,\r\n\t\r\n\tUnicode:null,\r\n\t\r\n\t// storeCurrentAndFetchNextToken(bool, false, false true) to get just one token\r\n\tstoreCurrentAndFetchNextToken: function(noRegex, returnValue, stack, _dontStore){\r\n\t\tvar regex = !noRegex; // TOFIX :)\r\n\t\tvar pos = this.pos;\r\n\t\tvar inp = this.inp;\r\n\t\tvar shadowInp = this.shadowInp;\r\n\t\tvar matchedNewline = false;\r\n\t\tdo {\r\n\t\t\tif (!_dontStore) {\r\n\t\t\t\t++this.tokenCount;\r\n\t\t\t\tstack.push(returnValue);\r\n\t\t\t\t// did the parent Parser throw up?\r\n\t\t\t\tif (this.errorEscape) {\r\n\t\t\t\t\treturnValue = this.errorEscape;\r\n\t\t\t\t\tthis.errorEscape = null;\r\n\t\t\t\t\treturn returnValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t_dontStore = false;\r\n\t\t\r\n\t\t\tif (pos >= inp.length) {\r\n\t\t\t\treturnValue = {start:inp.length,stop:inp.length,name:12/*EOF*/};\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t\tvar returnValue = null;\r\n\t\t\r\n\t\t\tvar start = pos;\r\n\t\t\tvar chr = inp[pos];\r\n\t\r\n\t\t\t//\t\t\t\t\t\t\t1 ws\t\t\t\t\t\t\t2 lt\t\t\t\t   3 scmt 4 mcmt 5/6 str 7 nr     8 rx  9 punc\r\n\t\t\t//if (true) {\r\n\t\t\t\t// substring method (I think this is faster..)\r\n\t\t\t\tvar part2 = inp.substring(pos,pos+4);\r\n\t\t\t\tvar part = this.regexBig.exec(part2);\r\n\t\t\t//} else {\r\n\t\t\t//\t// non-substring method (lastIndex)\r\n\t\t\t//\t// this method does not need a substring to apply it\r\n\t\t\t//\tthis.regexBigAlt.lastIndex = pos;\r\n\t\t\t//\tvar part = this.regexBigAlt.exec(inp);\r\n\t\t\t//}\r\n\t\t\t\r\n\t\t\tif (part[1]) { //this.regexWhiteSpace.test(chr)) { // SP, TAB, VT, FF, NBSP, BOM (, TOFIX: USP)\r\n\t\t\t\t++pos;\r\n\t\t\t\treturnValue = {start:start,stop:pos,name:9/*WHITE_SPACE*/,line:this.line,col:this.column,isWhite:true};\r\n\t\t\t\t++this.column;\r\n\t\t\t} else if (part[2]) { //this.regexLineTerminator.test(chr)) { // LF, CR, LS, PS\r\n\t\t\t\tvar end = pos+1;\r\n\t\t\t\tif (chr=='\\r' && inp[pos+1] == '\\n') ++end; // support crlf=>lf\r\n\t\t\t\treturnValue = {start:pos,stop:end,name:10/*LINETERMINATOR*/,line:this.line,col:this.column,isWhite:true};\r\n\t\t\t\tpos = end;\r\n\t\t\t\t// mark newlines for ASI\r\n\t\t\t\tmatchedNewline = true;\r\n\t\t\t\t++this.line;\r\n\t\t\t\tthis.column = 0;\r\n\t\t\t\treturnValue.hasNewline = 1;\r\n\t\t\t} else if (part[3]) { //chr == '/' && inp[pos+1] == '/') {\r\n\t\t\t\tpos = shadowInp.indexOf('\\n',pos);\r\n\t\t\t\tif (pos == -1) pos = inp.length;\r\n\t\t\t\treturnValue = {start:start,stop:pos,name:7/*COMMENT_SINGLE*/,line:this.line,col:this.column,isComment:true,isWhite:true};\r\n\t\t\t\tthis.column = returnValue.stop;\r\n\t\t\t} else if (part[4]) { //chr == '/' && inp[pos+1] == '*') {\r\n\t\t\t\tvar newpos = inp.indexOf('*/',pos);\r\n\t\t\t\tif (newpos == -1) {\r\n\t\t\t\t\tnewpos = shadowInp.indexOf('\\n', pos);\r\n\t\t\t\t\tif (newpos < 0) pos += 2;\r\n\t\t\t\t\telse pos = newpos;\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,value:inp.substring(start, pos),line:this.line,col:this.column,isComment:true,isWhite:true,tokenError:true,error:Tokenizer.Error.UnterminatedMultiLineComment};\r\n\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos = newpos+2;\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:8/*COMMENT_MULTI*/,value:inp.substring(start, pos),line:this.line,col:this.column,isComment:true,isWhite:true};\r\n\t\r\n\t\t\t\t\t// multi line comments are also reason for asi, but only if they contain at least one newline (use shadow input, because all line terminators would be valid...)\r\n\t\t\t\t\tvar shadowValue = shadowInp.substring(start, pos);\r\n\t\t\t\t\tvar i = 0, hasNewline = 0;\r\n\t\t\t\t\twhile (i < (i = shadowValue.indexOf('\\n', i+1))) {\r\n\t\t\t\t\t\t++hasNewline;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasNewline) {\r\n\t\t\t\t\t\tmatchedNewline = true;\r\n\t\t\t\t\t\treturnValue.hasNewline = hasNewline;\r\n\t\t\t\t\t\tthis.line += hasNewline;\r\n\t\t\t\t\t\tthis.column = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.column = returnValue.stop;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (part[5]) { //chr == \"'\") {\r\n\t\t\t\t// old method\r\n\t\t\t\t//console.log(\"old method\");\r\n\t\t\t\t\r\n\t\t\t\tvar hasNewline = 0;\r\n\t\t\t\tdo {\r\n\t\t\t\t\t// process escaped characters\r\n\t\t\t\t\twhile (pos < inp.length && inp[++pos] == '\\\\') {\r\n\t\t\t\t\t\tif (shadowInp[pos+1] == '\\n') ++hasNewline;\r\n\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.regexLineTerminator.test(inp[pos])) {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,value:inp.substring(start, pos),isString:true,tokenError:true,error:Tokenizer.Error.UnterminatedDoubleStringNewline};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (pos < inp.length && inp[pos] != \"'\");\r\n\t\t\t\tif (returnValue) {} // error\r\n\t\t\t\telse if (inp[pos] != \"'\") {\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,value:inp.substring(start, pos),isString:true,tokenError:true,error:Tokenizer.Error.UnterminatedDoubleStringOther};\r\n\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t++pos;\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:5/*STRING_SINGLE*/,isPrimitive:true,isString:true};\r\n\t\t\t\t\tif (hasNewline) {\r\n\t\t\t\t\t\treturnValue.hasNewline = hasNewline;\r\n\t\t\t\t\t\tthis.line += hasNewline;\r\n\t\t\t\t\t\tthis.column = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.column += (pos-start);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t} else if (part[6]) { //chr == '\"') {\r\n\t\t\t\tvar hasNewline = 0;\r\n\t\t\t\t// TODO: something like this: var regexmatch = /([^\\']|$)+/.match();\r\n\t\t\t\tdo {\r\n\t\t\t\t\t// process escaped chars\r\n\t\t\t\t\twhile (pos < inp.length && inp[++pos] == '\\\\') {\r\n\t\t\t\t\t\tif (shadowInp[pos+1] == '\\n') ++hasNewline;\r\n\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.regexLineTerminator.test(inp[pos])) {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,value:inp.substring(start, pos),isString:true,tokenError:true,error:Tokenizer.Error.UnterminatedSingleStringNewline};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (pos < inp.length && inp[pos] != '\"');\r\n\t\t\t\tif (returnValue) {}\r\n\t\t\t\telse if (inp[pos] != '\"') {\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,value:inp.substring(start, pos),isString:true,tokenError:true,error:Tokenizer.Error.UnterminatedSingleStringOther};\r\n\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t++pos;\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:6/*STRING_DOUBLE*/,isPrimitive:true,isString:true};\r\n\t\t\t\t\tif (hasNewline) {\r\n\t\t\t\t\t\treturnValue.hasNewline = hasNewline;\r\n\t\t\t\t\t\tthis.line += hasNewline;\r\n\t\t\t\t\t\tthis.column = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.column += (pos-start);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (part[7]) { //(chr >= '0' && chr <= '9') || (chr == '.' && inp[pos+1] >= '0' && inp[pos+1] <= '9')) {\r\n\t\t\t\tvar nextPart = inp.substring(pos, pos+30);\r\n\t\t\t\tvar match = nextPart.match(this.regexNumber);\r\n\t\t\t\tif (match[2]) { // decimal\r\n\t\t\t\t\tvar value = match[2];\r\n\t\t\t\t\tvar parsingOctal = value[0] == '0' && value[1] && value[1] != 'e' && value[1] != 'E' && value[1] != '.';\r\n\t\t\t\t\tif (parsingOctal) {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,isNumber:true,isOctal:true,tokenError:true,error:Tokenizer.Error.IllegalOctalEscape,value:value};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:start+value.length,name:4/*NUMERIC_DEC*/,isPrimitive:true,isNumber:true,value:value};\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (match[1]) { // hex\r\n\t\t\t\t\tvar value = match[1];\r\n\t\t\t\t\treturnValue = {start:start,stop:start+value.length,name:3/*NUMERIC_HEX*/,isPrimitive:true,isNumber:true,value:value};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow 'unexpected parser errror... regex fail :(';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (value.length < 300) {\r\n\t\t\t\t\tpos += value.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// old method of parsing numbers. only used for extremely long number literals (300+ chars).\r\n\t\t\t\t\t// this method does not require substringing... just memory :)\r\n\t\t\t\t\tvar tmpReturnValue = this.oldNumberParser(pos, chr, inp, returnValue, start, Tokenizer);\r\n\t\t\t\t\tpos = tmpReturnValue[0];\r\n\t\t\t\t\treturnValue = tmpReturnValue[1];\r\n\t\t\t\t}\r\n\t\t\t} else if (regex && part[8]) { //chr == '/') { // regex cannot start with /* (would be multiline comment, and not make sense anyways). but if it was /* then an earlier if would have eated it. so we only check for /\r\n\t\t\t\tvar twinfo = []; // matching {[( info\r\n\t\t\t\tvar found = false;\r\n\t\t\t\tvar parens = [];\r\n\t\t\t\tvar nonLethalError = null;\r\n\t\t\t\twhile (++pos < inp.length) {\r\n\t\t\t\t\tchr = shadowInp[pos];\r\n\t\t\t\t\t// parse RegularExpressionChar\r\n\t\t\t\t\tif (chr == '\\n') {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,tokenError:true,errorHasContent:true,error:Tokenizer.Error.UnterminatedRegularExpressionNewline};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\tbreak; // fail\r\n\t\t\t\t\t} else if (chr == '/') {\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else if (chr == '?' || chr == '*' || chr == '+') {\r\n\t\t\t\t\t\tnonLethalError = Tokenizer.Error.NothingToRepeat;\r\n\t\t\t\t\t} else if (chr == '^') {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tinp[pos-1] != '/' && \r\n\t\t\t\t\t\t\tinp[pos-1] != '|' && \r\n\t\t\t\t\t\t\tinp[pos-1] != '(' &&\r\n\t\t\t\t\t\t\t!(inp[pos-3] == '(' && inp[pos-2] == '?' && (inp[pos-1] == ':' || inp[pos-1] == '!' || inp[pos-1] == '='))\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tnonLethalError = Tokenizer.Error.StartOfMatchShouldBeAtStart;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (chr == '$') {\r\n\t\t\t\t\t\tif (inp[pos+1] != '/' && inp[pos+1] != '|' && inp[pos+1] != ')') nonLethalError = Tokenizer.Error.DollarShouldBeEnd;\r\n\t\t\t\t\t} else if (chr == '}') {\r\n\t\t\t\t\t\tnonLethalError = Tokenizer.Error.MissingOpeningCurly;\r\n\t\t\t\t\t} else { // it's a \"character\" (can be group or class), something to match\r\n\t\t\t\t\t\t// match parenthesis\r\n\t\t\t\t\t\tif (chr == '(') {\r\n\t\t\t\t\t\t\tparens.push(pos-start);\r\n\t\t\t\t\t\t} else if (chr == ')') {\r\n\t\t\t\t\t\t\tif (parens.length == 0) {\r\n\t\t\t\t\t\t\t\tnonLethalError = {start:start,stop:pos,name:14/*error*/,tokenError:true,error:Tokenizer.Error.RegexNoOpenGroups};\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvar twin = parens.pop();\r\n\t\t\t\t\t\t\t\tvar now = pos-start;\r\n\t\t\t\t\t\t\t\ttwinfo[twin] = now;\r\n\t\t\t\t\t\t\t\ttwinfo[now] = twin;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// first process character class\r\n\t\t\t\t\t\tif (chr == '[') {\r\n\t\t\t\t\t\t\tvar before = pos-start;\r\n\t\t\t\t\t\t\twhile (++pos < inp.length && shadowInp[pos] != '\\n' && inp[pos] != ']') {\r\n\t\t\t\t\t\t\t\t// only newline is not allowed in class range\r\n\t\t\t\t\t\t\t\t// anything else can be escaped, most of it does not have to be escaped...\r\n\t\t\t\t\t\t\t\tif (inp[pos] == '\\\\') {\r\n\t\t\t\t\t\t\t\t\tif (shadowInp[pos+1] == '\\n') break;\r\n\t\t\t\t\t\t\t\t\telse ++pos; // skip next char. (mainly prohibits ] to be picked up as closing the group...)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} \r\n\t\t\t\t\t\t\tif (inp[pos] != ']') {\r\n\t\t\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,tokenError:true,error:Tokenizer.Error.ClosingClassRangeNotFound};\r\n\t\t\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvar after = pos-start;\r\n\t\t\t\t\t\t\t\ttwinfo[before] = after;\r\n\t\t\t\t\t\t\t\ttwinfo[after] = before;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (chr == '\\\\' && shadowInp[pos+1] != '\\n') {\r\n\t\t\t\t\t\t\t// is ok anywhere in the regex (match next char literally, regardless of its otherwise special meaning)\r\n\t\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// now process repeaters (+, ? and *)\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// non-collecting group (?:...) and positive (?=...) or negative (?!...) lookahead\r\n\t\t\t\t\t\tif (chr == '(') {\r\n\t\t\t\t\t\t\tif (inp[pos+1] == '?' && (inp[pos+2] == ':' || inp[pos+2] == '=' || inp[pos+2] == '!')) {\r\n\t\t\t\t\t\t\t\tpos += 2;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// matching \"char\"\r\n\t\t\t\t\t\telse if (inp[pos+1] == '?') ++pos;\r\n\t\t\t\t\t\telse if (inp[pos+1] == '*' || inp[pos+1] == '+') {\r\n\t\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t\t\tif (inp[pos+1] == '?') ++pos; // non-greedy match\r\n\t\t\t\t\t\t} else if (inp[pos+1] == '{') {\r\n\t\t\t\t\t\t\tpos += 1;\r\n\t\t\t\t\t\t\tvar before = pos-start;\r\n\t\t\t\t\t\t\t// quantifier:\r\n\t\t\t\t\t\t\t// - {n}\r\n\t\t\t\t\t\t\t// - {n,}\r\n\t\t\t\t\t\t\t// - {n,m}\r\n\t\t\t\t\t\t\tif (!/[0-9]/.test(inp[pos+1])) {\r\n\t\t\t\t\t\t\t\tnonLethalError = Tokenizer.Error.QuantifierRequiresNumber;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\twhile (++pos < inp.length && /[0-9]/.test(inp[pos+1]));\r\n\t\t\t\t\t\t\tif (inp[pos+1] == ',') {\r\n\t\t\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t\t\t\twhile (pos < inp.length && /[0-9]/.test(inp[pos+1])) ++pos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (inp[pos+1] != '}') {\r\n\t\t\t\t\t\t\t\tnonLethalError = Tokenizer.Error.QuantifierRequiresClosingCurly;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t\t\t\tvar after = pos-start;\r\n\t\t\t\t\t\t\t\ttwinfo[before] = after;\r\n\t\t\t\t\t\t\t\ttwinfo[after] = before;\r\n\t\t\t\t\t\t\t\tif (inp[pos+1] == '?') ++pos; // non-greedy match\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if found=false, fail right now. otherwise try to parse an identifiername (that's all RegularExpressionFlags is..., but it's constructed in a stupid fashion)\r\n\t\t\t\tif (!found || returnValue) {\r\n\t\t\t\t\tif (!returnValue) {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,tokenError:true,error:Tokenizer.Error.UnterminatedRegularExpressionOther};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// this is the identifier scanner, for now\r\n\t\t\t\t\tdo ++pos;\r\n\t\t\t\t\twhile (pos < inp.length && this.hashAsciiIdentifier[inp[pos]]); /*this.regexAsciiIdentifier.test(inp[pos])*/ \r\n\t\r\n\t\t\t\t\tif (parens.length) {\r\n\t\t\t\t\t\t// nope, this is still an error, there was at least one paren that did not have a matching twin\r\n\t\t\t\t\t\tif (parens.length > 0) returnValue = {start:start,stop:pos,name:14/*error*/,tokenError:true,error:Tokenizer.Error.RegexOpenGroup};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t} else if (nonLethalError) {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,errorHasContent:true,tokenError:true,error:nonLethalError};\r\n\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:1/*REG_EX*/,isPrimitive:true};\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\treturnValue.twinfo = twinfo;\r\n\t\t\t} else {\r\n\t\t\t\t// note: operators need to be ordered from longest to smallest. regex will take care of the rest.\r\n\t\t\t\t// no need to worry about div vs regex. if looking for regex, earlier if will have eaten it\r\n\t\t\t\t//var result = this.regexPunctuators.exec(inp.substring(pos,pos+4));\r\n\t\t\t\t\r\n\t\t\t\t// note: due to the regex, the single forward slash might be caught by an earlier part of the regex. so check for that.\r\n\t\t\t\tvar result = part[8] || part[9];\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\t//result = result[1];\r\n\t\t\t\t\treturnValue = {start:pos,stop:pos+=result.length,name:11/*PUNCTUATOR*/,value:result};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t// identifiers cannot start with a number. but if the leading string would be a number, another if would have eaten it already for numeric literal :)\r\n\t\t\t\t\twhile (pos < inp.length) {\r\n\t\t\t\t\t\tvar c = inp[pos];\r\n\t\r\n\t\t\t\t\t\tif (this.hashAsciiIdentifier[c]) ++pos; //if (this.regexAsciiIdentifier.test(c)) ++pos;\r\n\t\t\t\t\t\telse if (c == '\\\\' && this.regexUnicodeEscape.test(inp.substring(pos,pos+6))) pos += 6; // this is like a \\uxxxx\r\n\t\t\t\t\t\t// ok, now test unicode ranges...\r\n\t\t\t\t\t\t// basically this hardly ever happens so there's little risk of this hitting performance\r\n\t\t\t\t\t\t// however, if you do happen to have used them, it's not a problem. the parser will support it :)\r\n\t\t\t\t\t\telse if (this.Unicode) { // the unicode is optional.\r\n\t\t\t\t\t\t\t// these chars may not be part of identifier. i want to try to prevent running the unicode regexes here...\r\n\t\t\t\t\t\t\tif (this.hashIdentifierStop[c] /*this.regexIdentifierStop.test(c)*/) break;\r\n\t\t\t\t\t\t\t// for most scripts, the code wont reach here. which is good, because this is going to be relatively slow :)\r\n\t\t\t\t\t\t\tvar Unicode = this.Unicode; // cache\r\n\t\t\t\t\t\t\tif (!(\r\n\t\t\t\t\t\t\t\t\t// these may all occur in an identifier... (pure a specification compliance thing :)\r\n\t\t\t\t\t\t\t\t\tUnicode.Lu.test(c) || Unicode.Ll.test(c) || Unicode.Lt.test(c) || Unicode.Lm.test(c) || \r\n\t\t\t\t\t\t\t\t\tUnicode.Lo.test(c) || Unicode.Nl.test(c) || Unicode.Mn.test(c) || Unicode.Mc.test(c) ||\r\n\t\t\t\t\t\t\t\t\tUnicode.Nd.test(c) || Unicode.Pc.test(c) || Unicode.sp.test(c)\r\n\t\t\t\t\t\t\t)) break; // end of match.\r\n\t\t\t\t\t\t\t// passed, next char\r\n\t\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t\t} else break; // end of match.\r\n\t\t\t\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t}\r\n\t\t\r\n\t\t\t\t\tif (found) {\r\n\t\t\t\t\t\treturnValue = {start:start,stop:pos,name:2/*IDENTIFIER*/,value:inp.substring(start,pos)};\r\n\t\t\t\t\t\tif (returnValue.value == 'undefined' || returnValue.value == 'null' || returnValue.value == 'true' || returnValue.value == 'false') returnValue.isPrimitive = true;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (inp[pos] == '`') {\r\n\t\t\t\t\t\t\treturnValue = {start:start,stop:pos+1,name:14/*error*/,tokenError:true,error:Tokenizer.Error.BacktickNotSupported};\r\n\t\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\t} else if (inp[pos] == '\\\\') {\r\n\t\t\t\t\t\t\tif (inp[pos+1] == 'u') {\r\n\t\t\t\t\t\t\t\treturnValue = {start:start,stop:pos+1,name:14/*error*/,tokenError:true,error:Tokenizer.Error.InvalidUnicodeEscape};\r\n\t\t\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturnValue = {start:start,stop:pos+1,name:14/*error*/,tokenError:true,error:Tokenizer.Error.InvalidBackslash};\r\n\t\t\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturnValue = {start:start,stop:pos+1,name:14/*error*/,tokenError:true,error:Tokenizer.Error.Unknown,value:c};\r\n\t\t\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\t\t\t// try to skip this char. it's not going anywhere.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t++pos;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (returnValue) {\r\n\t\t\t\t// note that ASI's are slipstreamed in here from the parser since the tokenizer cant determine that\r\n\t\t\t\t// if this part ever changes, make sure you change that too :)\r\n\t\t\t\treturnValue.tokposw = this.wtree.length;\r\n\t\t\t\tthis.wtree.push(returnValue);\r\n\t\t\t\tif (!returnValue.isWhite) {\r\n\t\t\t\t\treturnValue.tokposb = this.btree.length;\r\n\t\t\t\t\tthis.btree.push(returnValue);\r\n\t\t\t\t} \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t} while (stack && returnValue && returnValue.isWhite); // WHITE_SPACE LINETERMINATOR COMMENT_SINGLE COMMENT_MULTI\r\n\t\t++this.tokenCountNoWhite;\r\n\t\t\r\n\t\tthis.pos = pos;\r\n\t\r\n\t\tif (matchedNewline) returnValue.newline = true;\r\n\t\treturn returnValue;\r\n\t},\r\n\taddTokenToStreamBefore: function(token, match){\r\n\t\tvar wtree = this.wtree;\r\n\t\tvar btree = this.btree;\r\n\t\tif (match.name == 12/*asi*/) {\r\n\t\t\ttoken.tokposw = wtree.length;\r\n\t\t\twtree.push(token);\r\n\t\t\ttoken.tokposb = btree.length;\r\n\t\t\tbtree.push(token);\r\n\t\t} else {\r\n\t\t\ttoken.tokposw = match.tokposw;\r\n\t\t\twtree[token.tokposw] = token;\r\n\t\t\tmatch.tokposw += 1;\r\n\t\t\twtree[match.tokposw] = match;\r\n\r\n\t\t\tif (match.tokposb) {\r\n\t\t\t\ttoken.tokposb = match.tokposb;\r\n\t\t\t\tbtree[token.tokposb] = token;\r\n\t\t\t\tmatch.tokposb += 1;\r\n\t\t\t\tbtree[match.tokposb] = match;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\toldNumberParser: function(pos, chr, inp, returnValue, start, Tokenizer){\r\n\t\t++pos;\r\n\t\t// either: 0x 0X 0 .3\r\n\t\tif (chr == '0' && (inp[pos] == 'x' || inp[pos] == 'X')) {\r\n\t\t\t// parsing hex\r\n\t\t\twhile (++pos < inp.length && this.hashHex[inp[pos]]); // this.regexHex.test(inp[pos]));\r\n\t\t\treturnValue = {start:start,stop:pos,name:3/*NUMERIC_HEX*/,isPrimitive:true,isNumber:true};\r\n\t\t} else {\r\n\t\t\tvar parsingOctal = chr == '0' && inp[pos] >= '0' && inp[pos] <= '9';\r\n\t\t\t// parsing dec\r\n\t\t\tif (chr != '.') { // integer part\r\n\t\t\t\twhile (pos < inp.length && inp[pos] >= '0' && inp[pos] <= '9') ++pos;\r\n\t\t\t\tif (inp[pos] == '.') ++pos;\r\n\t\t\t}\r\n\t\t\t// decimal part\r\n\t\t\twhile (pos < inp.length && inp[pos] >= '0' && inp[pos] <= '9') ++pos;\r\n\t\t\t// exponent part\r\n\t\t\tif (inp[pos] == 'e' || inp[pos] == 'E') {\r\n\t\t\t\tif (inp[++pos] == '+' || inp[pos] == '-') ++pos;\r\n\t\t\t\tvar expPosBak = pos;\r\n\t\t\t\twhile (pos < inp.length && inp[pos] >= '0' && inp[pos] <= '9') ++pos;\r\n\t\t\t\tif (expPosBak == pos) {\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,tokenError:true,error:Tokenizer.Error.NumberExponentRequiresDigits};\r\n\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (returnValue.name != 14/*error*/) {\r\n\t\t\t\tif (parsingOctal) {\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:14/*error*/,isNumber:true,isOctal:true,tokenError:true,error:Tokenizer.Error.IllegalOctalEscape};\r\n\t\t\t\t\tthis.errorStack.push(returnValue);\r\n\t\t\t\t\tconsole.log(\"foo\")\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturnValue = {start:start,stop:pos,name:4/*NUMERIC_DEC*/,isPrimitive:true,isNumber:true};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [pos, returnValue];\r\n\t},\r\n\ttokens: function(arrx){\r\n\t\tarrx = arrx || [];\r\n\t\tvar n = 0;\r\n\t\tvar last;\r\n\t\tvar stack = [];\r\n\t\twhile ((last = this.storeCurrentAndFetchNextToken(!arrx[n++], false, false, true)) && last.name != 12/*EOF*/) stack.push(last);\r\n\t\treturn stack;\r\n\t},\r\n\tfixValues: function(){\r\n\t\tthis.wtree.forEach(function(t){\r\n\t\t\tif (!t.value) t.value = this.inp.substring(t.start, t.stop);\r\n\t\t},this);\r\n\t}\r\n};\r\n\r\n//#ifdef TEST_SUITE\r\nTokenizer.escape = function(s){\r\n\treturn s.replace(/\\n/g,'\\\\n').replace(/\\t/g,'\\\\t').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\\uFFFF/g, '\\\\uFFFF').replace(/\\s/g, function(s){\r\n\t\t// replace whitespace as is...\r\n\t\tvar ord = s.charCodeAt(0).toString(16);\r\n\t\tswitch (ord.length) {\r\n\t\t\tcase 1: ord = '000'+ord; break;\r\n\t\t\tcase 2: ord = '00'+ord; break;\r\n\t\t\tcase 3: ord = '0'+ord; break;\r\n\t\t}\r\n\t\treturn '\\\\u'+ord;\r\n\t});\r\n};\r\nTokenizer.testSuite = function(arr){\r\n\tvar out = document.createElement('pre');\r\n\tdocument.body.appendChild(out);\r\n\tvar debug = function(){\r\n\t\tvar f = document.createElement('div');\r\n\t\tf.innerHTML = Array.prototype.slice.call(arguments).join(' ');\r\n\t\tout.appendChild(f);\r\n\t\treturn arguments[0];\r\n\t};\r\n\r\n\tdebug(\"Running test suite...\",arr.length,\"tests\");\r\n\tdebug(' ');\r\n\tvar start = +new Date;\r\n\tvar ok = 0;\r\n\tvar fail = 0;\r\n\tfor (var i=0; i<arr.length; ++i) {\r\n\t\tvar test = arr[i], result;\r\n\t\tvar input = test[1];\r\n\t\tvar outputLen = test[2];\r\n\t\tvar regexHints = test[4] ? test[3] : null; // if flags, then len=4\r\n\t\tvar desc = test[4] || test[3];\r\n\t\t\r\n\t\tvar result = new Tokenizer(input).tokens(regexHints); // regexHints can be null, that's ok\r\n\t\tif (result.length == outputLen) {\r\n\t\t\tdebug('<span class=\"green\">Test '+i+' ok:</span>',desc);\r\n\t\t\t++ok;\r\n\t\t} else {\r\n\t\t\tdebug('<b class=\"red\">Test failed:</span>',desc,'(found',result.length,'expected',outputLen+')'),console.log(desc, result);\r\n\t\t\t++fail;\r\n\t\t}\r\n\t\tdebug('<b>'+Tokenizer.escape(input)+'</b>');\r\n\t\tdebug('<br/>');\r\n\t}\r\n\tdebug(\"Tokenizer test suite finished (\"+(+new Date - start)+' ms). ok:'+ok+', fail:'+fail);\r\n};\r\n//#endif\r\n\r\nTokenizer.regexWhiteSpace = /[ \\t\\u000B\\u000C\\u00A0\\uFFFF]/;\r\nTokenizer.regexLineTerminator = /[\\u000A\\u000D\\u2028\\u2029]/;\r\nTokenizer.regexAsciiIdentifier = /[a-zA-Z0-9\\$_]/;\r\nTokenizer.hashAsciiIdentifier = {_:1,$:1,a:1,b:1,c:1,d:1,e:1,f:1,g:1,h:1,i:1,j:1,k:1,l:1,m:1,n:1,o:1,p:1,q:1,r:1,s:1,t:1,u:1,v:1,w:1,x:1,y:1,z:1,A:1,B:1,C:1,D:1,E:1,F:1,G:1,H:1,I:1,J:1,K:1,L:1,M:1,N:1,O:1,P:1,Q:1,R:1,S:1,T:1,U:1,V:1,W:1,X:1,Y:1,Z:1,0:1,1:1,2:1,3:1,4:1,5:1,6:1,7:1,8:1,9:1};\r\nTokenizer.regexHex = /[0-9A-Fa-f]/;\r\nTokenizer.hashHex = {0:1,1:1,2:1,3:1,4:1,5:1,6:1,7:1,8:1,9:1,a:1,b:1,c:1,d:1,e:1,f:1,A:1,B:1,C:1,D:1,E:1,F:1};\r\nTokenizer.regexUnicodeEscape = /u[0-9A-Fa-f]{4}/; // the \\ is already checked at usage...\r\nTokenizer.regexIdentifierStop = /[\\>\\=\\!\\|\\<\\+\\-\\&\\*\\%\\^\\/\\{\\}\\(\\)\\[\\]\\.\\;\\,\\~\\?\\:\\ \\t\\n\\\\\\'\\\"]/; \r\nTokenizer.hashIdentifierStop = {'>':1,'=':1,'!':1,'|':1,'<':1,'+':1,'-':1,'&':1,'*':1,'%':1,'^':1,'/':1,'{':1,'}':1,'(':1,')':1,'[':1,']':1,'.':1,';':1,',':1,'~':1,'?':1,':':1,'\\\\':1,'\\'':1,'\"':1,' ':1,'\\t':1,'\\n':1};\r\nTokenizer.regexNewline = /\\n/g;\r\n//Tokenizer.regexPunctuators = /^(>>>=|===|!==|>>>|<<=|>>=|<=|>=|==|!=|\\+\\+|--|<<|>>|\\&\\&|\\|\\||\\+=|-=|\\*=|%=|\\&=|\\|=|\\^=|\\/=|\\{|\\}|\\(|\\)|\\[|\\]|\\.|;|,|<|>|\\+|-|\\*|%|\\||\\&|\\||\\^|!|~|\\?|:|=|\\/)/;\r\nTokenizer.Unidocde = window.Unicode;\r\nTokenizer.regexNumber = /^(?:(0[xX][0-9A-Fa-f]+)|((?:(?:(?:(?:[0-9]+)(?:\\.[0-9]*)?))|(?:\\.[0-9]+))(?:[eE][-+]?[0-9]{1,})?))/;\r\nTokenizer.regexNormalizeNewlines = /(\\u000D[^\\u000A])|[\\u2028\\u2029]/;\r\n\r\n//\t\t\t\t\t\t\t1 ws\t\t\t\t\t\t\t2 lt\t\t\t\t   3 scmt 4 mcmt 5/6 str 7 nr     8 rx  9 punc\r\nTokenizer.regexBig = /^([ \\t\\u000B\\u000C\\u00A0\\uFFFF])?([\\u000A\\u000D\\u2028\\u2029])?(\\/\\/)?(\\/\\*)?(')?(\")?(\\.?[0-9])?(?:(\\/)[^=])?(>>>=|===|!==|>>>|<<=|>>=|<=|>=|==|!=|\\+\\+|--|<<|>>|\\&\\&|\\|\\||\\+=|-=|\\*=|%=|\\&=|\\|=|\\^=|\\/=|\\{|\\}|\\(|\\)|\\[|\\]|\\.|;|,|<|>|\\+|-|\\*|%|\\||\\&|\\||\\^|!|~|\\?|:|=|\\/)?/;\r\nTokenizer.regexBigAlt = /([ \\t\\u000B\\u000C\\u00A0\\uFFFF])?([\\u000A\\u000D\\u2028\\u2029])?(\\/\\/)?(\\/\\*)?(')?(\")?(\\.?[0-9])?(?:(\\/)[^=])?(>>>=|===|!==|>>>|<<=|>>=|<=|>=|==|!=|\\+\\+|--|<<|>>|\\&\\&|\\|\\||\\+=|-=|\\*=|%=|\\&=|\\|=|\\^=|\\/=|\\{|\\}|\\(|\\)|\\[|\\]|\\.|;|,|<|>|\\+|-|\\*|%|\\||\\&|\\||\\^|!|~|\\?|:|=|\\/)?/g;\r\n\r\nTokenizer.Error = {\r\n\tUnterminatedSingleStringNewline: {msg:'Newlines are not allowed in string literals'},\r\n\tUnterminatedSingleStringOther: {msg:'Unterminated single string'},\r\n\tUnterminatedDoubleStringNewline: {msg:'Newlines are not allowed in string literals'},\r\n\tUnterminatedDoubleStringOther: {msg:'Unterminated double string'},\r\n\tUnterminatedRegularExpressionNewline: {msg:'Newlines are not allowed in regular expressions'},\r\n\tNothingToRepeat: {msg:'Used a repeat character (*?+) in a regex without something prior to it to match'},\r\n\tClosingClassRangeNotFound: {msg: 'Unable to find ] for class range'},\r\n\tRegexOpenGroup: {msg: 'Open group did not find closing parenthesis'},\r\n\tRegexNoOpenGroups: {msg: 'Closing parenthesis found but no group open'},\r\n\tUnterminatedRegularExpressionOther: {msg:'Unterminated regular expression'},\r\n\tUnterminatedMultiLineComment: {msg:'Unterminated multi line comment'},\r\n\tUnexpectedIdentifier: {msg:'Unexpected identifier'},\r\n\tIllegalOctalEscape: {msg:'Octal escapes are not valid'},\r\n\tUnknown: {msg:'Unknown input'}, // if this happens, my parser is bad :(\r\n\tNumberExponentRequiresDigits: {msg:'Numbers with exponents require at least one digit after the `e`'},\r\n\tBacktickNotSupported: {msg:'The backtick is not used in js, maybe you copy/pasted from a fancy site/doc?'},\r\n\tInvalidUnicodeEscape: {msg:'Encountered an invalid unicode escape, must be followed by exactly four hex numbers'},\r\n\tInvalidBackslash: {msg:'Encountered a backslash where it not allowed'},\r\n\tStartOfMatchShouldBeAtStart: {msg: 'The ^ signifies the start of match but was not found at a start'},\r\n\tDollarShouldBeEnd: {msg: 'The $ signifies the stop of match but was not found at a stop'},\r\n\tQuantifierRequiresNumber: {msg:'Quantifier curly requires at least one digit before the comma'},\r\n\tQuantifierRequiresClosingCurly: {msg:'Quantifier curly requires to be closed'},\r\n\tMissingOpeningCurly: {msg:'Encountered closing quantifier curly without seeing an opening curly'}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}